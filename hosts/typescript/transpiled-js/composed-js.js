"use jco";
export function instantiate(getCoreModule, imports, instantiateCore = (module, importObject) => new WebAssembly.Instance(module, importObject)) {
  
  const _debugLog = (...args) => {
    if (!globalThis?.process?.env?.JCO_DEBUG) { return; }
    console.debug(...args);
  }
  const ASYNC_DETERMINISM = 'random';
  
  class GlobalComponentAsyncLowers {
    static map = new Map();
    
    constructor() { throw new Error('GlobalComponentAsyncLowers should not be constructed'); }
    
    static define(args) {
      const { componentIdx, qualifiedImportFn, fn } = args;
      let inner = GlobalComponentAsyncLowers.map.get(componentIdx);
      if (!inner) {
        inner = new Map();
        GlobalComponentAsyncLowers.map.set(componentIdx, inner);
      }
      
      inner.set(qualifiedImportFn, fn);
    }
    
    static lookup(componentIdx, qualifiedImportFn) {
      let inner = GlobalComponentAsyncLowers.map.get(componentIdx);
      if (!inner) {
        inner = new Map();
        GlobalComponentAsyncLowers.map.set(componentIdx, inner);
      }
      
      const found = inner.get(qualifiedImportFn);
      if (found) { return found; }
      
      // In some cases, async lowers are *not* host provided, and
      // but contain/will call an async function in the host.
      //
      // One such case is `stream.write`/`stream.read` trampolines which are
      // actually re-exported through a patch up container *before*
      // they call the relevant async host trampoline.
      //
      // So the path of execution from a component export would be:
      //
      // async guest export --> stream.write import (host wired) -> guest export (patch component) -> async host trampoline
      //
      // On top of all this, the trampoline that is eventually called is async,
      // so we must await the patched guest export call.
      //
      if (qualifiedImportFn.includes("[stream-write-") || qualifiedImportFn.includes("[stream-read-")) {
        return async (...args) => {
          const [originalFn, ...params] = args;
          return await originalFn(...params);
        };
      }
      
      // All other cases can call the registered function directly
      return (...args) => {
        const [originalFn, ...params] = args;
        return originalFn(...params);
      };
    }
  }
  
  class GlobalAsyncParamLowers {
    static map = new Map();
    
    static generateKey(args) {
      const { componentIdx, iface, fnName } = args;
      if (componentIdx === undefined) { throw new TypeError("missing component idx"); }
      if (iface === undefined) { throw new TypeError("missing iface name"); }
      if (fnName === undefined) { throw new TypeError("missing function name"); }
      return `${componentIdx}-${iface}-${fnName}`;
    }
    
    static define(args) {
      const { componentIdx, iface, fnName, fn } = args;
      if (!fn) { throw new TypeError('missing function'); }
      const key = GlobalAsyncParamLowers.generateKey(args);
      GlobalAsyncParamLowers.map.set(key, fn);
    }
    
    static lookup(args) {
      const { componentIdx, iface, fnName } = args;
      const key = GlobalAsyncParamLowers.generateKey(args);
      return GlobalAsyncParamLowers.map.get(key);
    }
  }
  
  class GlobalComponentMemories {
    static map = new Map();
    
    constructor() { throw new Error('GlobalComponentMemories should not be constructed'); }
    
    static save(args) {
      const { idx, componentIdx, memory } = args;
      let inner = GlobalComponentMemories.map.get(componentIdx);
      if (!inner) {
        inner = [];
        GlobalComponentMemories.map.set(componentIdx, inner);
      }
      inner.push({ memory, idx });
    }
    
    static getMemoriesForComponentIdx(componentIdx) {
      const metas = GlobalComponentMemories.map.get(componentIdx);
      return metas.map(meta => meta.memory);
    }
    
    static getMemory(componentIdx, idx) {
      const metas = GlobalComponentMemories.map.get(componentIdx);
      return metas.find(meta => meta.idx === idx)?.memory;
    }
  }
  
  class RepTable {
    #data = [0, null];
    #target;
    
    constructor(args) {
      this.target = args?.target;
    }
    
    insert(val) {
      _debugLog('[RepTable#insert()] args', { val, target: this.target });
      const freeIdx = this.#data[0];
      if (freeIdx === 0) {
        this.#data.push(val);
        this.#data.push(null);
        return (this.#data.length >> 1) - 1;
      }
      this.#data[0] = this.#data[freeIdx << 1];
      const placementIdx = freeIdx << 1;
      this.#data[placementIdx] = val;
      this.#data[placementIdx + 1] = null;
      return freeIdx;
    }
    
    get(rep) {
      _debugLog('[RepTable#get()] args', { rep, target: this.target });
      const baseIdx = rep << 1;
      const val = this.#data[baseIdx];
      return val;
    }
    
    contains(rep) {
      _debugLog('[RepTable#contains()] args', { rep, target: this.target });
      const baseIdx = rep << 1;
      return !!this.#data[baseIdx];
    }
    
    remove(rep) {
      _debugLog('[RepTable#remove()] args', { rep, target: this.target });
      if (this.#data.length === 2) { throw new Error('invalid'); }
      
      const baseIdx = rep << 1;
      const val = this.#data[baseIdx];
      if (val === 0) { throw new Error('invalid resource rep (cannot be 0)'); }
      
      this.#data[baseIdx] = this.#data[0];
      this.#data[0] = rep;
      
      return val;
    }
    
    clear() {
      _debugLog('[RepTable#clear()] args', { rep, target: this.target });
      this.#data = [0, null];
    }
  }
  const _coinFlip = () => { return Math.random() > 0.5; };
  let SCOPE_ID = 0;
  const I32_MIN = -2_147_483_648;
  const I32_MAX = 2_147_483_647;
  const _typeCheckValidI32 = (n) => typeof n === 'number' && n >= I32_MIN && n <= I32_MAX;
  
  const _typeCheckAsyncFn= (f) => {
    return f instanceof ASYNC_FN_CTOR;
  };
  
  const ASYNC_FN_CTOR = (async () => {}).constructor;
  const ASYNC_CURRENT_TASK_IDS = [];
  const ASYNC_CURRENT_COMPONENT_IDXS = [];
  
  function unpackCallbackResult(result) {
    _debugLog('[unpackCallbackResult()] args', { result });
    if (!(_typeCheckValidI32(result))) { throw new Error('invalid callback return value [' + result + '], not a valid i32'); }
    const eventCode = result & 0xF;
    if (eventCode < 0 || eventCode > 3) {
      throw new Error('invalid async return value [' + eventCode + '], outside callback code range');
    }
    if (result < 0 || result >= 2**32) { throw new Error('invalid callback result'); }
    // TODO: table max length check?
    const waitableSetRep = result >> 4;
    return [eventCode, waitableSetRep];
  }
  
  function promiseWithResolvers() {
    if (Promise.withResolvers) {
      return Promise.withResolvers();
    } else {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  }
  
  function _prepareCall(
  memoryIdx,
  getMemoryFn,
  startFn,
  returnFn,
  callerInstanceIdx,
  calleeInstanceIdx,
  taskReturnTypeIdx,
  isCalleeAsyncInt,
  stringEncoding,
  resultCountOrAsync,
  ) {
    _debugLog('[_prepareCall()]', {
      callerInstanceIdx,
      calleeInstanceIdx,
      taskReturnTypeIdx,
      isCalleeAsyncInt,
      stringEncoding,
      resultCountOrAsync,
    });
    const argArray = [...arguments];
    
    // Since Rust will happily pass large u32s over, resultCountOrAsync should be one of:
    // (a) u32 max size     => callee is async fn with no result
    // (b) u32 max size - 1 => callee is async fn with result
    // (c) any other value  => callee is sync with the given result count
    //
    // Due to JS handling the value as 2s complement, the `resultCountOrAsync` ends up being:
    // (a) -1 as u32 max size
    // (b) -2 as u32 max size - 1
    // (c) x
    //
    // Due to JS mishandling the value as 2s complement, the actual values we get are:
    // see. https://github.com/wasm-bindgen/wasm-bindgen/issues/1388
    let isAsync = false;
    let hasResultPointer = false;
    if (resultCountOrAsync === -1) {
      isAsync = true;
      hasResultPointer = false;
    } else if (resultCountOrAsync === -2) {
      isAsync = true;
      hasResultPointer = true;
    }
    
    const currentCallerTaskMeta = getCurrentTask(callerInstanceIdx);
    if (!currentCallerTaskMeta) {
      throw new Error('invalid/missing current task for caller during prepare call');
    }
    
    const currentCallerTask = currentCallerTaskMeta.task;
    if (!currentCallerTask) {
      throw new Error('unexpectedly missing task in meta for caller during prepare call');
    }
    
    if (currentCallerTask.componentIdx() !== callerInstanceIdx) {
      throw new Error(`task component idx [${ currentCallerTask.componentIdx() }] !== [${ callerInstanceIdx }] (callee ${ calleeInstanceIdx })`);
    }
    
    let getCalleeParamsFn;
    let resultPtr = null;
    if (hasResultPointer) {
      const directParamsArr = argArray.slice(11);
      getCalleeParamsFn = () => directParamsArr;
      resultPtr = argArray[10];
    } else {
      const directParamsArr = argArray.slice(10);
      getCalleeParamsFn = () => directParamsArr;
    }
    
    let encoding;
    switch (stringEncoding) {
      case 0:
      encoding = 'utf8';
      break;
      case 1:
      encoding = 'utf16';
      break;
      case 2:
      encoding = 'compact-utf16';
      break;
      default:
      throw new Error(`unrecognized string encoding enum [${stringEncoding}]`);
    }
    
    const [newTask, newTaskID] = createNewCurrentTask({
      componentIdx: calleeInstanceIdx,
      isAsync: isCalleeAsyncInt !== 0,
      getCalleeParamsFn,
      // TODO: find a way to pass the import name through here
      entryFnName: 'task/' + currentCallerTask.id() + '/new-prepare-task',
      stringEncoding,
    });
    
    const subtask = currentCallerTask.createSubtask({
      componentIdx: callerInstanceIdx,
      parentTask: currentCallerTask,
      childTask: newTask,
      callMetadata: {
        memory: getMemoryFn(),
        memoryIdx,
        resultPtr,
        returnFn,
        startFn,
      }
    });
    
    newTask.setParentSubtask(subtask);
    // NOTE: This isn't really a return memory idx for the caller, it's for checking
    // against the task.return (which will be called from the callee)
    newTask.setReturnMemoryIdx(memoryIdx);
  }
  
  function _asyncStartCall(args, callee, paramCount, resultCount, flags) {
    const { getCallbackFn, callbackIdx, getPostReturnFn, postReturnIdx } = args;
    _debugLog('[_asyncStartCall()] args', args);
    
    const taskMeta = getCurrentTask(ASYNC_CURRENT_COMPONENT_IDXS.at(-1), ASYNC_CURRENT_TASK_IDS.at(-1));
    if (!taskMeta) { throw new Error('invalid/missing current async task meta during prepare call'); }
    
    const argArray = [...arguments];
    
    // NOTE: at this point we know the current task is the one that was started
    // in PrepareCall, so we *should* be able to pop it back off and be left with
    // the previous task
    const preparedTask = taskMeta.task;
    if (!preparedTask) { throw new Error('unexpectedly missing task in task meta during prepare call'); }
    
    if (resultCount < 0 || resultCount > 1) { throw new Error('invalid/unsupported result count'); }
    
    const callbackFnName = 'callback_' + callbackIdx;
    const callbackFn = getCallbackFn();
    preparedTask.setCallbackFn(callbackFn, callbackFnName);
    preparedTask.setPostReturnFn(getPostReturnFn());
    
    const subtask = preparedTask.getParentSubtask();
    
    if (resultCount < 0 || resultCount > 1) { throw new Error(`unsupported result count [${ resultCount }]`); }
    
    const params = preparedTask.getCalleeParams();
    if (paramCount !== params.length) {
      throw new Error(`unexpected callee param count [${ params.length }], _asyncStartCall invocation expected [${ paramCount }]`);
    }
    
    subtask.setOnProgressFn(() => {
      subtask.setPendingEventFn(() => {
        if (subtask.resolved()) { subtask.deliverResolve(); }
        return {
          code: ASYNC_EVENT_CODE.SUBTASK,
          index: rep,
          result: subtask.getStateNumber(),
        }
      });
    });
    
    const subtaskState = subtask.getStateNumber();
    if (subtaskState < 0 || subtaskState > 2**5) {
      throw new Error('invalid subtask state, out of valid range');
    }
    
    const callerComponentState = getOrCreateAsyncState(subtask.componentIdx());
    const rep = callerComponentState.subtasks.insert(subtask);
    subtask.setRep(rep);
    
    const calleeComponentState = getOrCreateAsyncState(preparedTask.componentIdx());
    const calleeBackpressure = calleeComponentState.hasBackpressure();
    
    // Set up a handler on subtask completion to lower results from the call into the caller's memory region.
    //
    // NOTE: during fused guest->guest calls this handler is triggered, but does not actually perform
    // lowering manually, as fused modules provider helper functions that can
    subtask.registerOnResolveHandler((res) => {
      _debugLog('[_asyncStartCall()] handling subtask result', { res, subtaskID: subtask.id() });
      let subtaskCallMeta = subtask.getCallMetadata();
      
      // NOTE: in the case of guest -> guest async calls, there may be no memory/realloc present,
      // as the host will intermediate the value storage/movement between calls.
      //
      // We can simply take the value and lower it as a parameter
      if (subtaskCallMeta.memory || subtaskCallMeta.realloc) {
        throw new Error("call metadata unexpectedly contains memory/realloc for guest->guest call");
      }
      
      const callerTask = subtask.getParentTask();
      const calleeTask = preparedTask;
      const callerMemoryIdx = callerTask.getReturnMemoryIdx();
      const callerComponentIdx = callerTask.componentIdx();
      
      // If a helper function was provided we are likely in a fused guest->guest call,
      // and the result will be delivered (lift/lowered) via helper function
      if (subtaskCallMeta.returnFn) {
        _debugLog('[_asyncStartCall()] return function present while ahndling subtask result, returning early (skipping lower)');
        return;
      }
      
      // If there is no where to lower the results, exit early
      if (!subtaskCallMeta.resultPtr) {
        _debugLog('[_asyncStartCall()] no result ptr during subtask result handling, returning early (skipping lower)');
        return;
      }
      
      let callerMemory;
      if (callerMemoryIdx) {
        callerMemory = GlobalComponentMemories.getMemory(callerComponentIdx, callerMemoryIdx);
      } else {
        const callerMemories = GlobalComponentMemories.getMemoriesForComponentIdx(callerComponentIdx);
        if (callerMemories.length != 1) { throw new Error(`unsupported amount of caller memories`); }
        callerMemory = callerMemories[0];
      }
      
      if (!callerMemory) {
        throw new Error(`missing memory for to guest->guest call result (subtask [${subtask.id()}])`);
      }
      
      const lowerFns = calleeTask.getReturnLowerFns();
      if (!lowerFns || lowerFns.length === 0) {
        throw new Error(`missing result lower metadata for guest->guests call (subtask [${subtask.id()}])`);
      }
      
      if (lowerFns.length !== 1) {
        throw new Error(`only single result supported for guest->guest calls (subtask [${subtask.id()}])`);
      }
      
      lowerFns[0]({
        realloc: undefined,
        memory: callerMemory,
        vals: [res],
        storagePtr: subtaskCallMeta.resultPtr,
        componentIdx: callerComponentIdx
      });
      
    });
    
    // Build call params
    const subtaskCallMeta = subtask.getCallMetadata();
    let startFnParams = [];
    let calleeParams = [];
    if (subtaskCallMeta.startFn && subtaskCallMeta.resultPtr) {
      // If we're using a fused component start fn  and a result pointer is present,
      // then we need to pass the result pointer and other params to the start fn
      startFnParams.push(subtaskCallMeta.resultPtr, ...params);
    } else {
      // if not we need to pass params to the callee instead
      startFnParams.push(...params);
      calleeParams.push(...params);
    }
    
    preparedTask.registerOnResolveHandler((res) => {
      _debugLog('[_asyncStartCall()] signaling subtask completion due to task completion', {
        childTaskID: preparedTask.id(),
        subtaskID: subtask.id(),
        parentTaskID: subtask.getParentTask().id(),
      });
      subtask.onResolve(res);
    });
    
    // TODO(fix): start fns sometimes produce results, how should they be used?
    // the result should theoretically be used for flat lowering, but fused components do
    // this automatically!
    subtask.onStart({ startFnParams });
    
    _debugLog("[_asyncStartCall()] initial call", {
      task: preparedTask.id(),
      subtaskID: subtask.id(),
      calleeFnName: callee.name,
    });
    
    const callbackResult = callee.apply(null, calleeParams);
    
    _debugLog("[_asyncStartCall()] after initial call", {
      task: preparedTask.id(),
      subtaskID: subtask.id(),
      calleeFnName: callee.name,
    });
    
    const doSubtaskResolve = () => {
      subtask.deliverResolve();
    };
    
    // If a single call resolved the subtask and there is no backpressure in the guest,
    // we can return immediately
    if (subtask.resolved() && !calleeBackpressure) {
      _debugLog("[_asyncStartCall()] instantly resolved", {
        calleeComponentIdx: preparedTask.componentIdx(),
        task: preparedTask.id(),
        subtaskID: subtask.id(),
        callerComponentIdx: subtask.componentIdx(),
      });
      
      // If a fused component return function was specified for the subtask,
      // we've likely already called it during resolution of the task.
      //
      // In this case, we do not want to actually return 2 AKA "RETURNED",
      // but the normal started task state, because the fused component expects to get
      // the waitable + the original subtask state (0 AKA "STARTING")
      //
      if (subtask.getCallMetadata().returnFn) {
        return Number(subtask.waitableRep()) << 4 | subtaskState;
      }
      
      doSubtaskResolve();
      return AsyncSubtask.State.RETURNED;
    }
    
    // Start the (event) driver loop that will resolve the task
    new Promise(async (resolve, reject) => {
      if (subtask.resolved() && calleeBackpressure) {
        await calleeComponentState.waitForBackpressure();
        
        _debugLog("[_asyncStartCall()] instantly resolved after cleared backpressure", {
          calleeComponentIdx: preparedTask.componentIdx(),
          task: preparedTask.id(),
          subtaskID: subtask.id(),
          callerComponentIdx: subtask.componentIdx(),
        });
        return;
      }
      
      const started = await preparedTask.enter();
      if (!started) {
        _debugLog('[_asyncStartCall()] task failed early', {
          taskID: preparedTask.id(),
          subtaskID: subtask.id(),
        });
        throw new Error("task failed to start");
        return;
      }
      
      // TODO: retrieve/pass along actual fn name the callback corresponds to
      // (at least something like `<lifted fn name>_callback`)
      const fnName = [
      '<task ',
      subtask.parentTaskID(),
      '/subtask ',
      subtask.id(),
      '/task ',
      preparedTask.id(),
      '>',
      ].join("");
      
      try {
        _debugLog("[_asyncStartCall()] starting driver loop", { fnName, componentIdx: preparedTask.componentIdx(), });
        await _driverLoop({
          componentState: calleeComponentState,
          task: preparedTask,
          fnName,
          isAsync: true,
          callbackResult,
          resolve,
          reject
        });
      } catch (err) {
        _debugLog("[AsyncStartCall] drive loop call failure", { err });
      }
      
    });
    
    return Number(subtask.waitableRep()) << 4 | subtaskState;
  }
  
  function _syncStartCall(callbackIdx) {
    _debugLog('[_syncStartCall()] args', { callbackIdx });
    throw new Error('synchronous start call not implemented!');
  }
  
  const emptyFunc = () => {};
  
  let dv = new DataView(new ArrayBuffer());
  const dataView = mem => dv.buffer === mem.buffer ? dv : dv = new DataView(mem.buffer);
  
  const toUint64 = val => BigInt.asUintN(64, BigInt(val));
  
  function toUint16(val) {
    val >>>= 0;
    val %= 2 ** 16;
    return val;
  }
  
  function toUint32(val) {
    return val >>> 0;
  }
  
  function toUint8(val) {
    val >>>= 0;
    val %= 2 ** 8;
    return val;
  }
  const TEXT_DECODER_UTF8 = new TextDecoder();
  const TEXT_ENCODER_UTF8 = new TextEncoder();
  
  function _utf8AllocateAndEncode(s, realloc, memory) {
    if (typeof s !== 'string') {
      throw new TypeError('expected a string, received [' + typeof s + ']');
    }
    if (s.length === 0) { return { ptr: 1, len: 0 }; }
    let buf = TEXT_ENCODER_UTF8.encode(s);
    let ptr = realloc(0, 0, 1, buf.length);
    new Uint8Array(memory.buffer).set(buf, ptr);
    return { ptr, len: buf.length, codepoints: [...s].length };
  }
  
  
  const T_FLAG = 1 << 30;
  
  function rscTableCreateOwn(table, rep) {
    const free = table[0] & ~T_FLAG;
    if (free === 0) {
      table.push(0);
      table.push(rep | T_FLAG);
      return (table.length >> 1) - 1;
    }
    table[0] = table[free << 1];
    table[free << 1] = 0;
    table[(free << 1) + 1] = rep | T_FLAG;
    return free;
  }
  
  function rscTableRemove(table, handle) {
    const scope = table[handle << 1];
    const val = table[(handle << 1) + 1];
    const own = (val & T_FLAG) !== 0;
    const rep = val & ~T_FLAG;
    if (val === 0 || (scope & T_FLAG) !== 0) {
      throw new TypeError("Invalid handle");
    }
    table[handle << 1] = table[0] | T_FLAG;
    table[0] = handle | T_FLAG;
    return { rep, scope, own };
  }
  
  let curResourceBorrows = [];
  
  function getCurrentTask(componentIdx) {
    if (componentIdx === undefined || componentIdx === null) {
      throw new Error('missing/invalid component instance index [' + componentIdx + '] while getting current task');
    }
    const tasks = ASYNC_TASKS_BY_COMPONENT_IDX.get(componentIdx);
    if (tasks === undefined) { return undefined; }
    if (tasks.length === 0) { return undefined; }
    return tasks[tasks.length - 1];
  }
  
  function createNewCurrentTask(args) {
    _debugLog('[createNewCurrentTask()] args', args);
    const {
      componentIdx,
      isAsync,
      entryFnName,
      parentSubtaskID,
      callbackFnName,
      getCallbackFn,
      getParamsFn,
      stringEncoding,
      errHandling,
      getCalleeParamsFn,
      resultPtr,
      callingWasmExport,
    } = args;
    if (componentIdx === undefined || componentIdx === null) {
      throw new Error('missing/invalid component instance index while starting task');
    }
    const taskMetas = ASYNC_TASKS_BY_COMPONENT_IDX.get(componentIdx);
    const callbackFn = getCallbackFn ? getCallbackFn() : null;
    
    const newTask = new AsyncTask({
      componentIdx,
      isAsync,
      entryFnName,
      callbackFn,
      callbackFnName,
      stringEncoding,
      getCalleeParamsFn,
      resultPtr,
      errHandling,
    });
    
    const newTaskID = newTask.id();
    const newTaskMeta = { id: newTaskID, componentIdx, task: newTask };
    
    ASYNC_CURRENT_TASK_IDS.push(newTaskID);
    ASYNC_CURRENT_COMPONENT_IDXS.push(componentIdx);
    
    if (!taskMetas) {
      ASYNC_TASKS_BY_COMPONENT_IDX.set(componentIdx, [newTaskMeta]);
    } else {
      taskMetas.push(newTaskMeta);
    }
    
    return [newTask, newTaskID];
  }
  
  function endCurrentTask(componentIdx, taskID) {
    componentIdx ??= ASYNC_CURRENT_COMPONENT_IDXS.at(-1);
    taskID ??= ASYNC_CURRENT_TASK_IDS.at(-1);
    _debugLog('[endCurrentTask()] args', { componentIdx, taskID });
    
    if (componentIdx === undefined || componentIdx === null) {
      throw new Error('missing/invalid component instance index while ending current task');
    }
    
    const tasks = ASYNC_TASKS_BY_COMPONENT_IDX.get(componentIdx);
    if (!tasks || !Array.isArray(tasks)) {
      throw new Error('missing/invalid tasks for component instance while ending task');
    }
    if (tasks.length == 0) {
      throw new Error('no current task(s) for component instance while ending task');
    }
    
    if (taskID) {
      const last = tasks[tasks.length - 1];
      if (last.id !== taskID) {
        // throw new Error('current task does not match expected task ID');
        return;
      }
    }
    
    ASYNC_CURRENT_TASK_IDS.pop();
    ASYNC_CURRENT_COMPONENT_IDXS.pop();
    
    const taskMeta = tasks.pop();
    return taskMeta.task;
  }
  const ASYNC_TASKS_BY_COMPONENT_IDX = new Map();
  
  class AsyncTask {
    static _ID = 0n;
    
    static State = {
      INITIAL: 'initial',
      CANCELLED: 'cancelled',
      CANCEL_PENDING: 'cancel-pending',
      CANCEL_DELIVERED: 'cancel-delivered',
      RESOLVED: 'resolved',
    }
    
    static BlockResult = {
      CANCELLED: 'block.cancelled',
      NOT_CANCELLED: 'block.not-cancelled',
    }
    
    #id;
    #componentIdx;
    #state;
    #isAsync;
    #entryFnName = null;
    #subtasks = [];
    
    #onResolveHandlers = [];
    #completionPromise = null;
    
    #memoryIdx = null;
    
    #callbackFn = null;
    #callbackFnName = null;
    
    #postReturnFn = null;
    
    #getCalleeParamsFn = null;
    
    #stringEncoding = null;
    
    #parentSubtask = null;
    
    #needsExclusiveLock = false;
    
    #errHandling;
    
    #backpressurePromise;
    #backpressureWaiters = 0n;
    
    #returnLowerFns = null;
    
    cancelled = false;
    requested = false;
    alwaysTaskReturn = false;
    
    returnCalls =  0;
    storage = [0, 0];
    borrowedHandles = {};
    
    awaitableResume = null;
    awaitableCancel = null;
    
    constructor(opts) {
      this.#id = ++AsyncTask._ID;
      
      if (opts?.componentIdx === undefined) {
        throw new TypeError('missing component id during task creation');
      }
      this.#componentIdx = opts.componentIdx;
      
      this.#state = AsyncTask.State.INITIAL;
      this.#isAsync = opts?.isAsync ?? false;
      this.#entryFnName = opts.entryFnName;
      
      const {
        promise: completionPromise,
        resolve: resolveCompletionPromise,
        reject: rejectCompletionPromise,
      } = promiseWithResolvers();
      this.#completionPromise = completionPromise;
      
      this.#onResolveHandlers.push((results) => {
        resolveCompletionPromise(results);
      })
      
      if (opts.callbackFn) { this.#callbackFn = opts.callbackFn; }
      if (opts.callbackFnName) { this.#callbackFnName = opts.callbackFnName; }
      
      if (opts.getCalleeParamsFn) { this.#getCalleeParamsFn = opts.getCalleeParamsFn; }
      
      if (opts.stringEncoding) { this.#stringEncoding = opts.stringEncoding; }
      
      if (opts.parentSubtask) { this.#parentSubtask = opts.parentSubtask; }
      
      this.#needsExclusiveLock = this.isSync() || !this.hasCallback();
      
      if (opts.errHandling) { this.#errHandling = opts.errHandling; }
    }
    
    taskState() { return this.#state; }
    id() { return this.#id; }
    componentIdx() { return this.#componentIdx; }
    isAsync() { return this.#isAsync; }
    entryFnName() { return this.#entryFnName; }
    completionPromise() { return this.#completionPromise; }
    
    isAsync() { return this.#isAsync; }
    isSync() { return !this.isAsync(); }
    
    getErrHandling() { return this.#errHandling; }
    
    hasCallback() { return this.#callbackFn !== null; }
    
    setReturnMemoryIdx(idx) { this.#memoryIdx = idx; }
    getReturnMemoryIdx() { return this.#memoryIdx; }
    
    setReturnLowerFns(fns) { this.#returnLowerFns = fns; }
    getReturnLowerFns() { return this.#returnLowerFns; }
    
    setParentSubtask(subtask) {
      if (!subtask || !(subtask instanceof AsyncSubtask)) { return }
      if (this.#parentSubtask) { throw new Error('parent subtask can only be set once'); }
      this.#parentSubtask = subtask;
    }
    
    getParentSubtask() { return this.#parentSubtask; }
    
    // TODO(threads): this is very inefficient, we can pass along a root task,
    // and ideally do not need this once thread support is in place
    getRootTask() {
      let currentSubtask = this.getParentSubtask();
      let task = this;
      while (currentSubtask) {
        task = currentSubtask.getParentTask();
        currentSubtask = task.getParentSubtask();
      }
      return task;
    }
    
    setPostReturnFn(f) {
      if (!f) { return; }
      if (this.#postReturnFn) { throw new Error('postReturn fn can only be set once'); }
      this.#postReturnFn = f;
    }
    
    setCallbackFn(f, name) {
      if (!f) { return; }
      if (this.#callbackFn) { throw new Error('callback fn can only be set once'); }
      this.#callbackFn = f;
      this.#callbackFnName = name;
    }
    
    getCallbackFnName() {
      if (!this.#callbackFnName) { return undefined; }
      return this.#callbackFnName;
    }
    
    runCallbackFn(...args) {
      if (!this.#callbackFn) { throw new Error('on callback function has been set for task'); }
      return this.#callbackFn.apply(null, args);
    }
    
    getCalleeParams() {
      if (!this.#getCalleeParamsFn) { throw new Error('missing/invalid getCalleeParamsFn'); }
      return this.#getCalleeParamsFn();
    }
    
    mayEnter(task) {
      const cstate = getOrCreateAsyncState(this.#componentIdx);
      if (cstate.hasBackpressure()) {
        _debugLog('[AsyncTask#mayEnter()] disallowed due to backpressure', { taskID: this.#id });
        return false;
      }
      if (!cstate.callingSyncImport()) {
        _debugLog('[AsyncTask#mayEnter()] disallowed due to sync import call', { taskID: this.#id });
        return false;
      }
      const callingSyncExportWithSyncPending = cstate.callingSyncExport && !task.isAsync;
      if (!callingSyncExportWithSyncPending) {
        _debugLog('[AsyncTask#mayEnter()] disallowed due to sync export w/ sync pending', { taskID: this.#id });
        return false;
      }
      return true;
    }
    
    async enter() {
      _debugLog('[AsyncTask#enter()] args', { taskID: this.#id });
      const cstate = getOrCreateAsyncState(this.#componentIdx);
      
      if (this.isSync()) { return true; }
      
      if (cstate.hasBackpressure()) {
        cstate.addBackpressureWaiter();
        
        const result = await this.waitUntil({
          readyFn: () => !cstate.hasBackpressure(),
          cancellable: true,
        });
        
        cstate.removeBackpressureWaiter();
        
        if (result === AsyncTask.BlockResult.CANCELLED) {
          this.cancel();
          return false;
        }
      }
      
      if (this.needsExclusiveLock()) { cstate.exclusiveLock(); }
      
      return true;
    }
    
    isRunning() {
      return this.#state !== AsyncTask.State.RESOLVED;
    }
    
    async waitUntil(opts) {
      const { readyFn, waitableSetRep, cancellable } = opts;
      _debugLog('[AsyncTask#waitUntil()] args', { taskID: this.#id, waitableSetRep, cancellable });
      
      const state = getOrCreateAsyncState(this.#componentIdx);
      const wset = state.waitableSets.get(waitableSetRep);
      
      let event;
      
      wset.incrementNumWaiting();
      
      const keepGoing = await this.suspendUntil({
        readyFn: () => {
          const hasPendingEvent = wset.hasPendingEvent();
          return readyFn() && hasPendingEvent;
        },
        cancellable,
      });
      
      if (keepGoing) {
        event = wset.getPendingEvent();
      } else {
        event = {
          code: ASYNC_EVENT_CODE.TASK_CANCELLED,
          index: 0,
          result: 0,
        };
      }
      
      wset.decrementNumWaiting();
      
      return event;
    }
    
    async onBlock(awaitable) {
      _debugLog('[AsyncTask#onBlock()] args', { taskID: this.#id, awaitable });
      if (!(awaitable instanceof Awaitable)) {
        throw new Error('invalid awaitable during onBlock');
      }
      
      // Build a promise that this task can await on which resolves when it is awoken
      const { promise, resolve, reject } = promiseWithResolvers();
      this.awaitableResume = () => {
        _debugLog('[AsyncTask] resuming after onBlock', { taskID: this.#id });
        resolve();
      };
      this.awaitableCancel = (err) => {
        _debugLog('[AsyncTask] rejecting after onBlock', { taskID: this.#id, err });
        reject(err);
      };
      
      // Park this task/execution to be handled later
      const state = getOrCreateAsyncState(this.#componentIdx);
      state.parkTaskOnAwaitable({ awaitable, task: this });
      
      try {
        await promise;
        return AsyncTask.BlockResult.NOT_CANCELLED;
      } catch (err) {
        // rejection means task cancellation
        return AsyncTask.BlockResult.CANCELLED;
      }
    }
    
    async asyncOnBlock(awaitable) {
      _debugLog('[AsyncTask#asyncOnBlock()] args', { taskID: this.#id, awaitable });
      if (!(awaitable instanceof Awaitable)) {
        throw new Error('invalid awaitable during onBlock');
      }
      // TODO: watch for waitable AND cancellation
      // TODO: if it WAS cancelled:
      // - return true
      // - only once per subtask
      // - do not wait on the scheduler
      // - control flow should go to the subtask (only once)
      // - Once subtask blocks/resolves, reqlinquishControl() will tehn resolve request_cancel_end (without scheduler lock release)
      // - control flow goes back to request_cancel
      //
      // Subtask cancellation should work similarly to an async import call -- runs sync up until
      // the subtask blocks or resolves
      //
      throw new Error('AsyncTask#asyncOnBlock() not yet implemented');
    }
    
    async yieldUntil(opts) {
      const { readyFn, cancellable } = opts;
      _debugLog('[AsyncTask#yieldUntil()] args', { taskID: this.#id, cancellable });
      
      const keepGoing = await this.suspendUntil({ readyFn, cancellable });
      if (!keepGoing) {
        return {
          code: ASYNC_EVENT_CODE.TASK_CANCELLED,
          index: 0,
          result: 0,
        };
      }
      
      return {
        code: ASYNC_EVENT_CODE.NONE,
        index: 0,
        result: 0,
      };
    }
    
    async suspendUntil(opts) {
      const { cancellable, readyFn } = opts;
      _debugLog('[AsyncTask#suspendUntil()] args', { cancellable });
      
      const pendingCancelled = this.deliverPendingCancel({ cancellable });
      if (pendingCancelled) { return false; }
      
      const completed = await this.immediateSuspendUntil({ readyFn, cancellable });
      return completed;
    }
    
    // TODO(threads): equivalent to thread.suspend_until()
    async immediateSuspendUntil(opts) {
      const { cancellable, readyFn } = opts;
      _debugLog('[AsyncTask#immediateSuspendUntil()] args', { cancellable, readyFn });
      
      const ready = readyFn();
      if (ready && !ASYNC_DETERMINISM && _coinFlip()) {
        return true;
      }
      
      const cstate = getOrCreateAsyncState(this.#componentIdx);
      cstate.addPendingTask(this);
      
      const keepGoing = await this.immediateSuspend({ cancellable, readyFn });
      return keepGoing;
    }
    
    async immediateSuspend(opts) { // NOTE: equivalent to thread.suspend()
    // TODO(threads): store readyFn on the thread
    const { cancellable, readyFn } = opts;
    _debugLog('[AsyncTask#immediateSuspend()] args', { cancellable, readyFn });
    
    const pendingCancelled = this.deliverPendingCancel({ cancellable });
    if (pendingCancelled) { return false; }
    
    const cstate = getOrCreateAsyncState(this.#componentIdx);
    
    // TODO(fix): update this to tick until there is no more action to take.
    setTimeout(() => cstate.tick(), 0);
    
    const taskWait = await cstate.suspendTask({ task: this, readyFn });
    const keepGoing = await taskWait;
    return keepGoing;
  }
  
  deliverPendingCancel(opts) {
    const { cancellable } = opts;
    _debugLog('[AsyncTask#deliverPendingCancel()] args', { cancellable });
    
    if (cancellable && this.#state === AsyncTask.State.PENDING_CANCEL) {
      this.#state = Task.State.CANCEL_DELIVERED;
      return true;
    }
    
    return false;
  }
  
  isCancelled() { return this.cancelled }
  
  cancel() {
    _debugLog('[AsyncTask#cancel()] args', { });
    if (!this.taskState() !== AsyncTask.State.CANCEL_DELIVERED) {
      throw new Error(`(component [${this.#componentIdx}]) task [${this.#id}] invalid task state for cancellation`);
    }
    if (this.borrowedHandles.length > 0) { throw new Error('task still has borrow handles'); }
    this.cancelled = true;
    this.onResolve(new Error('cancelled'));
    this.#state = AsyncTask.State.RESOLVED;
  }
  
  onResolve(taskValue) {
    for (const f of this.#onResolveHandlers) {
      try {
        f(taskValue);
      } catch (err) {
        console.error("error during task resolve handler", err);
        throw err;
      }
    }
    
    if (this.#postReturnFn) {
      _debugLog('[AsyncTask#onResolve()] running post return ', {
        componentIdx: this.#componentIdx,
        taskID: this.#id,
      });
      this.#postReturnFn();
    }
  }
  
  registerOnResolveHandler(f) {
    this.#onResolveHandlers.push(f);
  }
  
  resolve(results) {
    _debugLog('[AsyncTask#resolve()] args', {
      results,
      componentIdx: this.#componentIdx,
      taskID: this.#id,
    });
    
    if (this.#state === AsyncTask.State.RESOLVED) {
      throw new Error(`(component [${this.#componentIdx}]) task [${this.#id}]  is already resolved (did you forget to wait for an import?)`);
    }
    if (this.borrowedHandles.length > 0) { throw new Error('task still has borrow handles'); }
    switch (results.length) {
      case 0:
      this.onResolve(undefined);
      break;
      case 1:
      this.onResolve(results[0]);
      break;
      default:
      throw new Error('unexpected number of results');
    }
    this.#state = AsyncTask.State.RESOLVED;
  }
  
  exit() {
    _debugLog('[AsyncTask#exit()] args', { });
    
    // TODO: ensure there is only one task at a time (scheduler.lock() functionality)
    if (this.#state !== AsyncTask.State.RESOLVED) {
      // TODO(fix): only fused, manually specified post returns seem to break this invariant,
      // as the TaskReturn trampoline is not activated it seems.
      //
      // see: test/p3/ported/wasmtime/component-async/post-return.js
      //
      // We *should* be able to upgrade this to be more strict and throw at some point,
      // which may involve rewriting the upstream test to surface task return manually somehow.
      //
      //throw new Error(`(component [${this.#componentIdx}]) task [${this.#id}] exited without resolution`);
      _debugLog('[AsyncTask#exit()] task exited without resolution', {
        componentIdx: this.#componentIdx,
        taskID: this.#id,
        subtask: this.getParentSubtask(),
        subtaskID: this.getParentSubtask()?.id(),
      });
      this.#state = AsyncTask.State.RESOLVED;
    }
    
    if (this.borrowedHandles > 0) {
      throw new Error('task [${this.#id}] exited without clearing borrowed handles');
    }
    
    const state = getOrCreateAsyncState(this.#componentIdx);
    if (!state) { throw new Error('missing async state for component [' + this.#componentIdx + ']'); }
    if (!this.#isAsync && !state.inSyncExportCall) {
      throw new Error('sync task must be run from components known to be in a sync export call');
    }
    state.inSyncExportCall = false;
    
    if (this.needsExclusiveLock() && !state.isExclusivelyLocked()) {
      throw new Error('task [' + this.#id + '] exit: component [' + this.#componentIdx + '] should have been exclusively locked');
    }
    
    state.exclusiveRelease();
  }
  
  needsExclusiveLock() { return this.#needsExclusiveLock; }
  
  createSubtask(args) {
    _debugLog('[AsyncTask#createSubtask()] args', args);
    const { componentIdx, childTask, callMetadata } = args;
    const newSubtask = new AsyncSubtask({
      componentIdx,
      childTask,
      parentTask: this,
      callMetadata,
    });
    this.#subtasks.push(newSubtask);
    return newSubtask;
  }
  
  getLatestSubtask() { return this.#subtasks.at(-1); }
  
  currentSubtask() {
    _debugLog('[AsyncTask#currentSubtask()]');
    if (this.#subtasks.length === 0) { return undefined; }
    return this.#subtasks.at(-1);
  }
  
  endCurrentSubtask() {
    _debugLog('[AsyncTask#endCurrentSubtask()]');
    if (this.#subtasks.length === 0) { throw new Error('cannot end current subtask: no current subtask'); }
    const subtask = this.#subtasks.pop();
    subtask.drop();
    return subtask;
  }
}

function _lowerImport(args, exportFn) {
  const params = [...arguments].slice(2);
  _debugLog('[_lowerImport()] args', { args, params, exportFn });
  const {
    functionIdx,
    componentIdx,
    isAsync,
    paramLiftFns,
    resultLowerFns,
    metadata,
    memoryIdx,
    getMemoryFn,
    getReallocFn,
  } = args;
  
  const parentTaskMeta = getCurrentTask(componentIdx);
  const parentTask = parentTaskMeta?.task;
  if (!parentTask) { throw new Error('missing parent task during lower of import'); }
  
  const cstate = getOrCreateAsyncState(componentIdx);
  
  const subtask = parentTask.createSubtask({
    componentIdx,
    parentTask,
    callMetadata: {
      memoryIdx,
      memory: getMemoryFn(),
      realloc: getReallocFn(),
      resultPtr: params[0],
    }
  });
  parentTask.setReturnMemoryIdx(memoryIdx);
  
  const rep = cstate.subtasks.insert(subtask);
  subtask.setRep(rep);
  
  subtask.setOnProgressFn(() => {
    subtask.setPendingEventFn(() => {
      if (subtask.resolved()) { subtask.deliverResolve(); }
      return {
        code: ASYNC_EVENT_CODE.SUBTASK,
        index: rep,
        result: subtask.getStateNumber(),
      }
    });
  });
  
  // Set up a handler on subtask completion to lower results from the call into the caller's memory region.
  subtask.registerOnResolveHandler((res) => {
    _debugLog('[_lowerImport()] handling subtask result', { res, subtaskID: subtask.id() });
    const { memory, resultPtr, realloc } = subtask.getCallMetadata();
    if (resultLowerFns.length === 0) { return; }
    resultLowerFns[0]({ componentIdx, memory, realloc, vals: [res], storagePtr: resultPtr });
  });
  
  const subtaskState = subtask.getStateNumber();
  if (subtaskState < 0 || subtaskState > 2**5) {
    throw new Error('invalid subtask state, out of valid range');
  }
  
  // NOTE: we must wait a bit before calling the export function,
  // to ensure the subtask state is not modified before the lower call return
  //
  // TODO: we should trigger via subtask state changing, rather than a static wait?
  setTimeout(async () => {
    try {
      _debugLog('[_lowerImport()] calling lowered import', { exportFn, params });
      exportFn.apply(null, params);
      
      const task = subtask.getChildTask();
      task.registerOnResolveHandler((res) => {
        _debugLog('[_lowerImport()] cascading subtask completion', {
          childTaskID: task.id(),
          subtaskID: subtask.id(),
          parentTaskID: parentTask.id(),
        });
        
        subtask.onResolve(res);
        
        cstate.tick();
      });
    } catch (err) {
      console.error("post-lower import fn error:", err);
      throw err;
    }
  }, 100);
  
  return Number(subtask.waitableRep()) << 4 | subtaskState;
}

function _liftFlatBool(ctx) {
  _debugLog('[_liftFlatBool()] args', { ctx });
  let val;
  
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least a single i32 argument'); }
    val = ctx.params[0] === 1;
    ctx.params = ctx.params.slice(1);
    return [val, ctx];
  }
  
  if (ctx.storageLen !== undefined && ctx.storageLen < ctx.storagePtr + 1) {
    throw new Error('not enough storage remaining for lift');
  }
  val = new DataView(ctx.memory.buffer).getUint8(ctx.storagePtr, true) === 1;
  ctx.storagePtr += 1;
  if (ctx.storageLen !== undefined) { ctx.storageLen -= 1; }
  
  return [val, ctx];
}

function _liftFlatU8(ctx) {
  _debugLog('[_liftFlatU8()] args', { ctx });
  let val;
  
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least a single i32 argument'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
    return [val, ctx];
  }
  
  if (ctx.storageLen !== undefined && ctx.storageLen < ctx.storagePtr + 1) {
    throw new Error('not enough storage remaining for lift');
  }
  val = new DataView(ctx.memory.buffer).getUint8(ctx.storagePtr, true);
  ctx.storagePtr += 1;
  if (ctx.storageLen !== undefined) { ctx.storageLen -= 1; }
  
  return [val, ctx];
}

function _liftFlatU16(ctx) {
  _debugLog('[_liftFlatU16()] args', { ctx });
  let val;
  
  if (ctx.useDirectParams) {
    if (params.length === 0) { throw new Error('expected at least a single i32 argument'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
    return [val, ctx];
  }
  
  if (ctx.storageLen !== undefined && ctx.storageLen < ctx.storagePtr + 2) {
    throw new Error('not enough storage remaining for lift');
  }
  val = new DataView(ctx.memory.buffer).getUint16(ctx.storagePtr, true);
  ctx.storagePtr += 2;
  if (ctx.storageLen !== undefined) { ctx.storageLen -= 2; }
  
  return [val, ctx];
}

function _liftFlatU32(ctx) {
  _debugLog('[_liftFlatU32()] args', { ctx });
  let val;
  
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least a single i34 argument'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
    return [val, ctx];
  }
  
  if (ctx.storageLen !== undefined && ctx.storageLen < ctx.storagePtr + 4) {
    throw new Error('not enough storage remaining for lift');
  }
  val = new DataView(ctx.memory.buffer).getUint32(ctx.storagePtr, true);
  ctx.storagePtr += 4;
  if (ctx.storageLen !== undefined) { ctx.storageLen -= 4; }
  
  return [val, ctx];
}

function _liftFlatU64(ctx) {
  _debugLog('[_liftFlatU64()] args', { ctx });
  let val;
  
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least one single i64 argument'); }
    if (typeof ctx.params[0] !== 'bigint') { throw new Error('expected bigint'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
    return [val, ctx];
  }
  
  if (ctx.storageLen !== undefined && ctx.storageLen < ctx.storagePtr + 8) {
    throw new Error('not enough storage remaining for lift');
  }
  val = new DataView(ctx.memory.buffer).getUint64(ctx.storagePtr, true);
  ctx.storagePtr += 8;
  if (ctx.storageLen !== undefined) { ctx.storageLen -= 8; }
  
  return [val, ctx];
}

function _liftFlatStringUTF8(ctx) {
  _debugLog('[_liftFlatStringUTF8()] args', { ctx });
  let val;
  
  if (ctx.useDirectParams) {
    if (ctx.params.length < 2) { throw new Error('expected at least two u32 arguments'); }
    const offset = ctx.params[0];
    if (!Number.isSafeInteger(offset)) {  throw new Error('invalid offset'); }
    const len = ctx.params[1];
    if (!Number.isSafeInteger(len)) {  throw new Error('invalid len'); }
    val = TEXT_DECODER_UTF8.decode(new DataView(ctx.memory.buffer, offset, len));
    ctx.params = ctx.params.slice(2);
    return [val, ctx];
  }
  
  const start = new DataView(ctx.memory.buffer).getUint32(ctx.storagePtr, params[0], true);
  const codeUnits = new DataView(memory.buffer).getUint32(ctx.storagePtr, params[0] + 4, true);
  val = TEXT_DECODER_UTF8.decode(new Uint8Array(ctx.memory.buffer, start, codeUnits));
  ctx.storagePtr += codeUnits;
  if (ctx.storageLen !== undefined) { ctx.storageLen -= codeUnits; }
  
  return [val, ctx];
}

function _liftFlatRecord(keysAndLiftFns) {
  return function _liftFlatRecordInner(ctx) {
    _debugLog('[_liftFlatRecord()] args', { ctx });
    const { memory, useDirectParams, storagePtr, storageLen, params } = ctx;
    
    if (useDirectParams) {
      storagePtr = params[0]
    }
    
    const res = {};
    for (const [key, liftFn, alignment32] in keysAndLiftFns) {
      ctx.storagePtr = Math.ceil(ctx.storagePtr / alignment32) * alignment32;
      let [val, newCtx] = liftFn(ctx);
      res[key] = val;
      ctx = newCtx;
    }
    
    return res;
  }
}

function _liftFlatVariant(casesAndLiftFns) {
  return function _liftFlatVariantInner(ctx) {
    _debugLog('[_liftFlatVariant()] args', { ctx });
    
    const origUseParams = ctx.useDirectParams;
    
    let caseIdx;
    if (casesAndLiftFns.length < 256) {
      let discriminantByteLen = 1;
      const [idx, newCtx] = _liftFlatU8(ctx);
      caseIdx = idx;
      ctx = newCtx;
    } else if (casesAndLiftFns.length > 256 && discriminantByteLen < 65536) {
      discriminantByteLen = 2;
      const [idx, newCtx] = _liftFlatU16(ctx);
      caseIdx = idx;
      ctx = newCtx;
    } else if (casesAndLiftFns.length > 65536 && discriminantByteLen < 4_294_967_296) {
      discriminantByteLen = 4;
      const [idx, newCtx] = _liftFlatU32(ctx);
      caseIdx = idx;
      ctx = newCtx;
    } else {
      throw new Error('unsupported number of cases [' + casesAndLIftFns.legnth + ']');
    }
    
    const [ tag, liftFn, size32, alignment32 ] = casesAndLiftFns[caseIdx];
    
    let val;
    if (liftFn === null) {
      val = { tag };
      return [val, ctx];
    }
    
    const [newVal, newCtx] = liftFn(ctx);
    ctx = newCtx;
    val = { tag, val: newVal };
    
    return [val, ctx];
  }
}

function _liftFlatList(elemLiftFn, alignment32, knownLen) {
  function _liftFlatListInner(ctx) {
    _debugLog('[_liftFlatList()] args', { ctx });
    
    let metaPtr;
    let dataPtr;
    let len;
    if (ctx.useDirectParams) {
      if (knownLen) {
        dataPtr = _liftFlatU32(ctx);
      } else {
        metaPtr = _liftFlatU32(ctx);
      }
    } else {
      if (knownLen) {
        dataPtr = _liftFlatU32(ctx);
      } else {
        metaPtr = _liftFlatU32(ctx);
      }
    }
    
    if (metaPtr) {
      if (dataPtr !== undefined) { throw new Error('both meta and data pointers should not be set yet'); }
      
      if (ctx.useDirectParams) {
        ctx.useDirectParams = false;
        ctx.storagePtr = metaPtr;
        ctx.storageLen = 8;
        
        dataPtr = _liftFlatU32(ctx);
        len = _liftFlatU32(ctx);
        
        ctx.useDirectParams = true;
        ctx.storagePtr = null;
        ctx.storageLen = null;
      } else {
        dataPtr = _liftFlatU32(ctx);
        len = _liftFlatU32(ctx);
      }
    }
    
    const val = [];
    for (var i = 0; i < len; i++) {
      ctx.storagePtr = Math.ceil(ctx.storagePtr / alignment32) * alignment32;
      const [res, nextCtx] = elemLiftFn(ctx);
      val.push(res);
      ctx = nextCtx;
    }
    
    return [val, ctx];
  }
}

function _liftFlatTuple(numberedLiftFns) {
  return function _liftFlatTupleInner(ctx) {
    _debugLog('[_liftFlatTuple()] args', { ctx });
    
    const obj = _liftFlatRecord(numberedLiftFns)(ctx);
    const val = [];
    for (var i = 0; i++; i < nubmeredLiftFns.length) {
      val.push(obj[i]);
    }
    
    return val;
  }
}

function _liftFlatFlags(cases) {
  return function _liftFlatFlagsInner(ctx) {
    _debugLog('[_liftFlatFlags()] args', { ctx });
    throw new Error('flat lift for flags not yet implemented!');
  }
}

function _liftFlatEnum(casesAndLiftFns) {
  return function _liftFlatEnumInner(ctx) {
    _debugLog('[_liftFlatEnum()] args', { ctx });
    return _liftFlatVariant(casesAndLiftFns)(ctx);
  }
}

function _liftFlatOption(casesAndLiftFns) {
  return function _liftFlatOptionInner(ctx) {
    _debugLog('[_liftFlatOption()] args', { ctx });
    return _liftFlatVariant(casesAndLiftFns)(ctx);
  }
}

function _liftFlatResult(casesAndLiftFns) {
  return function _liftFlatResultInner(ctx) {
    _debugLog('[_liftFlatResult()] args', { ctx });
    return _liftFlatVariant(casesAndLiftFns)(ctx);
  }
}

function _liftFlatBorrow(componentTableIdx, size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_liftFlatBorrow()] args', { size, memory, vals, storagePtr, storageLen });
  throw new Error('flat lift for borrowed resources not yet implemented!');
}

function _lowerFlatBool(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatBool()] args', { memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) {
    throw new Error('unexpected number (' + vals.length + ') of core vals (expected 1)');
  }
  if (vals[0] !== 0 && vals[0] !== 1) { throw new Error('invalid value for core value representing bool'); }
  new DataView(memory.buffer).setUint32(storagePtr, vals[0], true);
  return 1;
}

function _lowerFlatU8(ctx) {
  _debugLog('[_lowerFlatU8()] args', ctx);
  const { memory, realloc, vals, storagePtr, storageLen } = ctx;
  if (vals.length !== 1) {
    throw new Error('unexpected number (' + vals.length + ') of core vals (expected 1)');
  }
  if (vals[0] > 255 || vals[0] < 0) { throw new Error('invalid value for core value representing u8'); }
  if (!memory) { throw new Error("missing memory for lower"); }
  new DataView(memory.buffer).setUint32(storagePtr, vals[0], true);
  return 1;
}

function _lowerFlatU16(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatU16()] args', { memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) {
    throw new Error('unexpected number (' + vals.length + ') of core vals (expected 1)');
  }
  if (vals[0] > 65_535 || vals[0] < 0) { throw new Error('invalid value for core value representing u16'); }
  new DataView(memory.buffer).setUint16(storagePtr, vals[0], true);
  return 2;
}

function _lowerFlatU32(ctx) {
  _debugLog('[_lowerFlatU32()] args', { ctx });
  const { memory, realloc, vals, storagePtr, storageLen } = ctx;
  if (vals.length !== 1) { throw new Error('expected single value to lower, got (' + vals.length + ')'); }
  if (vals[0] > 4_294_967_295 || vals[0] < 0) { throw new Error('invalid value for core value representing u32'); }
  
  // TODO(refactor): fail loudly on misaligned flat lowers?
  const rem = ctx.storagePtr % 4;
  if (rem !== 0) { ctx.storagePtr += (4 - rem); }
  
  new DataView(memory.buffer).setUint32(storagePtr, vals[0], true);
  
  return 4;
}

function _lowerFlatU64(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatU64()] args', { memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) { throw new Error('unexpected number of core vals'); }
  if (vals[0] > 18_446_744_073_709_551_615n || vals[0] < 0n) { throw new Error('invalid value for core value representing u64'); }
  new DataView(memory.buffer).setBigUint64(storagePtr, vals[0], true);
  return 8;
}

function _lowerFlatStringUTF8(ctx) {
  _debugLog('[_lowerFlatStringUTF8()] args', ctx);
  const { memory, realloc, vals, storagePtr, storageLen } = ctx;
  
  const s = vals[0];
  const { ptr, len, codepoints } = _utf8AllocateAndEncode(vals[0], realloc, memory);
  
  const view = new DataView(memory.buffer);
  view.setUint32(storagePtr, ptr, true);
  view.setUint32(storagePtr + 4, codepoints, true);
  
  return len;
}

function _lowerFlatRecord(fieldMetas) {
  return (size, memory, vals, storagePtr, storageLen) => {
    const params = [...arguments].slice(5);
    _debugLog('[_lowerFlatRecord()] args', {
      size,
      memory,
      vals,
      storagePtr,
      storageLen,
      params,
      fieldMetas
    });
    
    const [start] = vals;
    if (storageLen !== undefined && size !== undefined && size > storageLen) {
      throw new Error('not enough storage remaining for record flat lower');
    }
    const data = new Uint8Array(memory.buffer, start, size);
    new Uint8Array(memory.buffer, storagePtr, size).set(data);
    return data.byteLength;
  }
}

function _lowerFlatVariant(metadata, extra) {
  const { discriminantSizeBytes, lowerMetas } = metadata;
  
  return function _lowerFlatVariantInner(ctx) {
    _debugLog('[_lowerFlatVariant()] args', ctx);
    const { memory, realloc, vals, storageLen, componentIdx } = ctx;
    let storagePtr = ctx.storagePtr;
    
    const { tag, val } = vals[0];
    const variant = lowerMetas.find(vm => vm.tag === tag);
    if (!variant) { throw new Error(`missing/invalid variant, no tag matches [${tag}] (options were ${variantMetas.map(vm => vm.tag)})`); }
    if (!variant.discriminant) { throw new Error(`missing/invalid discriminant for variant [${variant}]`); }
    
    let bytesWritten;
    let discriminantLowerArgs = { memory, realloc, vals: [variant.discriminant], storagePtr, componentIdx }
    switch (discriminantSizeBytes) {
      case 1:
      bytesWritten = _lowerFlatU8(discriminantLowerArgs);
      break;
      case 2:
      bytesWritten = _lowerFlatU16(discriminantLowerArgs);
      break;
      case 4:
      bytesWritten = _lowerFlatU32(discriminantLowerArgs);
      break;
      default:
      throw new Error(`unexpected discriminant size bytes [${discriminantSizeBytes}]`);
    }
    if (bytesWritten !== discriminantSizeBytes) {
      throw new Error("unexpectedly wrote more bytes than discriminant");
    }
    storagePtr += bytesWritten;
    
    bytesWritten += variant.lowerFn({ memory, realloc, vals: [val], storagePtr, storageLen, componentIdx });
    
    return bytesWritten;
  }
}

function _lowerFlatList(args) {
  const { elemLowerFn } = args;
  if (!elemLowerFn) { throw new TypeError("missing/invalid element lower fn for list"); }
  
  return function _lowerFlatListInner(ctx) {
    _debugLog('[_lowerFlatList()] args', { ctx });
    
    if (ctx.params.length < 2) { throw new Error('insufficient params left to lower list'); }
    const storagePtr = ctx.params[0];
    const elemCount = ctx.params[1];
    ctx.params = ctx.params.slice(2);
    
    if (ctx.useDirectParams) {
      const list = ctx.vals[0];
      if (!list) { throw new Error("missing direct param value"); }
      
      const elemLowerCtx = { storagePtr, memory: ctx.memory };
      for (let idx = 0; idx < list.length; idx++) {
        elemLowerCtx.vals = list.slice(idx, idx+1);
        elemLowerCtx.storagePtr += elemLowerFn(elemLowerCtx);
      }
      
      const bytesLowered = elemLowerCtx.storagePtr - ctx.storagePtr;
      ctx.storagePtr = elemLowerCtx.storagePtr;
      return bytesLowered;
    }
    
    
    if (ctx.vals.length !== 2) {
      throw new Error('indirect parameter loading must have a pointer and length as vals');
    }
    let [valStartPtr, valLen] = ctx.vals;
    const totalSizeBytes = valLen * size;
    if (ctx.storageLen !== undefined && totalSizeBytes > ctx.storageLen) {
      throw new Error('not enough storage remaining for list flat lower');
    }
    
    const data = new Uint8Array(memory.buffer, valStartPtr, totalSizeBytes);
    new Uint8Array(memory.buffer, storagePtr, totalSizeBytes).set(data);
    
    return totalSizeBytes;
  }
}

function _lowerFlatTuple(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatTuple()] args', { size, memory, vals, storagePtr, storageLen });
  let [start, len] = vals;
  if (storageLen !== undefined && len > storageLen) {
    throw new Error('not enough storage remaining for tuple flat lower');
  }
  const data = new Uint8Array(memory.buffer, start, len);
  new Uint8Array(memory.buffer, storagePtr, len).set(data);
  return data.byteLength;
}

function _lowerFlatFlags(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatFlags()] args', { size, memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) { throw new Error('unexpected number of core vals'); }
  new DataView(memory.buffer).setInt32(storagePtr, vals[0], true);
  return 4;
}

function _lowerFlatEnum(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatEnum()] args', { size, memory, vals, storagePtr, storageLen });
  let [start] = vals;
  if (storageLen !== undefined && size !== undefined && size > storageLen) {
    throw new Error('not enough storage remaining for enum flat lower');
  }
  const data = new Uint8Array(memory.buffer, start, size);
  new Uint8Array(memory.buffer, storagePtr, size).set(data);
  return data.byteLength;
}

function _lowerFlatOption(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatOption()] args', { size, memory, vals, storagePtr, storageLen });
  let [start] = vals;
  if (storageLen !== undefined && size !== undefined && size > storageLen) {
    throw new Error('not enough storage remaining for option flat lower');
  }
  const data = new Uint8Array(memory.buffer, start, size);
  new Uint8Array(memory.buffer, storagePtr, size).set(data);
  return data.byteLength;
}

function _lowerFlatResult(lowerMetas) {
  const invalidTag = lowerMetas.find(t => t.tag !== 'ok' && t.tag !== 'error')
  if (invalidTag) { throw new Error(`invalid variant tag [${invalidTag}] found for result`); }
  
  return function _lowerFlatResultInner() {
    _debugLog('[_lowerFlatResult()] args', { lowerMetas });
    let lowerFn = _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas }, { forResult: true });
    return lowerFn.apply(null, arguments);
  };
}

function _lowerFlatOwn(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatOwn()] args', { size, memory, vals, storagePtr, storageLen });
  throw new Error('flat lower for owned resources not yet implemented!');
}
const ASYNC_STATE = new Map();

function getOrCreateAsyncState(componentIdx, init) {
  if (!ASYNC_STATE.has(componentIdx)) {
    const newState = new ComponentAsyncState({ componentIdx });
    ASYNC_STATE.set(componentIdx, newState);
  }
  return ASYNC_STATE.get(componentIdx);
}

class ComponentAsyncState {
  static EVENT_HANDLER_EVENTS = [ 'backpressure-change' ];
  
  #componentIdx;
  #callingAsyncImport = false;
  #syncImportWait = promiseWithResolvers();
  #locked = false;
  #parkedTasks = new Map();
  #suspendedTasksByTaskID = new Map();
  #suspendedTaskIDs = [];
  #pendingTasks = [];
  #errored = null;
  
  #backpressure = 0;
  #backpressureWaiters = 0n;
  
  #handlerMap = new Map();
  #nextHandlerID = 0n;
  
  mayLeave = true;
  
  #streams;
  
  waitableSets;
  waitables;
  subtasks;
  
  constructor(args) {
    this.#componentIdx = args.componentIdx;
    this.waitableSets = new RepTable({ target: `component [${this.#componentIdx}] waitable sets` });
    this.waitables = new RepTable({ target: `component [${this.#componentIdx}] waitables` });
    this.subtasks = new RepTable({ target: `component [${this.#componentIdx}] subtasks` });
    this.#streams = new Map();
  };
  
  componentIdx() { return this.#componentIdx; }
  streams() { return this.#streams; }
  
  errored() { return this.#errored !== null; }
  setErrored(err) {
    _debugLog('[ComponentAsyncState#setErrored()] component errored', { err, componentIdx: this.#componentIdx });
    if (this.#errored) { return; }
    if (!err) {
      err = new Error('error elswehere (see other component instance error)')
      err.componentIdx = this.#componentIdx;
    }
    this.#errored = err;
  }
  
  callingSyncImport(val) {
    if (val === undefined) { return this.#callingAsyncImport; }
    if (typeof val !== 'boolean') { throw new TypeError('invalid setting for async import'); }
    const prev = this.#callingAsyncImport;
    this.#callingAsyncImport = val;
    if (prev === true && this.#callingAsyncImport === false) {
      this.#notifySyncImportEnd();
    }
  }
  
  #notifySyncImportEnd() {
    const existing = this.#syncImportWait;
    this.#syncImportWait = promiseWithResolvers();
    existing.resolve();
  }
  
  async waitForSyncImportCallEnd() {
    await this.#syncImportWait.promise;
  }
  
  setBackpressure(v) { this.#backpressure = v; }
  getBackpressure(v) { return this.#backpressure; }
  incrementBackpressure() {
    const newValue = this.getBackpressure() + 1;
    if (newValue > 2**16) { throw new Error("invalid backpressure value, overflow"); }
    this.setBackpressure(newValue);
  }
  decrementBackpressure() {
    this.setBackpressure(Math.max(0, this.getBackpressure() - 1));
  }
  hasBackpressure() { return this.#backpressure > 0; }
  
  waitForBackpressure() {
    let backpressureCleared = false;
    const cstate = this;
    cstate.addBackpressureWaiter();
    const handlerID = this.registerHandler({
      event: 'backpressure-change',
      fn: (bp) => {
        if (bp === 0) {
          cstate.removeHandler(handlerID);
          backpressureCleared = true;
        }
      }
    });
    return new Promise((resolve) => {
      const interval = setInterval(() => {
        if (backpressureCleared) { return; }
        clearInterval(interval);
        cstate.removeBackpressureWaiter();
        resolve(null);
      }, 0);
    });
  }
  
  registerHandler(args) {
    const { event, fn } = args;
    if (!event) { throw new Error("missing handler event"); }
    if (!fn) { throw new Error("missing handler fn"); }
    
    if (!ComponentAsyncState.EVENT_HANDLER_EVENTS.includes(event)) {
      throw new Error(`unrecognized event handler [${event}]`);
    }
    
    const handlerID = this.#nextHandlerID++;
    let handlers = this.#handlerMap.get(event);
    if (!handlers) {
      handlers = [];
      this.#handlerMap.set(event, handlers)
    }
    
    handlers.push({ id: handlerID, fn, event });
    return handlerID;
  }
  
  removeHandler(args) {
    const { event, handlerID } = args;
    const registeredHandlers = this.#handlerMap.get(event);
    if (!registeredHandlers) { return; }
    const found = registeredHandlers.find(h => h.id === handlerID);
    if (!found) { return; }
    this.#handlerMap.set(event, this.#handlerMap.get(event).filter(h => h.id !== handlerID));
  }
  
  getBackpressureWaiters() { return this.#backpressureWaiters; }
  addBackpressureWaiter() { this.#backpressureWaiters++; }
  removeBackpressureWaiter() {
    this.#backpressureWaiters--;
    if (this.#backpressureWaiters < 0) {
      throw new Error("unexepctedly negative number of backpressure waiters");
    }
  }
  
  parkTaskOnAwaitable(args) {
    if (!args.awaitable) { throw new TypeError('missing awaitable when trying to park'); }
    if (!args.task) { throw new TypeError('missing task when trying to park'); }
    const { awaitable, task } = args;
    
    let taskList = this.#parkedTasks.get(awaitable.id());
    if (!taskList) {
      taskList = [];
      this.#parkedTasks.set(awaitable.id(), taskList);
    }
    taskList.push(task);
    
    this.wakeNextTaskForAwaitable(awaitable);
  }
  
  wakeNextTaskForAwaitable(awaitable) {
    if (!awaitable) { throw new TypeError('missing awaitable when waking next task'); }
    const awaitableID = awaitable.id();
    
    const taskList = this.#parkedTasks.get(awaitableID);
    if (!taskList || taskList.length === 0) {
      _debugLog('[ComponentAsyncState] no tasks waiting for awaitable', { awaitableID: awaitable.id() });
      return;
    }
    
    let task = taskList.shift(); // todo(perf)
    if (!task) { throw new Error('no task in parked list despite previous check'); }
    
    if (!task.awaitableResume) {
      throw new Error('task ready due to awaitable is missing resume', { taskID: task.id(), awaitableID });
    }
    task.awaitableResume();
  }
  
  // TODO: we might want to check for pre-locked status here
  exclusiveLock() {
    this.#locked = true;
  }
  
  exclusiveRelease() {
    _debugLog('[ComponentAsyncState#exclusiveRelease()] releasing', {
      locked: this.#locked,
      componentIdx: this.#componentIdx,
    });
    
    this.#locked = false
  }
  
  isExclusivelyLocked() { return this.#locked === true; }
  
  #getSuspendedTaskMeta(taskID) {
    return this.#suspendedTasksByTaskID.get(taskID);
  }
  
  #removeSuspendedTaskMeta(taskID) {
    _debugLog('[ComponentAsyncState#removeSuspendedTaskMeta()] removing suspended task', { taskID });
    const idx = this.#suspendedTaskIDs.findIndex(t => t === taskID);
    const meta = this.#suspendedTasksByTaskID.get(taskID);
    this.#suspendedTaskIDs[idx] = null;
    this.#suspendedTasksByTaskID.delete(taskID);
    return meta;
  }
  
  #addSuspendedTaskMeta(meta) {
    if (!meta) { throw new Error('missing task meta'); }
    const taskID = meta.taskID;
    this.#suspendedTasksByTaskID.set(taskID, meta);
    this.#suspendedTaskIDs.push(taskID);
    if (this.#suspendedTasksByTaskID.size < this.#suspendedTaskIDs.length - 10) {
      this.#suspendedTaskIDs = this.#suspendedTaskIDs.filter(t => t !== null);
    }
  }
  
  suspendTask(args) {
    // TODO(threads): readyFn is normally on the thread
    const { task, readyFn } = args;
    const taskID = task.id();
    _debugLog('[ComponentAsyncState#suspendTask()]', { taskID });
    
    if (this.#getSuspendedTaskMeta(taskID)) {
      throw new Error('task [' + taskID + '] already suspended');
    }
    
    const { promise, resolve } = Promise.withResolvers();
    this.#addSuspendedTaskMeta({
      task,
      taskID,
      readyFn,
      resume: () => {
        _debugLog('[ComponentAsyncState#suspendTask()] resuming suspended task', { taskID });
        // TODO(threads): it's thread cancellation we should be checking for below, not task
        resolve(!task.isCancelled());
      },
    });
    
    return promise;
  }
  
  resumeTaskByID(taskID) {
    const meta = this.#removeSuspendedTaskMeta(taskID);
    if (!meta) { return; }
    if (meta.taskID !== taskID) { throw new Error('task ID does not match'); }
    meta.resume();
  }
  
  tick() {
    _debugLog('[ComponentAsyncState#tick()]', { suspendedTaskIDs: this.#suspendedTaskIDs });
    const resumableTasks = this.#suspendedTaskIDs.filter(t => t !== null);
    for (const taskID of resumableTasks) {
      const meta = this.#suspendedTasksByTaskID.get(taskID);
      if (!meta || !meta.readyFn) {
        throw new Error(`missing/invalid task despite ID [${taskID}] being present`);
      }
      
      const isReady = meta.readyFn();
      if (!isReady) { continue; }
      
      this.resumeTaskByID(taskID);
    }
    
    return this.#suspendedTaskIDs.filter(t => t !== null).length === 0;
  }
  
  addPendingTask(task) {
    this.#pendingTasks.push(task);
  }
  
  addStreamEnd(args) {
    _debugLog('[ComponentAsyncState#addStreamEnd()] args', args);
    const { tableIdx, streamEnd } = args;
    
    let tbl = this.#streams.get(tableIdx);
    if (!tbl) {
      tbl = new RepTable({ target: `component [${this.#componentIdx}] streams` });
      this.#streams.set(tableIdx, tbl);
    }
    
    const streamIdx = tbl.insert(streamEnd);
    return streamIdx;
  }
  
  createStream(args) {
    _debugLog('[ComponentAsyncState#createStream()] args', args);
    const { tableIdx, elemMeta } = args;
    if (tableIdx === undefined) { throw new Error("missing table idx while adding stream"); }
    if (elemMeta === undefined) { throw new Error("missing element metadata while adding stream"); }
    
    let tbl = this.#streams.get(tableIdx);
    if (!tbl) {
      tbl = new RepTable({ target: `component [${this.#componentIdx}] streams` });
      this.#streams.set(tableIdx, tbl);
    }
    
    const stream = new InternalStream({
      tableIdx,
      componentIdx: this.#componentIdx,
      elemMeta,
    });
    const writeEndIdx = tbl.insert(stream.getWriteEnd());
    stream.setWriteEndIdx(writeEndIdx);
    const readEndIdx = tbl.insert(stream.getReadEnd());
    stream.setReadEndIdx(readEndIdx);
    
    const rep = STREAMS.insert(stream);
    stream.setRep(rep);
    
    return { writeEndIdx, readEndIdx };
  }
  
  getStreamEnd(args) {
    _debugLog('[ComponentAsyncState#getStreamEnd()] args', args);
    const { tableIdx, streamIdx } = args;
    if (tableIdx === undefined) { throw new Error('missing table idx while retrieveing stream end'); }
    if (streamIdx === undefined) { throw new Error('missing stream idx while retrieveing stream end'); }
    
    const tbl = this.#streams.get(tableIdx);
    if (!tbl) {
      throw new Error(`missing stream table [${tableIdx}] in component [${this.#componentIdx}] while getting stream`);
    }
    
    const stream = tbl.get(streamIdx);
    return stream;
  }
  
  removeStreamEnd(args) {
    _debugLog('[ComponentAsyncState#removeStreamEnd()] args', args);
    const { tableIdx, streamIdx } = args;
    if (tableIdx === undefined) { throw new Error("missing table idx while removing stream end"); }
    if (streamIdx === undefined) { throw new Error("missing stream idx while removing stream end"); }
    
    const tbl = this.#streams.get(tableIdx);
    if (!tbl) {
      throw new Error(`missing stream table [${tableIdx}] in component [${this.#componentIdx}] while removing stream end`);
    }
    
    const stream = tbl.get(streamIdx);
    if (!stream) { throw new Error(`component [${this.#componentIdx}] missing stream [${streamIdx}]`); }
    
    const removed = tbl.remove(streamIdx);
    if (!removed) {
      throw new Error(`missing stream [${streamIdx}] (table [${tableIdx}]) in component [${this.#componentIdx}] while removing stream end`);
    }
    
    return stream;
  }
}

function clampGuest(i, min, max) {
  if (i < min || i > max) throw new TypeError(`must be between ${min} and ${max}`);
  return i;
}

const symbolCabiDispose = Symbol.for('cabiDispose');

const symbolRscHandle = Symbol('handle');

const symbolRscRep = Symbol.for('cabiRep');

const symbolDispose = Symbol.dispose || Symbol.for('dispose');

const handleTables = [];

function finalizationRegistryCreate (unregister) {
  if (typeof FinalizationRegistry === 'undefined') {
    return { unregister () {} };
  }
  return new FinalizationRegistry(unregister);
}

function getErrorPayload(e) {
  if (e && hasOwnProperty.call(e, 'payload')) return e.payload;
  if (e instanceof Error) throw e;
  return e;
}

function throwInvalidBool() {
  throw new TypeError('invalid variant discriminant for bool');
}

const hasOwnProperty = Object.prototype.hasOwnProperty;


const module0 = getCoreModule('composed-js.core.wasm');
const module1 = getCoreModule('composed-js.core2.wasm');
const module2 = getCoreModule('composed-js.core3.wasm');
const module3 = getCoreModule('composed-js.core4.wasm');
const module4 = getCoreModule('composed-js.core5.wasm');
const module5 = getCoreModule('composed-js.core6.wasm');
const module6 = getCoreModule('composed-js.core7.wasm');
const module7 = getCoreModule('composed-js.core8.wasm');
const module8 = getCoreModule('composed-js.core9.wasm');

const { onDone, onNumber } = imports['docs:calculator/stream-sink'];
onDone._isHostProvided = true;

if (onDone=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'onDone', was 'onDone' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

onNumber._isHostProvided = true;

if (onNumber=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'onNumber', was 'onNumber' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getArguments, getEnvironment, initialCwd } = imports['wasi:cli/environment'];
getArguments._isHostProvided = true;

if (getArguments=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getArguments', was 'getArguments' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

getEnvironment._isHostProvided = true;

if (getEnvironment=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getEnvironment', was 'getEnvironment' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

initialCwd._isHostProvided = true;

if (initialCwd=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'initialCwd', was 'initialCwd' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { exit } = imports['wasi:cli/exit'];
exit._isHostProvided = true;

if (exit=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'exit', was 'exit' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getStderr } = imports['wasi:cli/stderr'];
getStderr._isHostProvided = true;

if (getStderr=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getStderr', was 'getStderr' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getStdin } = imports['wasi:cli/stdin'];
getStdin._isHostProvided = true;

if (getStdin=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getStdin', was 'getStdin' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getStdout } = imports['wasi:cli/stdout'];
getStdout._isHostProvided = true;

if (getStdout=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getStdout', was 'getStdout' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { TerminalInput } = imports['wasi:cli/terminal-input'];
TerminalInput._isHostProvided = true;

if (TerminalInput=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'TerminalInput', was 'TerminalInput' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { TerminalOutput } = imports['wasi:cli/terminal-output'];
TerminalOutput._isHostProvided = true;

if (TerminalOutput=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'TerminalOutput', was 'TerminalOutput' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getTerminalStderr } = imports['wasi:cli/terminal-stderr'];
getTerminalStderr._isHostProvided = true;

if (getTerminalStderr=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getTerminalStderr', was 'getTerminalStderr' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getTerminalStdin } = imports['wasi:cli/terminal-stdin'];
getTerminalStdin._isHostProvided = true;

if (getTerminalStdin=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getTerminalStdin', was 'getTerminalStdin' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getTerminalStdout } = imports['wasi:cli/terminal-stdout'];
getTerminalStdout._isHostProvided = true;

if (getTerminalStdout=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getTerminalStdout', was 'getTerminalStdout' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { now, subscribeDuration, subscribeInstant } = imports['wasi:clocks/monotonic-clock'];
now._isHostProvided = true;

if (now=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'now', was 'now' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

subscribeDuration._isHostProvided = true;

if (subscribeDuration=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'subscribeDuration', was 'subscribeDuration' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

subscribeInstant._isHostProvided = true;

if (subscribeInstant=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'subscribeInstant', was 'subscribeInstant' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getDirectories } = imports['wasi:filesystem/preopens'];
getDirectories._isHostProvided = true;

if (getDirectories=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getDirectories', was 'getDirectories' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Descriptor, DirectoryEntryStream, filesystemErrorCode } = imports['wasi:filesystem/types'];
Descriptor._isHostProvided = true;

if (Descriptor=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'Descriptor', was 'Descriptor' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

DirectoryEntryStream._isHostProvided = true;

if (DirectoryEntryStream=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'DirectoryEntryStream', was 'DirectoryEntryStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

filesystemErrorCode._isHostProvided = true;

if (filesystemErrorCode=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'filesystemErrorCode', was 'filesystemErrorCode' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Error: Error$1 } = imports['wasi:io/error'];
Error$1._isHostProvided = true;

if (Error$1=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'Error$1', was 'Error' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Pollable, poll } = imports['wasi:io/poll'];
Pollable._isHostProvided = true;

if (Pollable=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'Pollable', was 'Pollable' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

poll._isHostProvided = true;

if (poll=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'poll', was 'poll' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { InputStream, OutputStream } = imports['wasi:io/streams'];
InputStream._isHostProvided = true;

if (InputStream=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'InputStream', was 'InputStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

OutputStream._isHostProvided = true;

if (OutputStream=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'OutputStream', was 'OutputStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getRandomBytes, getRandomU64 } = imports['wasi:random/random'];
getRandomBytes._isHostProvided = true;

if (getRandomBytes=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getRandomBytes', was 'getRandomBytes' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

getRandomU64._isHostProvided = true;

if (getRandomU64=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'getRandomU64', was 'getRandomU64' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { instanceNetwork } = imports['wasi:sockets/instance-network'];
instanceNetwork._isHostProvided = true;

if (instanceNetwork=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'instanceNetwork', was 'instanceNetwork' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { ResolveAddressStream, resolveAddresses } = imports['wasi:sockets/ip-name-lookup'];
ResolveAddressStream._isHostProvided = true;

if (ResolveAddressStream=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'ResolveAddressStream', was 'ResolveAddressStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

resolveAddresses._isHostProvided = true;

if (resolveAddresses=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'resolveAddresses', was 'resolveAddresses' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Network } = imports['wasi:sockets/network'];
Network._isHostProvided = true;

if (Network=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'Network', was 'Network' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { TcpSocket } = imports['wasi:sockets/tcp'];
TcpSocket._isHostProvided = true;

if (TcpSocket=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'TcpSocket', was 'TcpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { createTcpSocket } = imports['wasi:sockets/tcp-create-socket'];
createTcpSocket._isHostProvided = true;

if (createTcpSocket=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'createTcpSocket', was 'createTcpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { IncomingDatagramStream, OutgoingDatagramStream, UdpSocket } = imports['wasi:sockets/udp'];
IncomingDatagramStream._isHostProvided = true;

if (IncomingDatagramStream=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'IncomingDatagramStream', was 'IncomingDatagramStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

OutgoingDatagramStream._isHostProvided = true;

if (OutgoingDatagramStream=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'OutgoingDatagramStream', was 'OutgoingDatagramStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

UdpSocket._isHostProvided = true;

if (UdpSocket=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'UdpSocket', was 'UdpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { createUdpSocket } = imports['wasi:sockets/udp-create-socket'];
createUdpSocket._isHostProvided = true;

if (createUdpSocket=== undefined) {
  const err = new Error("unexpectedly undefined instance import 'createUdpSocket', was 'createUdpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

let gen = (function* _initGenerator () {
  const instanceFlags1 = new WebAssembly.Global({ value: "i32", mutable: true }, 3);
  const instanceFlags3 = new WebAssembly.Global({ value: "i32", mutable: true }, 3);
  let exports0;
  
  let lowered_import_0_metadata = {
    qualifiedImportFn: 'wasi:io/poll@0.2.3#[method]pollable.block',
    moduleIdx: null,
  };
  
  const handleTable14 = [T_FLAG, 0];
  const captureTable1= new Map();
  let captureCnt1 = 0;
  handleTables[14] = handleTable14;
  
  function trampoline4(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable14[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable1.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Pollable.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.block"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.block?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'block',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret; rsc0.block();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.block"][Instruction::Return]', {
      funcName: '[method]pollable.block',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_1_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable15 = [T_FLAG, 0];
  const captureTable2= new Map();
  let captureCnt2 = 0;
  handleTables[15] = handleTable15;
  
  function trampoline5(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable15[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]input-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_2_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable16 = [T_FLAG, 0];
  const captureTable3= new Map();
  let captureCnt3 = 0;
  handleTables[16] = handleTable16;
  
  function trampoline6(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]output-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_3_metadata = {
    qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.3#now',
    moduleIdx: null,
  };
  
  
  function trampoline7() {
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="now"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = now?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'now',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  now();
    endCurrentTask(1);
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="now"][Instruction::Return]', {
      funcName: 'now',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return toUint64(ret);
  }
  
  
  let lowered_import_4_metadata = {
    qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.3#subscribe-instant',
    moduleIdx: null,
  };
  
  
  function trampoline8(arg0) {
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-instant"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = subscribeInstant?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribeInstant',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  subscribeInstant(BigInt.asUintN(64, arg0));
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-instant"][Instruction::Return]', {
      funcName: 'subscribe-instant',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_5_metadata = {
    qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.3#subscribe-duration',
    moduleIdx: null,
  };
  
  
  function trampoline9(arg0) {
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-duration"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = subscribeDuration?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribeDuration',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  subscribeDuration(BigInt.asUintN(64, arg0));
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-duration"][Instruction::Return]', {
      funcName: 'subscribe-duration',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_6_metadata = {
    qualifiedImportFn: 'wasi:sockets/instance-network@0.2.3#instance-network',
    moduleIdx: null,
  };
  
  const handleTable18 = [T_FLAG, 0];
  const captureTable8= new Map();
  let captureCnt8 = 0;
  handleTables[18] = handleTable18;
  
  function trampoline10() {
    _debugLog('[iface="wasi:sockets/instance-network@0.2.3", function="instance-network"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = instanceNetwork?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'instanceNetwork',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  instanceNetwork();
    endCurrentTask(1);
    if (!(ret instanceof Network)) {
      throw new TypeError('Resource error: Not a valid "Network" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt8;
      captureTable8.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable18, rep);
    }
    _debugLog('[iface="wasi:sockets/instance-network@0.2.3", function="instance-network"][Instruction::Return]', {
      funcName: 'instance-network',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_7_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.subscribe',
    moduleIdx: null,
  };
  
  const handleTable17 = [T_FLAG, 0];
  const captureTable12= new Map();
  let captureCnt12 = 0;
  handleTables[17] = handleTable17;
  
  function trampoline11(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.subscribe"][Instruction::Return]', {
      funcName: '[method]tcp-socket.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_8_metadata = {
    qualifiedImportFn: 'wasi:random/random@0.2.3#get-random-u64',
    moduleIdx: null,
  };
  
  
  function trampoline12() {
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-u64"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getRandomU64?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getRandomU64',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getRandomU64();
    endCurrentTask(1);
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-u64"][Instruction::Return]', {
      funcName: 'get-random-u64',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return toUint64(ret);
  }
  
  
  let lowered_import_9_metadata = {
    qualifiedImportFn: 'wasi:cli/exit@0.2.3#exit',
    moduleIdx: null,
  };
  
  
  function trampoline13(arg0) {
    let variant0;
    switch (arg0) {
      case 0: {
        variant0= {
          tag: 'ok',
          val: undefined
        };
        break;
      }
      case 1: {
        variant0= {
          tag: 'err',
          val: undefined
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for expected');
      }
    }
    _debugLog('[iface="wasi:cli/exit@0.2.3", function="exit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = exit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'exit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret; exit(variant0);
    endCurrentTask(1);
    _debugLog('[iface="wasi:cli/exit@0.2.3", function="exit"][Instruction::Return]', {
      funcName: 'exit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_10_metadata = {
    qualifiedImportFn: 'wasi:io/poll@0.2.3#[method]pollable.ready',
    moduleIdx: null,
  };
  
  
  function trampoline14(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable14[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable1.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Pollable.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.ready"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.ready?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'ready',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.ready();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.ready"][Instruction::Return]', {
      funcName: '[method]pollable.ready',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return ret ? 1 : 0;
  }
  
  
  let lowered_import_11_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.is-same-object',
    moduleIdx: null,
  };
  
  const handleTable20 = [T_FLAG, 0];
  const captureTable6= new Map();
  let captureCnt6 = 0;
  handleTables[20] = handleTable20;
  
  function trampoline15(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable20[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable6.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.is-same-object"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.isSameObject?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'isSameObject',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.isSameObject(rsc3);
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.is-same-object"][Instruction::Return]', {
      funcName: '[method]descriptor.is-same-object',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return ret ? 1 : 0;
  }
  
  
  let lowered_import_12_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.address-family',
    moduleIdx: null,
  };
  
  const handleTable22 = [T_FLAG, 0];
  const captureTable9= new Map();
  let captureCnt9 = 0;
  handleTables[22] = handleTable22;
  
  function trampoline16(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.address-family"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.addressFamily?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'addressFamily',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.addressFamily();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var val3 = ret;
    let enum3;
    switch (val3) {
      case 'ipv4': {
        enum3 = 0;
        break;
      }
      case 'ipv6': {
        enum3 = 1;
        break;
      }
      default: {
        if ((ret) instanceof Error) {
          console.error(ret);
        }
        
        throw new TypeError(`"${val3}" is not one of the cases of ip-address-family`);
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.address-family"][Instruction::Return]', {
      funcName: '[method]udp-socket.address-family',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return enum3;
  }
  
  
  let lowered_import_13_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.subscribe',
    moduleIdx: null,
  };
  
  
  function trampoline17(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.subscribe"][Instruction::Return]', {
      funcName: '[method]udp-socket.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_14_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]incoming-datagram-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable23 = [T_FLAG, 0];
  const captureTable10= new Map();
  let captureCnt10 = 0;
  handleTables[23] = handleTable23;
  
  function trampoline18(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable23[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable10.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(IncomingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]incoming-datagram-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_15_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]outgoing-datagram-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable24 = [T_FLAG, 0];
  const captureTable11= new Map();
  let captureCnt11 = 0;
  handleTables[24] = handleTable24;
  
  function trampoline19(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable24[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable11.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutgoingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]outgoing-datagram-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_16_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.is-listening',
    moduleIdx: null,
  };
  
  
  function trampoline20(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.is-listening"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.isListening?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'isListening',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.isListening();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.is-listening"][Instruction::Return]', {
      funcName: '[method]tcp-socket.is-listening',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return ret ? 1 : 0;
  }
  
  
  let lowered_import_17_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.address-family',
    moduleIdx: null,
  };
  
  
  function trampoline21(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.address-family"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.addressFamily?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'addressFamily',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.addressFamily();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var val3 = ret;
    let enum3;
    switch (val3) {
      case 'ipv4': {
        enum3 = 0;
        break;
      }
      case 'ipv6': {
        enum3 = 1;
        break;
      }
      default: {
        if ((ret) instanceof Error) {
          console.error(ret);
        }
        
        throw new TypeError(`"${val3}" is not one of the cases of ip-address-family`);
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.address-family"][Instruction::Return]', {
      funcName: '[method]tcp-socket.address-family',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return enum3;
  }
  
  
  let lowered_import_18_metadata = {
    qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.3#[method]resolve-address-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable25 = [T_FLAG, 0];
  const captureTable13= new Map();
  let captureCnt13 = 0;
  handleTables[25] = handleTable25;
  
  function trampoline22(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable25[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable13.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(ResolveAddressStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable14, rep);
    }
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]resolve-address-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  let exports1;
  
  let lowered_import_19_metadata = {
    qualifiedImportFn: 'wasi:cli/stderr@0.2.3#get-stderr',
    moduleIdx: null,
  };
  
  
  function trampoline33() {
    _debugLog('[iface="wasi:cli/stderr@0.2.3", function="get-stderr"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getStderr?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getStderr',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getStderr();
    endCurrentTask(1);
    if (!(ret instanceof OutputStream)) {
      throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt3;
      captureTable3.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable16, rep);
    }
    _debugLog('[iface="wasi:cli/stderr@0.2.3", function="get-stderr"][Instruction::Return]', {
      funcName: 'get-stderr',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_20_metadata = {
    qualifiedImportFn: 'wasi:cli/stdin@0.2.3#get-stdin',
    moduleIdx: null,
  };
  
  
  function trampoline34() {
    _debugLog('[iface="wasi:cli/stdin@0.2.3", function="get-stdin"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getStdin?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getStdin',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getStdin();
    endCurrentTask(1);
    if (!(ret instanceof InputStream)) {
      throw new TypeError('Resource error: Not a valid "InputStream" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt2;
      captureTable2.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable15, rep);
    }
    _debugLog('[iface="wasi:cli/stdin@0.2.3", function="get-stdin"][Instruction::Return]', {
      funcName: 'get-stdin',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_21_metadata = {
    qualifiedImportFn: 'wasi:cli/stdout@0.2.3#get-stdout',
    moduleIdx: null,
  };
  
  
  function trampoline35() {
    _debugLog('[iface="wasi:cli/stdout@0.2.3", function="get-stdout"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getStdout?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getStdout',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getStdout();
    endCurrentTask(1);
    if (!(ret instanceof OutputStream)) {
      throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt3;
      captureTable3.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable16, rep);
    }
    _debugLog('[iface="wasi:cli/stdout@0.2.3", function="get-stdout"][Instruction::Return]', {
      funcName: 'get-stdout',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  let exports2;
  let memory0;
  let realloc0;
  let realloc1;
  
  let lowered_import_22_metadata = {
    qualifiedImportFn: 'wasi:io/poll@0.2.3#poll',
    moduleIdx: null,
  };
  
  
  function trampoline36(arg0, arg1, arg2) {
    var len3 = arg1;
    var base3 = arg0;
    var result3 = [];
    for (let i = 0; i < len3; i++) {
      const base = base3 + i * 4;
      var handle1 = dataView(memory0).getInt32(base + 0, true);
      var rep2 = handleTable14[(handle1 << 1) + 1] & ~T_FLAG;
      var rsc0 = captureTable1.get(rep2);
      if (!rsc0) {
        rsc0 = Object.create(Pollable.prototype);
        Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
        Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
      }
      curResourceBorrows.push(rsc0);
      result3.push(rsc0);
    }
    _debugLog('[iface="wasi:io/poll@0.2.3", function="poll"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = poll?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'poll',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  poll(result3);
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var val4 = ret;
    var len4 = val4.length;
    var ptr4 = realloc0(0, 0, 4, len4 * 4);
    
    let valData4;
    const valLenBytes4 = len4 * 4;
    if (Array.isArray(val4)) {
      // Regular array likely containing numbers, write values to memory
      let offset = 0;
      const dv4 = new DataView(memory0.buffer);
      for (const v of val4) {
        dv4.setUint32(ptr4+ offset, v, true);
        offset += 4;
      }
    } else {
      // TypedArray / ArrayBuffer-like, direct copy
      valData4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, valLenBytes4);
      const out4 = new Uint8Array(memory0.buffer, ptr4,valLenBytes4);
      out4.set(valData4);
    }
    
    dataView(memory0).setUint32(arg2 + 4, len4, true);
    dataView(memory0).setUint32(arg2 + 0, ptr4, true);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="poll"][Instruction::Return]', {
      funcName: 'poll',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_23_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.read',
    moduleIdx: null,
  };
  
  const handleTable19 = [T_FLAG, 0];
  const captureTable0= new Map();
  let captureCnt0 = 0;
  handleTables[19] = handleTable19;
  
  function trampoline37(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable15[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.read?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'read',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc0(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory0.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory0.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory0).setUint32(arg2 + 8, len3, true);
        dataView(memory0).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"][Instruction::Return]', {
      funcName: '[method]input-stream.read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_24_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.blocking-read',
    moduleIdx: null,
  };
  
  
  function trampoline38(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable15[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingRead?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'blockingRead',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingRead(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc0(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory0.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory0.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory0).setUint32(arg2 + 8, len3, true);
        dataView(memory0).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"][Instruction::Return]', {
      funcName: '[method]input-stream.blocking-read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_25_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.check-write',
    moduleIdx: null,
  };
  
  
  function trampoline39(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.check-write"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.checkWrite?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'checkWrite',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.checkWrite()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory0).setInt8(arg1 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg1 + 12, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg1 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.check-write"][Instruction::Return]', {
      funcName: '[method]output-stream.check-write',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_26_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.write',
    moduleIdx: null,
  };
  
  
  function trampoline40(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.write?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'write',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.write(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg3 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg3 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg3 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write"][Instruction::Return]', {
      funcName: '[method]output-stream.write',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_27_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-flush',
    moduleIdx: null,
  };
  
  
  function trampoline41(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingFlush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'blockingFlush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingFlush()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory0).setInt8(arg1 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg1 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg1 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-flush"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_28_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.start-connect',
    moduleIdx: null,
  };
  
  
  function trampoline42(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable18[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable8.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Network.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    let variant6;
    switch (arg2) {
      case 0: {
        variant6= {
          tag: 'ipv4',
          val: {
            port: clampGuest(arg3, 0, 65535),
            address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
          }
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'ipv6',
          val: {
            port: clampGuest(arg3, 0, 65535),
            flowInfo: arg4 >>> 0,
            address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
            scopeId: arg13 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for IpSocketAddress');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-connect"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startConnect?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'startConnect',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startConnect(rsc3, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg14 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg14 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg14 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-connect"][Instruction::Return]', {
      funcName: '[method]tcp-socket.start-connect',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_29_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.finish-connect',
    moduleIdx: null,
  };
  
  
  function trampoline43(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-connect"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishConnect?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'finishConnect',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishConnect()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant7 = ret;
    switch (variant7.tag) {
      case 'ok': {
        const e = variant7.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var [tuple3_0, tuple3_1] = e;
        if (!(tuple3_0 instanceof InputStream)) {
          throw new TypeError('Resource error: Not a valid "InputStream" resource.');
        }
        var handle4 = tuple3_0[symbolRscHandle];
        if (!handle4) {
          const rep = tuple3_0[symbolRscRep] || ++captureCnt2;
          captureTable2.set(rep, tuple3_0);
          handle4 = rscTableCreateOwn(handleTable15, rep);
        }
        dataView(memory0).setInt32(arg1 + 4, handle4, true);
        if (!(tuple3_1 instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle5 = tuple3_1[symbolRscHandle];
        if (!handle5) {
          const rep = tuple3_1[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, tuple3_1);
          handle5 = rscTableCreateOwn(handleTable16, rep);
        }
        dataView(memory0).setInt32(arg1 + 8, handle5, true);
        break;
      }
      case 'err': {
        const e = variant7.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val6 = e;
        let enum6;
        switch (val6) {
          case 'unknown': {
            enum6 = 0;
            break;
          }
          case 'access-denied': {
            enum6 = 1;
            break;
          }
          case 'not-supported': {
            enum6 = 2;
            break;
          }
          case 'invalid-argument': {
            enum6 = 3;
            break;
          }
          case 'out-of-memory': {
            enum6 = 4;
            break;
          }
          case 'timeout': {
            enum6 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum6 = 6;
            break;
          }
          case 'not-in-progress': {
            enum6 = 7;
            break;
          }
          case 'would-block': {
            enum6 = 8;
            break;
          }
          case 'invalid-state': {
            enum6 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum6 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum6 = 11;
            break;
          }
          case 'address-in-use': {
            enum6 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum6 = 13;
            break;
          }
          case 'connection-refused': {
            enum6 = 14;
            break;
          }
          case 'connection-reset': {
            enum6 = 15;
            break;
          }
          case 'connection-aborted': {
            enum6 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum6 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum6 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum6 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum6 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val6}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum6, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-connect"][Instruction::Return]', {
      funcName: '[method]tcp-socket.finish-connect',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_30_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.shutdown',
    moduleIdx: null,
  };
  
  
  function trampoline44(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let enum3;
    switch (arg1) {
      case 0: {
        enum3 = 'receive';
        break;
      }
      case 1: {
        enum3 = 'send';
        break;
      }
      case 2: {
        enum3 = 'both';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for ShutdownType');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.shutdown"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.shutdown?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'shutdown',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.shutdown(enum3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'access-denied': {
            enum4 = 1;
            break;
          }
          case 'not-supported': {
            enum4 = 2;
            break;
          }
          case 'invalid-argument': {
            enum4 = 3;
            break;
          }
          case 'out-of-memory': {
            enum4 = 4;
            break;
          }
          case 'timeout': {
            enum4 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum4 = 6;
            break;
          }
          case 'not-in-progress': {
            enum4 = 7;
            break;
          }
          case 'would-block': {
            enum4 = 8;
            break;
          }
          case 'invalid-state': {
            enum4 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum4 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum4 = 11;
            break;
          }
          case 'address-in-use': {
            enum4 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum4 = 13;
            break;
          }
          case 'connection-refused': {
            enum4 = 14;
            break;
          }
          case 'connection-reset': {
            enum4 = 15;
            break;
          }
          case 'connection-aborted': {
            enum4 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum4 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum4 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum4 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum4 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.shutdown"][Instruction::Return]', {
      funcName: '[method]tcp-socket.shutdown',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_31_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-arguments',
    moduleIdx: null,
  };
  
  
  function trampoline45(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getArguments?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getArguments',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getArguments();
    endCurrentTask(1);
    var vec1 = ret;
    var len1 = vec1.length;
    var result1 = realloc0(0, 0, 4, len1 * 8);
    for (let i = 0; i < vec1.length; i++) {
      const e = vec1[i];
      const base = result1 + i * 8;
      var encodeRes = _utf8AllocateAndEncode(e, realloc0, memory0);
      var ptr0= encodeRes.ptr;
      var len0 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 4, len0, true);
      dataView(memory0).setUint32(base + 0, ptr0, true);
    }
    dataView(memory0).setUint32(arg0 + 4, len1, true);
    dataView(memory0).setUint32(arg0 + 0, result1, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"][Instruction::Return]', {
      funcName: 'get-arguments',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_32_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp-create-socket@0.2.3#create-tcp-socket',
    moduleIdx: null,
  };
  
  
  function trampoline46(arg0, arg1) {
    let enum0;
    switch (arg0) {
      case 0: {
        enum0 = 'ipv4';
        break;
      }
      case 1: {
        enum0 = 'ipv6';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for IpAddressFamily');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp-create-socket@0.2.3", function="create-tcp-socket"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = createTcpSocket?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'createTcpSocket',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  createTcpSocket(enum0)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    endCurrentTask(1);
    var variant3 = ret;
    switch (variant3.tag) {
      case 'ok': {
        const e = variant3.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof TcpSocket)) {
          throw new TypeError('Resource error: Not a valid "TcpSocket" resource.');
        }
        var handle1 = e[symbolRscHandle];
        if (!handle1) {
          const rep = e[symbolRscRep] || ++captureCnt12;
          captureTable12.set(rep, e);
          handle1 = rscTableCreateOwn(handleTable17, rep);
        }
        dataView(memory0).setInt32(arg1 + 4, handle1, true);
        break;
      }
      case 'err': {
        const e = variant3.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val2 = e;
        let enum2;
        switch (val2) {
          case 'unknown': {
            enum2 = 0;
            break;
          }
          case 'access-denied': {
            enum2 = 1;
            break;
          }
          case 'not-supported': {
            enum2 = 2;
            break;
          }
          case 'invalid-argument': {
            enum2 = 3;
            break;
          }
          case 'out-of-memory': {
            enum2 = 4;
            break;
          }
          case 'timeout': {
            enum2 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum2 = 6;
            break;
          }
          case 'not-in-progress': {
            enum2 = 7;
            break;
          }
          case 'would-block': {
            enum2 = 8;
            break;
          }
          case 'invalid-state': {
            enum2 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum2 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum2 = 11;
            break;
          }
          case 'address-in-use': {
            enum2 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum2 = 13;
            break;
          }
          case 'connection-refused': {
            enum2 = 14;
            break;
          }
          case 'connection-reset': {
            enum2 = 15;
            break;
          }
          case 'connection-aborted': {
            enum2 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum2 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum2 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum2 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum2 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val2}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum2, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp-create-socket@0.2.3", function="create-tcp-socket"][Instruction::Return]', {
      funcName: 'create-tcp-socket',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_33_metadata = {
    qualifiedImportFn: 'wasi:random/random@0.2.3#get-random-bytes',
    moduleIdx: null,
  };
  
  
  function trampoline47(arg0, arg1) {
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-bytes"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getRandomBytes?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getRandomBytes',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getRandomBytes(BigInt.asUintN(64, arg0));
    endCurrentTask(1);
    var val0 = ret;
    var len0 = val0.byteLength;
    var ptr0 = realloc0(0, 0, 1, len0 * 1);
    
    let valData0;
    const valLenBytes0 = len0 * 1;
    if (Array.isArray(val0)) {
      // Regular array likely containing numbers, write values to memory
      let offset = 0;
      const dv0 = new DataView(memory0.buffer);
      for (const v of val0) {
        dv0.setUint8(ptr0+ offset, v, true);
        offset += 1;
      }
    } else {
      // TypedArray / ArrayBuffer-like, direct copy
      valData0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, valLenBytes0);
      const out0 = new Uint8Array(memory0.buffer, ptr0,valLenBytes0);
      out0.set(valData0);
    }
    
    dataView(memory0).setUint32(arg1 + 4, len0, true);
    dataView(memory0).setUint32(arg1 + 0, ptr0, true);
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-bytes"][Instruction::Return]', {
      funcName: 'get-random-bytes',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_34_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-environment',
    moduleIdx: null,
  };
  
  
  function trampoline48(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getEnvironment?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getEnvironment',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getEnvironment();
    endCurrentTask(1);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc0(0, 0, 4, len3 * 16);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 16;var [tuple0_0, tuple0_1] = e;
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_0, realloc0, memory0);
      var ptr1= encodeRes.ptr;
      var len1 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 4, len1, true);
      dataView(memory0).setUint32(base + 0, ptr1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc0, memory0);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 12, len2, true);
      dataView(memory0).setUint32(base + 8, ptr2, true);
    }
    dataView(memory0).setUint32(arg0 + 4, len3, true);
    dataView(memory0).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"][Instruction::Return]', {
      funcName: 'get-environment',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_35_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#initial-cwd',
    moduleIdx: null,
  };
  
  
  function trampoline49(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="initial-cwd"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = initialCwd?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'initialCwd',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  initialCwd();
    endCurrentTask(1);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory0).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory0).setInt8(arg0 + 0, 1, true);
      
      var encodeRes = _utf8AllocateAndEncode(e, realloc0, memory0);
      var ptr0= encodeRes.ptr;
      var len0 = encodeRes.len;
      
      dataView(memory0).setUint32(arg0 + 8, len0, true);
      dataView(memory0).setUint32(arg0 + 4, ptr0, true);
    }
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="initial-cwd"][Instruction::Return]', {
      funcName: 'initial-cwd',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_36_metadata = {
    qualifiedImportFn: 'wasi:io/error@0.2.3#[method]error.to-debug-string',
    moduleIdx: null,
  };
  
  
  function trampoline50(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable19[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable0.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Error$1.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/error@0.2.3", function="[method]error.to-debug-string"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.toDebugString?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'toDebugString',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.toDebugString();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    
    var encodeRes = _utf8AllocateAndEncode(ret, realloc0, memory0);
    var ptr3= encodeRes.ptr;
    var len3 = encodeRes.len;
    
    dataView(memory0).setUint32(arg1 + 4, len3, true);
    dataView(memory0).setUint32(arg1 + 0, ptr3, true);
    _debugLog('[iface="wasi:io/error@0.2.3", function="[method]error.to-debug-string"][Instruction::Return]', {
      funcName: '[method]error.to-debug-string',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_37_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.skip',
    moduleIdx: null,
  };
  
  
  function trampoline51(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable15[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.skip"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.skip?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'skip',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.skip(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        dataView(memory0).setBigInt64(arg2 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory0).setInt8(arg2 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 12, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.skip"][Instruction::Return]', {
      funcName: '[method]input-stream.skip',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_38_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.blocking-skip',
    moduleIdx: null,
  };
  
  
  function trampoline52(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable15[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-skip"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingSkip?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'blockingSkip',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingSkip(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        dataView(memory0).setBigInt64(arg2 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory0).setInt8(arg2 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 12, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-skip"][Instruction::Return]', {
      funcName: '[method]input-stream.blocking-skip',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_39_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-write-and-flush',
    moduleIdx: null,
  };
  
  
  function trampoline53(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-and-flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingWriteAndFlush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'blockingWriteAndFlush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingWriteAndFlush(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg3 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg3 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg3 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-and-flush"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-write-and-flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_40_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.flush',
    moduleIdx: null,
  };
  
  
  function trampoline54(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.flush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'flush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.flush()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory0).setInt8(arg1 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg1 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg1 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.flush"][Instruction::Return]', {
      funcName: '[method]output-stream.flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_41_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.write-zeroes',
    moduleIdx: null,
  };
  
  
  function trampoline55(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write-zeroes"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.writeZeroes?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'writeZeroes',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.writeZeroes(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory0).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write-zeroes"][Instruction::Return]', {
      funcName: '[method]output-stream.write-zeroes',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_42_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-write-zeroes-and-flush',
    moduleIdx: null,
  };
  
  
  function trampoline56(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-zeroes-and-flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingWriteZeroesAndFlush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'blockingWriteZeroesAndFlush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingWriteZeroesAndFlush(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory0).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-zeroes-and-flush"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-write-zeroes-and-flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_43_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.splice',
    moduleIdx: null,
  };
  
  
  function trampoline57(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable15[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable2.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.splice"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.splice?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'splice',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.splice(rsc3, BigInt.asUintN(64, arg2))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        dataView(memory0).setBigInt64(arg3 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'last-operation-failed': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg3 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle6 = e[symbolRscHandle];
            if (!handle6) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle6 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg3 + 12, handle6, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg3 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.splice"][Instruction::Return]', {
      funcName: '[method]output-stream.splice',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_44_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-splice',
    moduleIdx: null,
  };
  
  
  function trampoline58(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable15[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable2.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-splice"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingSplice?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'blockingSplice',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingSplice(rsc3, BigInt.asUintN(64, arg2))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        dataView(memory0).setBigInt64(arg3 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'last-operation-failed': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg3 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle6 = e[symbolRscHandle];
            if (!handle6) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle6 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg3 + 12, handle6, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg3 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-splice"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-splice',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_45_metadata = {
    qualifiedImportFn: 'wasi:cli/terminal-stdin@0.2.3#get-terminal-stdin',
    moduleIdx: null,
  };
  
  const handleTable26 = [T_FLAG, 0];
  const captureTable4= new Map();
  let captureCnt4 = 0;
  handleTables[26] = handleTable26;
  
  function trampoline59(arg0) {
    _debugLog('[iface="wasi:cli/terminal-stdin@0.2.3", function="get-terminal-stdin"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getTerminalStdin?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getTerminalStdin',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getTerminalStdin();
    endCurrentTask(1);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory0).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory0).setInt8(arg0 + 0, 1, true);
      if (!(e instanceof TerminalInput)) {
        throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');
      }
      var handle0 = e[symbolRscHandle];
      if (!handle0) {
        const rep = e[symbolRscRep] || ++captureCnt4;
        captureTable4.set(rep, e);
        handle0 = rscTableCreateOwn(handleTable26, rep);
      }
      dataView(memory0).setInt32(arg0 + 4, handle0, true);
    }
    _debugLog('[iface="wasi:cli/terminal-stdin@0.2.3", function="get-terminal-stdin"][Instruction::Return]', {
      funcName: 'get-terminal-stdin',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_46_metadata = {
    qualifiedImportFn: 'wasi:cli/terminal-stdout@0.2.3#get-terminal-stdout',
    moduleIdx: null,
  };
  
  const handleTable27 = [T_FLAG, 0];
  const captureTable5= new Map();
  let captureCnt5 = 0;
  handleTables[27] = handleTable27;
  
  function trampoline60(arg0) {
    _debugLog('[iface="wasi:cli/terminal-stdout@0.2.3", function="get-terminal-stdout"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getTerminalStdout?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getTerminalStdout',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getTerminalStdout();
    endCurrentTask(1);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory0).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory0).setInt8(arg0 + 0, 1, true);
      if (!(e instanceof TerminalOutput)) {
        throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');
      }
      var handle0 = e[symbolRscHandle];
      if (!handle0) {
        const rep = e[symbolRscRep] || ++captureCnt5;
        captureTable5.set(rep, e);
        handle0 = rscTableCreateOwn(handleTable27, rep);
      }
      dataView(memory0).setInt32(arg0 + 4, handle0, true);
    }
    _debugLog('[iface="wasi:cli/terminal-stdout@0.2.3", function="get-terminal-stdout"][Instruction::Return]', {
      funcName: 'get-terminal-stdout',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_47_metadata = {
    qualifiedImportFn: 'wasi:cli/terminal-stderr@0.2.3#get-terminal-stderr',
    moduleIdx: null,
  };
  
  
  function trampoline61(arg0) {
    _debugLog('[iface="wasi:cli/terminal-stderr@0.2.3", function="get-terminal-stderr"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getTerminalStderr?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getTerminalStderr',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getTerminalStderr();
    endCurrentTask(1);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory0).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory0).setInt8(arg0 + 0, 1, true);
      if (!(e instanceof TerminalOutput)) {
        throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');
      }
      var handle0 = e[symbolRscHandle];
      if (!handle0) {
        const rep = e[symbolRscRep] || ++captureCnt5;
        captureTable5.set(rep, e);
        handle0 = rscTableCreateOwn(handleTable27, rep);
      }
      dataView(memory0).setInt32(arg0 + 4, handle0, true);
    }
    _debugLog('[iface="wasi:cli/terminal-stderr@0.2.3", function="get-terminal-stderr"][Instruction::Return]', {
      funcName: 'get-terminal-stderr',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_48_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#filesystem-error-code',
    moduleIdx: null,
  };
  
  
  function trampoline62(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable19[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable0.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Error$1.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="filesystem-error-code"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = filesystemErrorCode?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'filesystemErrorCode',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  filesystemErrorCode(rsc0);
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    if (variant4 === null || variant4=== undefined) {
      dataView(memory0).setInt8(arg1 + 0, 0, true);
    } else {
      const e = variant4;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'access': {
          enum3 = 0;
          break;
        }
        case 'would-block': {
          enum3 = 1;
          break;
        }
        case 'already': {
          enum3 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum3 = 3;
          break;
        }
        case 'busy': {
          enum3 = 4;
          break;
        }
        case 'deadlock': {
          enum3 = 5;
          break;
        }
        case 'quota': {
          enum3 = 6;
          break;
        }
        case 'exist': {
          enum3 = 7;
          break;
        }
        case 'file-too-large': {
          enum3 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum3 = 9;
          break;
        }
        case 'in-progress': {
          enum3 = 10;
          break;
        }
        case 'interrupted': {
          enum3 = 11;
          break;
        }
        case 'invalid': {
          enum3 = 12;
          break;
        }
        case 'io': {
          enum3 = 13;
          break;
        }
        case 'is-directory': {
          enum3 = 14;
          break;
        }
        case 'loop': {
          enum3 = 15;
          break;
        }
        case 'too-many-links': {
          enum3 = 16;
          break;
        }
        case 'message-size': {
          enum3 = 17;
          break;
        }
        case 'name-too-long': {
          enum3 = 18;
          break;
        }
        case 'no-device': {
          enum3 = 19;
          break;
        }
        case 'no-entry': {
          enum3 = 20;
          break;
        }
        case 'no-lock': {
          enum3 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum3 = 22;
          break;
        }
        case 'insufficient-space': {
          enum3 = 23;
          break;
        }
        case 'not-directory': {
          enum3 = 24;
          break;
        }
        case 'not-empty': {
          enum3 = 25;
          break;
        }
        case 'not-recoverable': {
          enum3 = 26;
          break;
        }
        case 'unsupported': {
          enum3 = 27;
          break;
        }
        case 'no-tty': {
          enum3 = 28;
          break;
        }
        case 'no-such-device': {
          enum3 = 29;
          break;
        }
        case 'overflow': {
          enum3 = 30;
          break;
        }
        case 'not-permitted': {
          enum3 = 31;
          break;
        }
        case 'pipe': {
          enum3 = 32;
          break;
        }
        case 'read-only': {
          enum3 = 33;
          break;
        }
        case 'invalid-seek': {
          enum3 = 34;
          break;
        }
        case 'text-file-busy': {
          enum3 = 35;
          break;
        }
        case 'cross-device': {
          enum3 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="filesystem-error-code"][Instruction::Return]', {
      funcName: 'filesystem-error-code',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_49_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.read-via-stream',
    moduleIdx: null,
  };
  
  
  function trampoline63(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readViaStream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'readViaStream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readViaStream(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        if (!(e instanceof InputStream)) {
          throw new TypeError('Resource error: Not a valid "InputStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt2;
          captureTable2.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable15, rep);
        }
        dataView(memory0).setInt32(arg2 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-via-stream"][Instruction::Return]', {
      funcName: '[method]descriptor.read-via-stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_50_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.write-via-stream',
    moduleIdx: null,
  };
  
  
  function trampoline64(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.writeViaStream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'writeViaStream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.writeViaStream(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        if (!(e instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable16, rep);
        }
        dataView(memory0).setInt32(arg2 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write-via-stream"][Instruction::Return]', {
      funcName: '[method]descriptor.write-via-stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_51_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.append-via-stream',
    moduleIdx: null,
  };
  
  
  function trampoline65(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.append-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.appendViaStream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'appendViaStream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.appendViaStream()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable16, rep);
        }
        dataView(memory0).setInt32(arg1 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.append-via-stream"][Instruction::Return]', {
      funcName: '[method]descriptor.append-via-stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_52_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.advise',
    moduleIdx: null,
  };
  
  
  function trampoline66(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let enum3;
    switch (arg3) {
      case 0: {
        enum3 = 'normal';
        break;
      }
      case 1: {
        enum3 = 'sequential';
        break;
      }
      case 2: {
        enum3 = 'random';
        break;
      }
      case 3: {
        enum3 = 'will-need';
        break;
      }
      case 4: {
        enum3 = 'dont-need';
        break;
      }
      case 5: {
        enum3 = 'no-reuse';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for Advice');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.advise"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.advise?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'advise',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.advise(BigInt.asUintN(64, arg1), BigInt.asUintN(64, arg2), enum3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg4 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg4 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg4 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.advise"][Instruction::Return]', {
      funcName: '[method]descriptor.advise',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_53_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.sync-data',
    moduleIdx: null,
  };
  
  
  function trampoline67(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync-data"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.syncData?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'syncData',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.syncData()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'access': {
            enum3 = 0;
            break;
          }
          case 'would-block': {
            enum3 = 1;
            break;
          }
          case 'already': {
            enum3 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum3 = 3;
            break;
          }
          case 'busy': {
            enum3 = 4;
            break;
          }
          case 'deadlock': {
            enum3 = 5;
            break;
          }
          case 'quota': {
            enum3 = 6;
            break;
          }
          case 'exist': {
            enum3 = 7;
            break;
          }
          case 'file-too-large': {
            enum3 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum3 = 9;
            break;
          }
          case 'in-progress': {
            enum3 = 10;
            break;
          }
          case 'interrupted': {
            enum3 = 11;
            break;
          }
          case 'invalid': {
            enum3 = 12;
            break;
          }
          case 'io': {
            enum3 = 13;
            break;
          }
          case 'is-directory': {
            enum3 = 14;
            break;
          }
          case 'loop': {
            enum3 = 15;
            break;
          }
          case 'too-many-links': {
            enum3 = 16;
            break;
          }
          case 'message-size': {
            enum3 = 17;
            break;
          }
          case 'name-too-long': {
            enum3 = 18;
            break;
          }
          case 'no-device': {
            enum3 = 19;
            break;
          }
          case 'no-entry': {
            enum3 = 20;
            break;
          }
          case 'no-lock': {
            enum3 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum3 = 22;
            break;
          }
          case 'insufficient-space': {
            enum3 = 23;
            break;
          }
          case 'not-directory': {
            enum3 = 24;
            break;
          }
          case 'not-empty': {
            enum3 = 25;
            break;
          }
          case 'not-recoverable': {
            enum3 = 26;
            break;
          }
          case 'unsupported': {
            enum3 = 27;
            break;
          }
          case 'no-tty': {
            enum3 = 28;
            break;
          }
          case 'no-such-device': {
            enum3 = 29;
            break;
          }
          case 'overflow': {
            enum3 = 30;
            break;
          }
          case 'not-permitted': {
            enum3 = 31;
            break;
          }
          case 'pipe': {
            enum3 = 32;
            break;
          }
          case 'read-only': {
            enum3 = 33;
            break;
          }
          case 'invalid-seek': {
            enum3 = 34;
            break;
          }
          case 'text-file-busy': {
            enum3 = 35;
            break;
          }
          case 'cross-device': {
            enum3 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync-data"][Instruction::Return]', {
      funcName: '[method]descriptor.sync-data',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_54_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.get-flags',
    moduleIdx: null,
  };
  
  
  function trampoline68(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-flags"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.getFlags?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getFlags',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.getFlags()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        let flags3 = 0;
        if (typeof e === 'object' && e !== null) {
          flags3 = Boolean(e.read) << 0 | Boolean(e.write) << 1 | Boolean(e.fileIntegritySync) << 2 | Boolean(e.dataIntegritySync) << 3 | Boolean(e.requestedWriteSync) << 4 | Boolean(e.mutateDirectory) << 5;
        } else if (e !== null && e!== undefined) {
          throw new TypeError('only an object, undefined or null can be converted to flags');
        }
        dataView(memory0).setInt8(arg1 + 1, flags3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-flags"][Instruction::Return]', {
      funcName: '[method]descriptor.get-flags',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_55_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.get-type',
    moduleIdx: null,
  };
  
  
  function trampoline69(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-type"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.getType?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getType',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.getType()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'block-device': {
            enum3 = 1;
            break;
          }
          case 'character-device': {
            enum3 = 2;
            break;
          }
          case 'directory': {
            enum3 = 3;
            break;
          }
          case 'fifo': {
            enum3 = 4;
            break;
          }
          case 'symbolic-link': {
            enum3 = 5;
            break;
          }
          case 'regular-file': {
            enum3 = 6;
            break;
          }
          case 'socket': {
            enum3 = 7;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-type"][Instruction::Return]', {
      funcName: '[method]descriptor.get-type',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_56_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.set-size',
    moduleIdx: null,
  };
  
  
  function trampoline70(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'access': {
            enum3 = 0;
            break;
          }
          case 'would-block': {
            enum3 = 1;
            break;
          }
          case 'already': {
            enum3 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum3 = 3;
            break;
          }
          case 'busy': {
            enum3 = 4;
            break;
          }
          case 'deadlock': {
            enum3 = 5;
            break;
          }
          case 'quota': {
            enum3 = 6;
            break;
          }
          case 'exist': {
            enum3 = 7;
            break;
          }
          case 'file-too-large': {
            enum3 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum3 = 9;
            break;
          }
          case 'in-progress': {
            enum3 = 10;
            break;
          }
          case 'interrupted': {
            enum3 = 11;
            break;
          }
          case 'invalid': {
            enum3 = 12;
            break;
          }
          case 'io': {
            enum3 = 13;
            break;
          }
          case 'is-directory': {
            enum3 = 14;
            break;
          }
          case 'loop': {
            enum3 = 15;
            break;
          }
          case 'too-many-links': {
            enum3 = 16;
            break;
          }
          case 'message-size': {
            enum3 = 17;
            break;
          }
          case 'name-too-long': {
            enum3 = 18;
            break;
          }
          case 'no-device': {
            enum3 = 19;
            break;
          }
          case 'no-entry': {
            enum3 = 20;
            break;
          }
          case 'no-lock': {
            enum3 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum3 = 22;
            break;
          }
          case 'insufficient-space': {
            enum3 = 23;
            break;
          }
          case 'not-directory': {
            enum3 = 24;
            break;
          }
          case 'not-empty': {
            enum3 = 25;
            break;
          }
          case 'not-recoverable': {
            enum3 = 26;
            break;
          }
          case 'unsupported': {
            enum3 = 27;
            break;
          }
          case 'no-tty': {
            enum3 = 28;
            break;
          }
          case 'no-such-device': {
            enum3 = 29;
            break;
          }
          case 'overflow': {
            enum3 = 30;
            break;
          }
          case 'not-permitted': {
            enum3 = 31;
            break;
          }
          case 'pipe': {
            enum3 = 32;
            break;
          }
          case 'read-only': {
            enum3 = 33;
            break;
          }
          case 'invalid-seek': {
            enum3 = 34;
            break;
          }
          case 'text-file-busy': {
            enum3 = 35;
            break;
          }
          case 'cross-device': {
            enum3 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-size"][Instruction::Return]', {
      funcName: '[method]descriptor.set-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_57_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.set-times',
    moduleIdx: null,
  };
  
  
  function trampoline71(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let variant3;
    switch (arg1) {
      case 0: {
        variant3= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant3= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant3= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg2),
            nanoseconds: arg3 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    let variant4;
    switch (arg4) {
      case 0: {
        variant4= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant4= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant4= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg5),
            nanoseconds: arg6 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setTimes?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setTimes',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setTimes(variant3, variant4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg7 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg7 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg7 + 1, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times"][Instruction::Return]', {
      funcName: '[method]descriptor.set-times',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_58_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.read',
    moduleIdx: null,
  };
  
  
  function trampoline72(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.read?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'read',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1), BigInt.asUintN(64, arg2))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        var [tuple3_0, tuple3_1] = e;
        var val4 = tuple3_0;
        var len4 = val4.byteLength;
        var ptr4 = realloc0(0, 0, 1, len4 * 1);
        
        let valData4;
        const valLenBytes4 = len4 * 1;
        if (Array.isArray(val4)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv4 = new DataView(memory0.buffer);
          for (const v of val4) {
            dv4.setUint8(ptr4+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, valLenBytes4);
          const out4 = new Uint8Array(memory0.buffer, ptr4,valLenBytes4);
          out4.set(valData4);
        }
        
        dataView(memory0).setUint32(arg3 + 8, len4, true);
        dataView(memory0).setUint32(arg3 + 4, ptr4, true);
        dataView(memory0).setInt8(arg3 + 12, tuple3_1 ? 1 : 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg3 + 4, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read"][Instruction::Return]', {
      funcName: '[method]descriptor.read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_59_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.write',
    moduleIdx: null,
  };
  
  
  function trampoline73(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.write?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'write',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.write(result3, BigInt.asUintN(64, arg3))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg4 + 0, 0, true);
        dataView(memory0).setBigInt64(arg4 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg4 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg4 + 8, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write"][Instruction::Return]', {
      funcName: '[method]descriptor.write',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_60_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.read-directory',
    moduleIdx: null,
  };
  
  const handleTable21 = [T_FLAG, 0];
  const captureTable7= new Map();
  let captureCnt7 = 0;
  handleTables[21] = handleTable21;
  
  function trampoline74(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-directory"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readDirectory?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'readDirectory',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readDirectory()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof DirectoryEntryStream)) {
          throw new TypeError('Resource error: Not a valid "DirectoryEntryStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt7;
          captureTable7.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable21, rep);
        }
        dataView(memory0).setInt32(arg1 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-directory"][Instruction::Return]', {
      funcName: '[method]descriptor.read-directory',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_61_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.sync',
    moduleIdx: null,
  };
  
  
  function trampoline75(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.sync?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'sync',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.sync()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'access': {
            enum3 = 0;
            break;
          }
          case 'would-block': {
            enum3 = 1;
            break;
          }
          case 'already': {
            enum3 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum3 = 3;
            break;
          }
          case 'busy': {
            enum3 = 4;
            break;
          }
          case 'deadlock': {
            enum3 = 5;
            break;
          }
          case 'quota': {
            enum3 = 6;
            break;
          }
          case 'exist': {
            enum3 = 7;
            break;
          }
          case 'file-too-large': {
            enum3 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum3 = 9;
            break;
          }
          case 'in-progress': {
            enum3 = 10;
            break;
          }
          case 'interrupted': {
            enum3 = 11;
            break;
          }
          case 'invalid': {
            enum3 = 12;
            break;
          }
          case 'io': {
            enum3 = 13;
            break;
          }
          case 'is-directory': {
            enum3 = 14;
            break;
          }
          case 'loop': {
            enum3 = 15;
            break;
          }
          case 'too-many-links': {
            enum3 = 16;
            break;
          }
          case 'message-size': {
            enum3 = 17;
            break;
          }
          case 'name-too-long': {
            enum3 = 18;
            break;
          }
          case 'no-device': {
            enum3 = 19;
            break;
          }
          case 'no-entry': {
            enum3 = 20;
            break;
          }
          case 'no-lock': {
            enum3 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum3 = 22;
            break;
          }
          case 'insufficient-space': {
            enum3 = 23;
            break;
          }
          case 'not-directory': {
            enum3 = 24;
            break;
          }
          case 'not-empty': {
            enum3 = 25;
            break;
          }
          case 'not-recoverable': {
            enum3 = 26;
            break;
          }
          case 'unsupported': {
            enum3 = 27;
            break;
          }
          case 'no-tty': {
            enum3 = 28;
            break;
          }
          case 'no-such-device': {
            enum3 = 29;
            break;
          }
          case 'overflow': {
            enum3 = 30;
            break;
          }
          case 'not-permitted': {
            enum3 = 31;
            break;
          }
          case 'pipe': {
            enum3 = 32;
            break;
          }
          case 'read-only': {
            enum3 = 33;
            break;
          }
          case 'invalid-seek': {
            enum3 = 34;
            break;
          }
          case 'text-file-busy': {
            enum3 = 35;
            break;
          }
          case 'cross-device': {
            enum3 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync"][Instruction::Return]', {
      funcName: '[method]descriptor.sync',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_62_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.create-directory-at',
    moduleIdx: null,
  };
  
  
  function trampoline76(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.create-directory-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.createDirectoryAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'createDirectoryAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.createDirectoryAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg3 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.create-directory-at"][Instruction::Return]', {
      funcName: '[method]descriptor.create-directory-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_63_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.stat',
    moduleIdx: null,
  };
  
  
  function trampoline77(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.stat?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'stat',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.stat()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant12 = ret;
    switch (variant12.tag) {
      case 'ok': {
        const e = variant12.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var {type: v3_0, linkCount: v3_1, size: v3_2, dataAccessTimestamp: v3_3, dataModificationTimestamp: v3_4, statusChangeTimestamp: v3_5 } = e;
        var val4 = v3_0;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'block-device': {
            enum4 = 1;
            break;
          }
          case 'character-device': {
            enum4 = 2;
            break;
          }
          case 'directory': {
            enum4 = 3;
            break;
          }
          case 'fifo': {
            enum4 = 4;
            break;
          }
          case 'symbolic-link': {
            enum4 = 5;
            break;
          }
          case 'regular-file': {
            enum4 = 6;
            break;
          }
          case 'socket': {
            enum4 = 7;
            break;
          }
          default: {
            if ((v3_0) instanceof Error) {
              console.error(v3_0);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum4, true);
        dataView(memory0).setBigInt64(arg1 + 16, toUint64(v3_1), true);
        dataView(memory0).setBigInt64(arg1 + 24, toUint64(v3_2), true);
        var variant6 = v3_3;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory0).setInt8(arg1 + 32, 0, true);
        } else {
          const e = variant6;
          dataView(memory0).setInt8(arg1 + 32, 1, true);
          var {seconds: v5_0, nanoseconds: v5_1 } = e;
          dataView(memory0).setBigInt64(arg1 + 40, toUint64(v5_0), true);
          dataView(memory0).setInt32(arg1 + 48, toUint32(v5_1), true);
        }
        var variant8 = v3_4;
        if (variant8 === null || variant8=== undefined) {
          dataView(memory0).setInt8(arg1 + 56, 0, true);
        } else {
          const e = variant8;
          dataView(memory0).setInt8(arg1 + 56, 1, true);
          var {seconds: v7_0, nanoseconds: v7_1 } = e;
          dataView(memory0).setBigInt64(arg1 + 64, toUint64(v7_0), true);
          dataView(memory0).setInt32(arg1 + 72, toUint32(v7_1), true);
        }
        var variant10 = v3_5;
        if (variant10 === null || variant10=== undefined) {
          dataView(memory0).setInt8(arg1 + 80, 0, true);
        } else {
          const e = variant10;
          dataView(memory0).setInt8(arg1 + 80, 1, true);
          var {seconds: v9_0, nanoseconds: v9_1 } = e;
          dataView(memory0).setBigInt64(arg1 + 88, toUint64(v9_0), true);
          dataView(memory0).setInt32(arg1 + 96, toUint32(v9_1), true);
        }
        break;
      }
      case 'err': {
        const e = variant12.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val11 = e;
        let enum11;
        switch (val11) {
          case 'access': {
            enum11 = 0;
            break;
          }
          case 'would-block': {
            enum11 = 1;
            break;
          }
          case 'already': {
            enum11 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum11 = 3;
            break;
          }
          case 'busy': {
            enum11 = 4;
            break;
          }
          case 'deadlock': {
            enum11 = 5;
            break;
          }
          case 'quota': {
            enum11 = 6;
            break;
          }
          case 'exist': {
            enum11 = 7;
            break;
          }
          case 'file-too-large': {
            enum11 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum11 = 9;
            break;
          }
          case 'in-progress': {
            enum11 = 10;
            break;
          }
          case 'interrupted': {
            enum11 = 11;
            break;
          }
          case 'invalid': {
            enum11 = 12;
            break;
          }
          case 'io': {
            enum11 = 13;
            break;
          }
          case 'is-directory': {
            enum11 = 14;
            break;
          }
          case 'loop': {
            enum11 = 15;
            break;
          }
          case 'too-many-links': {
            enum11 = 16;
            break;
          }
          case 'message-size': {
            enum11 = 17;
            break;
          }
          case 'name-too-long': {
            enum11 = 18;
            break;
          }
          case 'no-device': {
            enum11 = 19;
            break;
          }
          case 'no-entry': {
            enum11 = 20;
            break;
          }
          case 'no-lock': {
            enum11 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum11 = 22;
            break;
          }
          case 'insufficient-space': {
            enum11 = 23;
            break;
          }
          case 'not-directory': {
            enum11 = 24;
            break;
          }
          case 'not-empty': {
            enum11 = 25;
            break;
          }
          case 'not-recoverable': {
            enum11 = 26;
            break;
          }
          case 'unsupported': {
            enum11 = 27;
            break;
          }
          case 'no-tty': {
            enum11 = 28;
            break;
          }
          case 'no-such-device': {
            enum11 = 29;
            break;
          }
          case 'overflow': {
            enum11 = 30;
            break;
          }
          case 'not-permitted': {
            enum11 = 31;
            break;
          }
          case 'pipe': {
            enum11 = 32;
            break;
          }
          case 'read-only': {
            enum11 = 33;
            break;
          }
          case 'invalid-seek': {
            enum11 = 34;
            break;
          }
          case 'text-file-busy': {
            enum11 = 35;
            break;
          }
          case 'cross-device': {
            enum11 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val11}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum11, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat"][Instruction::Return]', {
      funcName: '[method]descriptor.stat',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_64_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.stat-at',
    moduleIdx: null,
  };
  
  
  function trampoline78(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.statAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'statAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.statAt(flags3, result4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant14 = ret;
    switch (variant14.tag) {
      case 'ok': {
        const e = variant14.val;
        dataView(memory0).setInt8(arg4 + 0, 0, true);
        var {type: v5_0, linkCount: v5_1, size: v5_2, dataAccessTimestamp: v5_3, dataModificationTimestamp: v5_4, statusChangeTimestamp: v5_5 } = e;
        var val6 = v5_0;
        let enum6;
        switch (val6) {
          case 'unknown': {
            enum6 = 0;
            break;
          }
          case 'block-device': {
            enum6 = 1;
            break;
          }
          case 'character-device': {
            enum6 = 2;
            break;
          }
          case 'directory': {
            enum6 = 3;
            break;
          }
          case 'fifo': {
            enum6 = 4;
            break;
          }
          case 'symbolic-link': {
            enum6 = 5;
            break;
          }
          case 'regular-file': {
            enum6 = 6;
            break;
          }
          case 'socket': {
            enum6 = 7;
            break;
          }
          default: {
            if ((v5_0) instanceof Error) {
              console.error(v5_0);
            }
            
            throw new TypeError(`"${val6}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory0).setInt8(arg4 + 8, enum6, true);
        dataView(memory0).setBigInt64(arg4 + 16, toUint64(v5_1), true);
        dataView(memory0).setBigInt64(arg4 + 24, toUint64(v5_2), true);
        var variant8 = v5_3;
        if (variant8 === null || variant8=== undefined) {
          dataView(memory0).setInt8(arg4 + 32, 0, true);
        } else {
          const e = variant8;
          dataView(memory0).setInt8(arg4 + 32, 1, true);
          var {seconds: v7_0, nanoseconds: v7_1 } = e;
          dataView(memory0).setBigInt64(arg4 + 40, toUint64(v7_0), true);
          dataView(memory0).setInt32(arg4 + 48, toUint32(v7_1), true);
        }
        var variant10 = v5_4;
        if (variant10 === null || variant10=== undefined) {
          dataView(memory0).setInt8(arg4 + 56, 0, true);
        } else {
          const e = variant10;
          dataView(memory0).setInt8(arg4 + 56, 1, true);
          var {seconds: v9_0, nanoseconds: v9_1 } = e;
          dataView(memory0).setBigInt64(arg4 + 64, toUint64(v9_0), true);
          dataView(memory0).setInt32(arg4 + 72, toUint32(v9_1), true);
        }
        var variant12 = v5_5;
        if (variant12 === null || variant12=== undefined) {
          dataView(memory0).setInt8(arg4 + 80, 0, true);
        } else {
          const e = variant12;
          dataView(memory0).setInt8(arg4 + 80, 1, true);
          var {seconds: v11_0, nanoseconds: v11_1 } = e;
          dataView(memory0).setBigInt64(arg4 + 88, toUint64(v11_0), true);
          dataView(memory0).setInt32(arg4 + 96, toUint32(v11_1), true);
        }
        break;
      }
      case 'err': {
        const e = variant14.val;
        dataView(memory0).setInt8(arg4 + 0, 1, true);
        var val13 = e;
        let enum13;
        switch (val13) {
          case 'access': {
            enum13 = 0;
            break;
          }
          case 'would-block': {
            enum13 = 1;
            break;
          }
          case 'already': {
            enum13 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum13 = 3;
            break;
          }
          case 'busy': {
            enum13 = 4;
            break;
          }
          case 'deadlock': {
            enum13 = 5;
            break;
          }
          case 'quota': {
            enum13 = 6;
            break;
          }
          case 'exist': {
            enum13 = 7;
            break;
          }
          case 'file-too-large': {
            enum13 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum13 = 9;
            break;
          }
          case 'in-progress': {
            enum13 = 10;
            break;
          }
          case 'interrupted': {
            enum13 = 11;
            break;
          }
          case 'invalid': {
            enum13 = 12;
            break;
          }
          case 'io': {
            enum13 = 13;
            break;
          }
          case 'is-directory': {
            enum13 = 14;
            break;
          }
          case 'loop': {
            enum13 = 15;
            break;
          }
          case 'too-many-links': {
            enum13 = 16;
            break;
          }
          case 'message-size': {
            enum13 = 17;
            break;
          }
          case 'name-too-long': {
            enum13 = 18;
            break;
          }
          case 'no-device': {
            enum13 = 19;
            break;
          }
          case 'no-entry': {
            enum13 = 20;
            break;
          }
          case 'no-lock': {
            enum13 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum13 = 22;
            break;
          }
          case 'insufficient-space': {
            enum13 = 23;
            break;
          }
          case 'not-directory': {
            enum13 = 24;
            break;
          }
          case 'not-empty': {
            enum13 = 25;
            break;
          }
          case 'not-recoverable': {
            enum13 = 26;
            break;
          }
          case 'unsupported': {
            enum13 = 27;
            break;
          }
          case 'no-tty': {
            enum13 = 28;
            break;
          }
          case 'no-such-device': {
            enum13 = 29;
            break;
          }
          case 'overflow': {
            enum13 = 30;
            break;
          }
          case 'not-permitted': {
            enum13 = 31;
            break;
          }
          case 'pipe': {
            enum13 = 32;
            break;
          }
          case 'read-only': {
            enum13 = 33;
            break;
          }
          case 'invalid-seek': {
            enum13 = 34;
            break;
          }
          case 'text-file-busy': {
            enum13 = 35;
            break;
          }
          case 'cross-device': {
            enum13 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val13}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg4 + 8, enum13, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat-at"][Instruction::Return]', {
      funcName: '[method]descriptor.stat-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_65_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.set-times-at',
    moduleIdx: null,
  };
  
  
  function trampoline79(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
    let variant5;
    switch (arg4) {
      case 0: {
        variant5= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant5= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant5= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg5),
            nanoseconds: arg6 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    let variant6;
    switch (arg7) {
      case 0: {
        variant6= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant6= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg8),
            nanoseconds: arg9 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setTimesAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setTimesAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setTimesAt(flags3, result4, variant5, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg10 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg10 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'access': {
            enum7 = 0;
            break;
          }
          case 'would-block': {
            enum7 = 1;
            break;
          }
          case 'already': {
            enum7 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum7 = 3;
            break;
          }
          case 'busy': {
            enum7 = 4;
            break;
          }
          case 'deadlock': {
            enum7 = 5;
            break;
          }
          case 'quota': {
            enum7 = 6;
            break;
          }
          case 'exist': {
            enum7 = 7;
            break;
          }
          case 'file-too-large': {
            enum7 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum7 = 9;
            break;
          }
          case 'in-progress': {
            enum7 = 10;
            break;
          }
          case 'interrupted': {
            enum7 = 11;
            break;
          }
          case 'invalid': {
            enum7 = 12;
            break;
          }
          case 'io': {
            enum7 = 13;
            break;
          }
          case 'is-directory': {
            enum7 = 14;
            break;
          }
          case 'loop': {
            enum7 = 15;
            break;
          }
          case 'too-many-links': {
            enum7 = 16;
            break;
          }
          case 'message-size': {
            enum7 = 17;
            break;
          }
          case 'name-too-long': {
            enum7 = 18;
            break;
          }
          case 'no-device': {
            enum7 = 19;
            break;
          }
          case 'no-entry': {
            enum7 = 20;
            break;
          }
          case 'no-lock': {
            enum7 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum7 = 22;
            break;
          }
          case 'insufficient-space': {
            enum7 = 23;
            break;
          }
          case 'not-directory': {
            enum7 = 24;
            break;
          }
          case 'not-empty': {
            enum7 = 25;
            break;
          }
          case 'not-recoverable': {
            enum7 = 26;
            break;
          }
          case 'unsupported': {
            enum7 = 27;
            break;
          }
          case 'no-tty': {
            enum7 = 28;
            break;
          }
          case 'no-such-device': {
            enum7 = 29;
            break;
          }
          case 'overflow': {
            enum7 = 30;
            break;
          }
          case 'not-permitted': {
            enum7 = 31;
            break;
          }
          case 'pipe': {
            enum7 = 32;
            break;
          }
          case 'read-only': {
            enum7 = 33;
            break;
          }
          case 'invalid-seek': {
            enum7 = 34;
            break;
          }
          case 'text-file-busy': {
            enum7 = 35;
            break;
          }
          case 'cross-device': {
            enum7 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg10 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times-at"][Instruction::Return]', {
      funcName: '[method]descriptor.set-times-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_66_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.link-at',
    moduleIdx: null,
  };
  
  
  function trampoline80(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
    var handle6 = arg4;
    var rep7 = handleTable20[(handle6 << 1) + 1] & ~T_FLAG;
    var rsc5 = captureTable6.get(rep7);
    if (!rsc5) {
      rsc5 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc5, symbolRscHandle, { writable: true, value: handle6});
      Object.defineProperty(rsc5, symbolRscRep, { writable: true, value: rep7});
    }
    curResourceBorrows.push(rsc5);
    var ptr8 = arg5;
    var len8 = arg6;
    var result8 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr8, len8));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.link-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.linkAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'linkAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.linkAt(flags3, result4, rsc5, result8)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant10 = ret;
    switch (variant10.tag) {
      case 'ok': {
        const e = variant10.val;
        dataView(memory0).setInt8(arg7 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant10.val;
        dataView(memory0).setInt8(arg7 + 0, 1, true);
        var val9 = e;
        let enum9;
        switch (val9) {
          case 'access': {
            enum9 = 0;
            break;
          }
          case 'would-block': {
            enum9 = 1;
            break;
          }
          case 'already': {
            enum9 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum9 = 3;
            break;
          }
          case 'busy': {
            enum9 = 4;
            break;
          }
          case 'deadlock': {
            enum9 = 5;
            break;
          }
          case 'quota': {
            enum9 = 6;
            break;
          }
          case 'exist': {
            enum9 = 7;
            break;
          }
          case 'file-too-large': {
            enum9 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum9 = 9;
            break;
          }
          case 'in-progress': {
            enum9 = 10;
            break;
          }
          case 'interrupted': {
            enum9 = 11;
            break;
          }
          case 'invalid': {
            enum9 = 12;
            break;
          }
          case 'io': {
            enum9 = 13;
            break;
          }
          case 'is-directory': {
            enum9 = 14;
            break;
          }
          case 'loop': {
            enum9 = 15;
            break;
          }
          case 'too-many-links': {
            enum9 = 16;
            break;
          }
          case 'message-size': {
            enum9 = 17;
            break;
          }
          case 'name-too-long': {
            enum9 = 18;
            break;
          }
          case 'no-device': {
            enum9 = 19;
            break;
          }
          case 'no-entry': {
            enum9 = 20;
            break;
          }
          case 'no-lock': {
            enum9 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum9 = 22;
            break;
          }
          case 'insufficient-space': {
            enum9 = 23;
            break;
          }
          case 'not-directory': {
            enum9 = 24;
            break;
          }
          case 'not-empty': {
            enum9 = 25;
            break;
          }
          case 'not-recoverable': {
            enum9 = 26;
            break;
          }
          case 'unsupported': {
            enum9 = 27;
            break;
          }
          case 'no-tty': {
            enum9 = 28;
            break;
          }
          case 'no-such-device': {
            enum9 = 29;
            break;
          }
          case 'overflow': {
            enum9 = 30;
            break;
          }
          case 'not-permitted': {
            enum9 = 31;
            break;
          }
          case 'pipe': {
            enum9 = 32;
            break;
          }
          case 'read-only': {
            enum9 = 33;
            break;
          }
          case 'invalid-seek': {
            enum9 = 34;
            break;
          }
          case 'text-file-busy': {
            enum9 = 35;
            break;
          }
          case 'cross-device': {
            enum9 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val9}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg7 + 1, enum9, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.link-at"][Instruction::Return]', {
      funcName: '[method]descriptor.link-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_67_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.open-at',
    moduleIdx: null,
  };
  
  
  function trampoline81(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
    if ((arg4 & 4294967280) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags5 = {
      create: Boolean(arg4 & 1),
      directory: Boolean(arg4 & 2),
      exclusive: Boolean(arg4 & 4),
      truncate: Boolean(arg4 & 8),
    };
    if ((arg5 & 4294967232) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags6 = {
      read: Boolean(arg5 & 1),
      write: Boolean(arg5 & 2),
      fileIntegritySync: Boolean(arg5 & 4),
      dataIntegritySync: Boolean(arg5 & 8),
      requestedWriteSync: Boolean(arg5 & 16),
      mutateDirectory: Boolean(arg5 & 32),
    };
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.open-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.openAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'openAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.openAt(flags3, result4, flags5, flags6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg6 + 0, 0, true);
        if (!(e instanceof Descriptor)) {
          throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
        }
        var handle7 = e[symbolRscHandle];
        if (!handle7) {
          const rep = e[symbolRscRep] || ++captureCnt6;
          captureTable6.set(rep, e);
          handle7 = rscTableCreateOwn(handleTable20, rep);
        }
        dataView(memory0).setInt32(arg6 + 4, handle7, true);
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg6 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'access': {
            enum8 = 0;
            break;
          }
          case 'would-block': {
            enum8 = 1;
            break;
          }
          case 'already': {
            enum8 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum8 = 3;
            break;
          }
          case 'busy': {
            enum8 = 4;
            break;
          }
          case 'deadlock': {
            enum8 = 5;
            break;
          }
          case 'quota': {
            enum8 = 6;
            break;
          }
          case 'exist': {
            enum8 = 7;
            break;
          }
          case 'file-too-large': {
            enum8 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum8 = 9;
            break;
          }
          case 'in-progress': {
            enum8 = 10;
            break;
          }
          case 'interrupted': {
            enum8 = 11;
            break;
          }
          case 'invalid': {
            enum8 = 12;
            break;
          }
          case 'io': {
            enum8 = 13;
            break;
          }
          case 'is-directory': {
            enum8 = 14;
            break;
          }
          case 'loop': {
            enum8 = 15;
            break;
          }
          case 'too-many-links': {
            enum8 = 16;
            break;
          }
          case 'message-size': {
            enum8 = 17;
            break;
          }
          case 'name-too-long': {
            enum8 = 18;
            break;
          }
          case 'no-device': {
            enum8 = 19;
            break;
          }
          case 'no-entry': {
            enum8 = 20;
            break;
          }
          case 'no-lock': {
            enum8 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum8 = 22;
            break;
          }
          case 'insufficient-space': {
            enum8 = 23;
            break;
          }
          case 'not-directory': {
            enum8 = 24;
            break;
          }
          case 'not-empty': {
            enum8 = 25;
            break;
          }
          case 'not-recoverable': {
            enum8 = 26;
            break;
          }
          case 'unsupported': {
            enum8 = 27;
            break;
          }
          case 'no-tty': {
            enum8 = 28;
            break;
          }
          case 'no-such-device': {
            enum8 = 29;
            break;
          }
          case 'overflow': {
            enum8 = 30;
            break;
          }
          case 'not-permitted': {
            enum8 = 31;
            break;
          }
          case 'pipe': {
            enum8 = 32;
            break;
          }
          case 'read-only': {
            enum8 = 33;
            break;
          }
          case 'invalid-seek': {
            enum8 = 34;
            break;
          }
          case 'text-file-busy': {
            enum8 = 35;
            break;
          }
          case 'cross-device': {
            enum8 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg6 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.open-at"][Instruction::Return]', {
      funcName: '[method]descriptor.open-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_68_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.readlink-at',
    moduleIdx: null,
  };
  
  
  function trampoline82(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.readlink-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readlinkAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'readlinkAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readlinkAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        
        var encodeRes = _utf8AllocateAndEncode(e, realloc0, memory0);
        var ptr4= encodeRes.ptr;
        var len4 = encodeRes.len;
        
        dataView(memory0).setUint32(arg3 + 8, len4, true);
        dataView(memory0).setUint32(arg3 + 4, ptr4, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg3 + 4, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.readlink-at"][Instruction::Return]', {
      funcName: '[method]descriptor.readlink-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_69_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.remove-directory-at',
    moduleIdx: null,
  };
  
  
  function trampoline83(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.remove-directory-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.removeDirectoryAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'removeDirectoryAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.removeDirectoryAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg3 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.remove-directory-at"][Instruction::Return]', {
      funcName: '[method]descriptor.remove-directory-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_70_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.rename-at',
    moduleIdx: null,
  };
  
  
  function trampoline84(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    var handle5 = arg3;
    var rep6 = handleTable20[(handle5 << 1) + 1] & ~T_FLAG;
    var rsc4 = captureTable6.get(rep6);
    if (!rsc4) {
      rsc4 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
      Object.defineProperty(rsc4, symbolRscRep, { writable: true, value: rep6});
    }
    curResourceBorrows.push(rsc4);
    var ptr7 = arg4;
    var len7 = arg5;
    var result7 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr7, len7));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.rename-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.renameAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'renameAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.renameAt(result3, rsc4, result7)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg6 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg6 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'access': {
            enum8 = 0;
            break;
          }
          case 'would-block': {
            enum8 = 1;
            break;
          }
          case 'already': {
            enum8 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum8 = 3;
            break;
          }
          case 'busy': {
            enum8 = 4;
            break;
          }
          case 'deadlock': {
            enum8 = 5;
            break;
          }
          case 'quota': {
            enum8 = 6;
            break;
          }
          case 'exist': {
            enum8 = 7;
            break;
          }
          case 'file-too-large': {
            enum8 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum8 = 9;
            break;
          }
          case 'in-progress': {
            enum8 = 10;
            break;
          }
          case 'interrupted': {
            enum8 = 11;
            break;
          }
          case 'invalid': {
            enum8 = 12;
            break;
          }
          case 'io': {
            enum8 = 13;
            break;
          }
          case 'is-directory': {
            enum8 = 14;
            break;
          }
          case 'loop': {
            enum8 = 15;
            break;
          }
          case 'too-many-links': {
            enum8 = 16;
            break;
          }
          case 'message-size': {
            enum8 = 17;
            break;
          }
          case 'name-too-long': {
            enum8 = 18;
            break;
          }
          case 'no-device': {
            enum8 = 19;
            break;
          }
          case 'no-entry': {
            enum8 = 20;
            break;
          }
          case 'no-lock': {
            enum8 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum8 = 22;
            break;
          }
          case 'insufficient-space': {
            enum8 = 23;
            break;
          }
          case 'not-directory': {
            enum8 = 24;
            break;
          }
          case 'not-empty': {
            enum8 = 25;
            break;
          }
          case 'not-recoverable': {
            enum8 = 26;
            break;
          }
          case 'unsupported': {
            enum8 = 27;
            break;
          }
          case 'no-tty': {
            enum8 = 28;
            break;
          }
          case 'no-such-device': {
            enum8 = 29;
            break;
          }
          case 'overflow': {
            enum8 = 30;
            break;
          }
          case 'not-permitted': {
            enum8 = 31;
            break;
          }
          case 'pipe': {
            enum8 = 32;
            break;
          }
          case 'read-only': {
            enum8 = 33;
            break;
          }
          case 'invalid-seek': {
            enum8 = 34;
            break;
          }
          case 'text-file-busy': {
            enum8 = 35;
            break;
          }
          case 'cross-device': {
            enum8 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg6 + 1, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.rename-at"][Instruction::Return]', {
      funcName: '[method]descriptor.rename-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_71_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.symlink-at',
    moduleIdx: null,
  };
  
  
  function trampoline85(arg0, arg1, arg2, arg3, arg4, arg5) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    var ptr4 = arg3;
    var len4 = arg4;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.symlink-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.symlinkAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'symlinkAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.symlinkAt(result3, result4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg5 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg5 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg5 + 1, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.symlink-at"][Instruction::Return]', {
      funcName: '[method]descriptor.symlink-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_72_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.unlink-file-at',
    moduleIdx: null,
  };
  
  
  function trampoline86(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.unlink-file-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.unlinkFileAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'unlinkFileAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.unlinkFileAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg3 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.unlink-file-at"][Instruction::Return]', {
      funcName: '[method]descriptor.unlink-file-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_73_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.metadata-hash',
    moduleIdx: null,
  };
  
  
  function trampoline87(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.metadataHash?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'metadataHash',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.metadataHash()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var {lower: v3_0, upper: v3_1 } = e;
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(v3_0), true);
        dataView(memory0).setBigInt64(arg1 + 16, toUint64(v3_1), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash"][Instruction::Return]', {
      funcName: '[method]descriptor.metadata-hash',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_74_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.metadata-hash-at',
    moduleIdx: null,
  };
  
  
  function trampoline88(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.metadataHashAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'metadataHashAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.metadataHashAt(flags3, result4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant7 = ret;
    switch (variant7.tag) {
      case 'ok': {
        const e = variant7.val;
        dataView(memory0).setInt8(arg4 + 0, 0, true);
        var {lower: v5_0, upper: v5_1 } = e;
        dataView(memory0).setBigInt64(arg4 + 8, toUint64(v5_0), true);
        dataView(memory0).setBigInt64(arg4 + 16, toUint64(v5_1), true);
        break;
      }
      case 'err': {
        const e = variant7.val;
        dataView(memory0).setInt8(arg4 + 0, 1, true);
        var val6 = e;
        let enum6;
        switch (val6) {
          case 'access': {
            enum6 = 0;
            break;
          }
          case 'would-block': {
            enum6 = 1;
            break;
          }
          case 'already': {
            enum6 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum6 = 3;
            break;
          }
          case 'busy': {
            enum6 = 4;
            break;
          }
          case 'deadlock': {
            enum6 = 5;
            break;
          }
          case 'quota': {
            enum6 = 6;
            break;
          }
          case 'exist': {
            enum6 = 7;
            break;
          }
          case 'file-too-large': {
            enum6 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum6 = 9;
            break;
          }
          case 'in-progress': {
            enum6 = 10;
            break;
          }
          case 'interrupted': {
            enum6 = 11;
            break;
          }
          case 'invalid': {
            enum6 = 12;
            break;
          }
          case 'io': {
            enum6 = 13;
            break;
          }
          case 'is-directory': {
            enum6 = 14;
            break;
          }
          case 'loop': {
            enum6 = 15;
            break;
          }
          case 'too-many-links': {
            enum6 = 16;
            break;
          }
          case 'message-size': {
            enum6 = 17;
            break;
          }
          case 'name-too-long': {
            enum6 = 18;
            break;
          }
          case 'no-device': {
            enum6 = 19;
            break;
          }
          case 'no-entry': {
            enum6 = 20;
            break;
          }
          case 'no-lock': {
            enum6 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum6 = 22;
            break;
          }
          case 'insufficient-space': {
            enum6 = 23;
            break;
          }
          case 'not-directory': {
            enum6 = 24;
            break;
          }
          case 'not-empty': {
            enum6 = 25;
            break;
          }
          case 'not-recoverable': {
            enum6 = 26;
            break;
          }
          case 'unsupported': {
            enum6 = 27;
            break;
          }
          case 'no-tty': {
            enum6 = 28;
            break;
          }
          case 'no-such-device': {
            enum6 = 29;
            break;
          }
          case 'overflow': {
            enum6 = 30;
            break;
          }
          case 'not-permitted': {
            enum6 = 31;
            break;
          }
          case 'pipe': {
            enum6 = 32;
            break;
          }
          case 'read-only': {
            enum6 = 33;
            break;
          }
          case 'invalid-seek': {
            enum6 = 34;
            break;
          }
          case 'text-file-busy': {
            enum6 = 35;
            break;
          }
          case 'cross-device': {
            enum6 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val6}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg4 + 8, enum6, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash-at"][Instruction::Return]', {
      funcName: '[method]descriptor.metadata-hash-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_75_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]directory-entry-stream.read-directory-entry',
    moduleIdx: null,
  };
  
  
  function trampoline89(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable21[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable7.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(DirectoryEntryStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readDirectoryEntry?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'readDirectoryEntry',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readDirectoryEntry()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var variant6 = e;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory0).setInt8(arg1 + 4, 0, true);
        } else {
          const e = variant6;
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          var {type: v3_0, name: v3_1 } = e;
          var val4 = v3_0;
          let enum4;
          switch (val4) {
            case 'unknown': {
              enum4 = 0;
              break;
            }
            case 'block-device': {
              enum4 = 1;
              break;
            }
            case 'character-device': {
              enum4 = 2;
              break;
            }
            case 'directory': {
              enum4 = 3;
              break;
            }
            case 'fifo': {
              enum4 = 4;
              break;
            }
            case 'symbolic-link': {
              enum4 = 5;
              break;
            }
            case 'regular-file': {
              enum4 = 6;
              break;
            }
            case 'socket': {
              enum4 = 7;
              break;
            }
            default: {
              if ((v3_0) instanceof Error) {
                console.error(v3_0);
              }
              
              throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
            }
          }
          dataView(memory0).setInt8(arg1 + 8, enum4, true);
          
          var encodeRes = _utf8AllocateAndEncode(v3_1, realloc0, memory0);
          var ptr5= encodeRes.ptr;
          var len5 = encodeRes.len;
          
          dataView(memory0).setUint32(arg1 + 16, len5, true);
          dataView(memory0).setUint32(arg1 + 12, ptr5, true);
        }
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'access': {
            enum7 = 0;
            break;
          }
          case 'would-block': {
            enum7 = 1;
            break;
          }
          case 'already': {
            enum7 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum7 = 3;
            break;
          }
          case 'busy': {
            enum7 = 4;
            break;
          }
          case 'deadlock': {
            enum7 = 5;
            break;
          }
          case 'quota': {
            enum7 = 6;
            break;
          }
          case 'exist': {
            enum7 = 7;
            break;
          }
          case 'file-too-large': {
            enum7 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum7 = 9;
            break;
          }
          case 'in-progress': {
            enum7 = 10;
            break;
          }
          case 'interrupted': {
            enum7 = 11;
            break;
          }
          case 'invalid': {
            enum7 = 12;
            break;
          }
          case 'io': {
            enum7 = 13;
            break;
          }
          case 'is-directory': {
            enum7 = 14;
            break;
          }
          case 'loop': {
            enum7 = 15;
            break;
          }
          case 'too-many-links': {
            enum7 = 16;
            break;
          }
          case 'message-size': {
            enum7 = 17;
            break;
          }
          case 'name-too-long': {
            enum7 = 18;
            break;
          }
          case 'no-device': {
            enum7 = 19;
            break;
          }
          case 'no-entry': {
            enum7 = 20;
            break;
          }
          case 'no-lock': {
            enum7 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum7 = 22;
            break;
          }
          case 'insufficient-space': {
            enum7 = 23;
            break;
          }
          case 'not-directory': {
            enum7 = 24;
            break;
          }
          case 'not-empty': {
            enum7 = 25;
            break;
          }
          case 'not-recoverable': {
            enum7 = 26;
            break;
          }
          case 'unsupported': {
            enum7 = 27;
            break;
          }
          case 'no-tty': {
            enum7 = 28;
            break;
          }
          case 'no-such-device': {
            enum7 = 29;
            break;
          }
          case 'overflow': {
            enum7 = 30;
            break;
          }
          case 'not-permitted': {
            enum7 = 31;
            break;
          }
          case 'pipe': {
            enum7 = 32;
            break;
          }
          case 'read-only': {
            enum7 = 33;
            break;
          }
          case 'invalid-seek': {
            enum7 = 34;
            break;
          }
          case 'text-file-busy': {
            enum7 = 35;
            break;
          }
          case 'cross-device': {
            enum7 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"][Instruction::Return]', {
      funcName: '[method]directory-entry-stream.read-directory-entry',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_76_metadata = {
    qualifiedImportFn: 'wasi:filesystem/preopens@0.2.3#get-directories',
    moduleIdx: null,
  };
  
  
  function trampoline90(arg0) {
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getDirectories?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getDirectories',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getDirectories();
    endCurrentTask(1);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc0(0, 0, 4, len3 * 12);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 12;var [tuple0_0, tuple0_1] = e;
      if (!(tuple0_0 instanceof Descriptor)) {
        throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
      }
      var handle1 = tuple0_0[symbolRscHandle];
      if (!handle1) {
        const rep = tuple0_0[symbolRscRep] || ++captureCnt6;
        captureTable6.set(rep, tuple0_0);
        handle1 = rscTableCreateOwn(handleTable20, rep);
      }
      dataView(memory0).setInt32(base + 0, handle1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc0, memory0);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 8, len2, true);
      dataView(memory0).setUint32(base + 4, ptr2, true);
    }
    dataView(memory0).setUint32(arg0 + 4, len3, true);
    dataView(memory0).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"][Instruction::Return]', {
      funcName: 'get-directories',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_77_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.start-bind',
    moduleIdx: null,
  };
  
  
  function trampoline91(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable18[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable8.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Network.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    let variant6;
    switch (arg2) {
      case 0: {
        variant6= {
          tag: 'ipv4',
          val: {
            port: clampGuest(arg3, 0, 65535),
            address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
          }
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'ipv6',
          val: {
            port: clampGuest(arg3, 0, 65535),
            flowInfo: arg4 >>> 0,
            address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
            scopeId: arg13 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for IpSocketAddress');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.start-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'startBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startBind(rsc3, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg14 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg14 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg14 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.start-bind"][Instruction::Return]', {
      funcName: '[method]udp-socket.start-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_78_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.finish-bind',
    moduleIdx: null,
  };
  
  
  function trampoline92(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.finish-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'finishBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishBind()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.finish-bind"][Instruction::Return]', {
      funcName: '[method]udp-socket.finish-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_79_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.stream',
    moduleIdx: null,
  };
  
  
  function trampoline93(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let variant4;
    switch (arg1) {
      case 0: {
        variant4 = undefined;
        break;
      }
      case 1: {
        let variant3;
        switch (arg2) {
          case 0: {
            variant3= {
              tag: 'ipv4',
              val: {
                port: clampGuest(arg3, 0, 65535),
                address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
              }
            };
            break;
          }
          case 1: {
            variant3= {
              tag: 'ipv6',
              val: {
                port: clampGuest(arg3, 0, 65535),
                flowInfo: arg4 >>> 0,
                address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
                scopeId: arg13 >>> 0,
              }
            };
            break;
          }
          default: {
            throw new TypeError('invalid variant discriminant for IpSocketAddress');
          }
        }
        variant4 = variant3;
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for option');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.stream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'stream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.stream(variant4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg14 + 0, 0, true);
        var [tuple5_0, tuple5_1] = e;
        if (!(tuple5_0 instanceof IncomingDatagramStream)) {
          throw new TypeError('Resource error: Not a valid "IncomingDatagramStream" resource.');
        }
        var handle6 = tuple5_0[symbolRscHandle];
        if (!handle6) {
          const rep = tuple5_0[symbolRscRep] || ++captureCnt10;
          captureTable10.set(rep, tuple5_0);
          handle6 = rscTableCreateOwn(handleTable23, rep);
        }
        dataView(memory0).setInt32(arg14 + 4, handle6, true);
        if (!(tuple5_1 instanceof OutgoingDatagramStream)) {
          throw new TypeError('Resource error: Not a valid "OutgoingDatagramStream" resource.');
        }
        var handle7 = tuple5_1[symbolRscHandle];
        if (!handle7) {
          const rep = tuple5_1[symbolRscRep] || ++captureCnt11;
          captureTable11.set(rep, tuple5_1);
          handle7 = rscTableCreateOwn(handleTable24, rep);
        }
        dataView(memory0).setInt32(arg14 + 8, handle7, true);
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg14 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg14 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.stream"][Instruction::Return]', {
      funcName: '[method]udp-socket.stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_80_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.local-address',
    moduleIdx: null,
  };
  
  
  function trampoline94(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.local-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.localAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'localAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.localAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.local-address"][Instruction::Return]', {
      funcName: '[method]udp-socket.local-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_81_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.remote-address',
    moduleIdx: null,
  };
  
  
  function trampoline95(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.remote-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.remoteAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'remoteAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.remoteAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.remote-address"][Instruction::Return]', {
      funcName: '[method]udp-socket.remote-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_82_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.unicast-hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline96(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.unicast-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.unicastHopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'unicastHopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.unicastHopLimit()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setInt8(arg1 + 1, toUint8(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.unicast-hop-limit"][Instruction::Return]', {
      funcName: '[method]udp-socket.unicast-hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_83_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.set-unicast-hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline97(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-unicast-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setUnicastHopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setUnicastHopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setUnicastHopLimit(clampGuest(arg1, 0, 255))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-unicast-hop-limit"][Instruction::Return]', {
      funcName: '[method]udp-socket.set-unicast-hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_84_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline98(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.receiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'receiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.receiveBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_85_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.set-receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline99(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setReceiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setReceiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setReceiveBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.set-receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_86_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline100(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.sendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'sendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.sendBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.send-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_87_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.set-send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline101(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable22[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setSendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setSendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setSendBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-send-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.set-send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_88_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]incoming-datagram-stream.receive',
    moduleIdx: null,
  };
  
  
  function trampoline102(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable23[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable10.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(IncomingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.receive"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.receive?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'receive',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.receive(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant12 = ret;
    switch (variant12.tag) {
      case 'ok': {
        const e = variant12.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        var vec10 = e;
        var len10 = vec10.length;
        var result10 = realloc0(0, 0, 4, len10 * 40);
        for (let i = 0; i < vec10.length; i++) {
          const e = vec10[i];
          const base = result10 + i * 40;var {data: v3_0, remoteAddress: v3_1 } = e;
          var val4 = v3_0;
          var len4 = val4.byteLength;
          var ptr4 = realloc0(0, 0, 1, len4 * 1);
          
          let valData4;
          const valLenBytes4 = len4 * 1;
          if (Array.isArray(val4)) {
            // Regular array likely containing numbers, write values to memory
            let offset = 0;
            const dv4 = new DataView(memory0.buffer);
            for (const v of val4) {
              dv4.setUint8(ptr4+ offset, v, true);
              offset += 1;
            }
          } else {
            // TypedArray / ArrayBuffer-like, direct copy
            valData4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, valLenBytes4);
            const out4 = new Uint8Array(memory0.buffer, ptr4,valLenBytes4);
            out4.set(valData4);
          }
          
          dataView(memory0).setUint32(base + 4, len4, true);
          dataView(memory0).setUint32(base + 0, ptr4, true);
          var variant9 = v3_1;
          switch (variant9.tag) {
            case 'ipv4': {
              const e = variant9.val;
              dataView(memory0).setInt8(base + 8, 0, true);
              var {port: v5_0, address: v5_1 } = e;
              dataView(memory0).setInt16(base + 12, toUint16(v5_0), true);
              var [tuple6_0, tuple6_1, tuple6_2, tuple6_3] = v5_1;
              dataView(memory0).setInt8(base + 14, toUint8(tuple6_0), true);
              dataView(memory0).setInt8(base + 15, toUint8(tuple6_1), true);
              dataView(memory0).setInt8(base + 16, toUint8(tuple6_2), true);
              dataView(memory0).setInt8(base + 17, toUint8(tuple6_3), true);
              break;
            }
            case 'ipv6': {
              const e = variant9.val;
              dataView(memory0).setInt8(base + 8, 1, true);
              var {port: v7_0, flowInfo: v7_1, address: v7_2, scopeId: v7_3 } = e;
              dataView(memory0).setInt16(base + 12, toUint16(v7_0), true);
              dataView(memory0).setInt32(base + 16, toUint32(v7_1), true);
              var [tuple8_0, tuple8_1, tuple8_2, tuple8_3, tuple8_4, tuple8_5, tuple8_6, tuple8_7] = v7_2;
              dataView(memory0).setInt16(base + 20, toUint16(tuple8_0), true);
              dataView(memory0).setInt16(base + 22, toUint16(tuple8_1), true);
              dataView(memory0).setInt16(base + 24, toUint16(tuple8_2), true);
              dataView(memory0).setInt16(base + 26, toUint16(tuple8_3), true);
              dataView(memory0).setInt16(base + 28, toUint16(tuple8_4), true);
              dataView(memory0).setInt16(base + 30, toUint16(tuple8_5), true);
              dataView(memory0).setInt16(base + 32, toUint16(tuple8_6), true);
              dataView(memory0).setInt16(base + 34, toUint16(tuple8_7), true);
              dataView(memory0).setInt32(base + 36, toUint32(v7_3), true);
              break;
            }
            default: {
              throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant9.tag)}\` (received \`${variant9}\`) specified for \`IpSocketAddress\``);
            }
          }
        }
        dataView(memory0).setUint32(arg2 + 8, len10, true);
        dataView(memory0).setUint32(arg2 + 4, result10, true);
        break;
      }
      case 'err': {
        const e = variant12.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val11 = e;
        let enum11;
        switch (val11) {
          case 'unknown': {
            enum11 = 0;
            break;
          }
          case 'access-denied': {
            enum11 = 1;
            break;
          }
          case 'not-supported': {
            enum11 = 2;
            break;
          }
          case 'invalid-argument': {
            enum11 = 3;
            break;
          }
          case 'out-of-memory': {
            enum11 = 4;
            break;
          }
          case 'timeout': {
            enum11 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum11 = 6;
            break;
          }
          case 'not-in-progress': {
            enum11 = 7;
            break;
          }
          case 'would-block': {
            enum11 = 8;
            break;
          }
          case 'invalid-state': {
            enum11 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum11 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum11 = 11;
            break;
          }
          case 'address-in-use': {
            enum11 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum11 = 13;
            break;
          }
          case 'connection-refused': {
            enum11 = 14;
            break;
          }
          case 'connection-reset': {
            enum11 = 15;
            break;
          }
          case 'connection-aborted': {
            enum11 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum11 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum11 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum11 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum11 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val11}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 4, enum11, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.receive"][Instruction::Return]', {
      funcName: '[method]incoming-datagram-stream.receive',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_89_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]outgoing-datagram-stream.check-send',
    moduleIdx: null,
  };
  
  
  function trampoline103(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable24[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable11.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutgoingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.check-send"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.checkSend?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'checkSend',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.checkSend()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.check-send"][Instruction::Return]', {
      funcName: '[method]outgoing-datagram-stream.check-send',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_90_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]outgoing-datagram-stream.send',
    moduleIdx: null,
  };
  
  
  function trampoline104(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable24[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable11.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutgoingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var len6 = arg2;
    var base6 = arg1;
    var result6 = [];
    for (let i = 0; i < len6; i++) {
      const base = base6 + i * 44;
      var ptr3 = dataView(memory0).getUint32(base + 0, true);
      var len3 = dataView(memory0).getUint32(base + 4, true);
      var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
      let variant5;
      switch (dataView(memory0).getUint8(base + 8, true)) {
        case 0: {
          variant5 = undefined;
          break;
        }
        case 1: {
          let variant4;
          switch (dataView(memory0).getUint8(base + 12, true)) {
            case 0: {
              variant4= {
                tag: 'ipv4',
                val: {
                  port: clampGuest(dataView(memory0).getUint16(base + 16, true), 0, 65535),
                  address: [clampGuest(dataView(memory0).getUint8(base + 18, true), 0, 255), clampGuest(dataView(memory0).getUint8(base + 19, true), 0, 255), clampGuest(dataView(memory0).getUint8(base + 20, true), 0, 255), clampGuest(dataView(memory0).getUint8(base + 21, true), 0, 255)],
                }
              };
              break;
            }
            case 1: {
              variant4= {
                tag: 'ipv6',
                val: {
                  port: clampGuest(dataView(memory0).getUint16(base + 16, true), 0, 65535),
                  flowInfo: dataView(memory0).getInt32(base + 20, true) >>> 0,
                  address: [clampGuest(dataView(memory0).getUint16(base + 24, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 26, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 28, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 30, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 32, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 34, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 36, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 38, true), 0, 65535)],
                  scopeId: dataView(memory0).getInt32(base + 40, true) >>> 0,
                }
              };
              break;
            }
            default: {
              throw new TypeError('invalid variant discriminant for IpSocketAddress');
            }
          }
          variant5 = variant4;
          break;
        }
        default: {
          throw new TypeError('invalid variant discriminant for option');
        }
      }
      result6.push({
        data: result3,
        remoteAddress: variant5,
      });
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.send"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.send?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'send',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.send(result6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        dataView(memory0).setBigInt64(arg3 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg3 + 8, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.send"][Instruction::Return]', {
      funcName: '[method]outgoing-datagram-stream.send',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_91_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp-create-socket@0.2.3#create-udp-socket',
    moduleIdx: null,
  };
  
  
  function trampoline105(arg0, arg1) {
    let enum0;
    switch (arg0) {
      case 0: {
        enum0 = 'ipv4';
        break;
      }
      case 1: {
        enum0 = 'ipv6';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for IpAddressFamily');
      }
    }
    _debugLog('[iface="wasi:sockets/udp-create-socket@0.2.3", function="create-udp-socket"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = createUdpSocket?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'createUdpSocket',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  createUdpSocket(enum0)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    endCurrentTask(1);
    var variant3 = ret;
    switch (variant3.tag) {
      case 'ok': {
        const e = variant3.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof UdpSocket)) {
          throw new TypeError('Resource error: Not a valid "UdpSocket" resource.');
        }
        var handle1 = e[symbolRscHandle];
        if (!handle1) {
          const rep = e[symbolRscRep] || ++captureCnt9;
          captureTable9.set(rep, e);
          handle1 = rscTableCreateOwn(handleTable22, rep);
        }
        dataView(memory0).setInt32(arg1 + 4, handle1, true);
        break;
      }
      case 'err': {
        const e = variant3.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val2 = e;
        let enum2;
        switch (val2) {
          case 'unknown': {
            enum2 = 0;
            break;
          }
          case 'access-denied': {
            enum2 = 1;
            break;
          }
          case 'not-supported': {
            enum2 = 2;
            break;
          }
          case 'invalid-argument': {
            enum2 = 3;
            break;
          }
          case 'out-of-memory': {
            enum2 = 4;
            break;
          }
          case 'timeout': {
            enum2 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum2 = 6;
            break;
          }
          case 'not-in-progress': {
            enum2 = 7;
            break;
          }
          case 'would-block': {
            enum2 = 8;
            break;
          }
          case 'invalid-state': {
            enum2 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum2 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum2 = 11;
            break;
          }
          case 'address-in-use': {
            enum2 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum2 = 13;
            break;
          }
          case 'connection-refused': {
            enum2 = 14;
            break;
          }
          case 'connection-reset': {
            enum2 = 15;
            break;
          }
          case 'connection-aborted': {
            enum2 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum2 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum2 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum2 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum2 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val2}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum2, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp-create-socket@0.2.3", function="create-udp-socket"][Instruction::Return]', {
      funcName: 'create-udp-socket',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_92_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.start-bind',
    moduleIdx: null,
  };
  
  
  function trampoline106(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable18[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable8.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Network.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    let variant6;
    switch (arg2) {
      case 0: {
        variant6= {
          tag: 'ipv4',
          val: {
            port: clampGuest(arg3, 0, 65535),
            address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
          }
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'ipv6',
          val: {
            port: clampGuest(arg3, 0, 65535),
            flowInfo: arg4 >>> 0,
            address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
            scopeId: arg13 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for IpSocketAddress');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'startBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startBind(rsc3, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg14 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg14 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg14 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-bind"][Instruction::Return]', {
      funcName: '[method]tcp-socket.start-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_93_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.finish-bind',
    moduleIdx: null,
  };
  
  
  function trampoline107(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'finishBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishBind()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-bind"][Instruction::Return]', {
      funcName: '[method]tcp-socket.finish-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_94_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.start-listen',
    moduleIdx: null,
  };
  
  
  function trampoline108(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-listen"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startListen?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'startListen',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startListen()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-listen"][Instruction::Return]', {
      funcName: '[method]tcp-socket.start-listen',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_95_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.finish-listen',
    moduleIdx: null,
  };
  
  
  function trampoline109(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-listen"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishListen?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'finishListen',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishListen()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-listen"][Instruction::Return]', {
      funcName: '[method]tcp-socket.finish-listen',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_96_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.accept',
    moduleIdx: null,
  };
  
  
  function trampoline110(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.accept"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.accept?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'accept',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.accept()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var [tuple3_0, tuple3_1, tuple3_2] = e;
        if (!(tuple3_0 instanceof TcpSocket)) {
          throw new TypeError('Resource error: Not a valid "TcpSocket" resource.');
        }
        var handle4 = tuple3_0[symbolRscHandle];
        if (!handle4) {
          const rep = tuple3_0[symbolRscRep] || ++captureCnt12;
          captureTable12.set(rep, tuple3_0);
          handle4 = rscTableCreateOwn(handleTable17, rep);
        }
        dataView(memory0).setInt32(arg1 + 4, handle4, true);
        if (!(tuple3_1 instanceof InputStream)) {
          throw new TypeError('Resource error: Not a valid "InputStream" resource.');
        }
        var handle5 = tuple3_1[symbolRscHandle];
        if (!handle5) {
          const rep = tuple3_1[symbolRscRep] || ++captureCnt2;
          captureTable2.set(rep, tuple3_1);
          handle5 = rscTableCreateOwn(handleTable15, rep);
        }
        dataView(memory0).setInt32(arg1 + 8, handle5, true);
        if (!(tuple3_2 instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle6 = tuple3_2[symbolRscHandle];
        if (!handle6) {
          const rep = tuple3_2[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, tuple3_2);
          handle6 = rscTableCreateOwn(handleTable16, rep);
        }
        dataView(memory0).setInt32(arg1 + 12, handle6, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.accept"][Instruction::Return]', {
      funcName: '[method]tcp-socket.accept',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_97_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.local-address',
    moduleIdx: null,
  };
  
  
  function trampoline111(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.local-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.localAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'localAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.localAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.local-address"][Instruction::Return]', {
      funcName: '[method]tcp-socket.local-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_98_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.remote-address',
    moduleIdx: null,
  };
  
  
  function trampoline112(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.remote-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.remoteAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'remoteAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.remoteAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory0).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.remote-address"][Instruction::Return]', {
      funcName: '[method]tcp-socket.remote-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_99_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-listen-backlog-size',
    moduleIdx: null,
  };
  
  
  function trampoline113(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-listen-backlog-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setListenBacklogSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setListenBacklogSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setListenBacklogSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-listen-backlog-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-listen-backlog-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_100_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-enabled',
    moduleIdx: null,
  };
  
  
  function trampoline114(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-enabled"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveEnabled?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'keepAliveEnabled',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveEnabled()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setInt8(arg1 + 1, e ? 1 : 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-enabled"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-enabled',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_101_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-enabled',
    moduleIdx: null,
  };
  
  
  function trampoline115(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var bool3 = arg1;
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-enabled"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveEnabled?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setKeepAliveEnabled',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveEnabled(bool3 == 0 ? false : (bool3 == 1 ? true : throwInvalidBool()))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'access-denied': {
            enum4 = 1;
            break;
          }
          case 'not-supported': {
            enum4 = 2;
            break;
          }
          case 'invalid-argument': {
            enum4 = 3;
            break;
          }
          case 'out-of-memory': {
            enum4 = 4;
            break;
          }
          case 'timeout': {
            enum4 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum4 = 6;
            break;
          }
          case 'not-in-progress': {
            enum4 = 7;
            break;
          }
          case 'would-block': {
            enum4 = 8;
            break;
          }
          case 'invalid-state': {
            enum4 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum4 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum4 = 11;
            break;
          }
          case 'address-in-use': {
            enum4 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum4 = 13;
            break;
          }
          case 'connection-refused': {
            enum4 = 14;
            break;
          }
          case 'connection-reset': {
            enum4 = 15;
            break;
          }
          case 'connection-aborted': {
            enum4 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum4 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum4 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum4 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum4 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-enabled"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-enabled',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_102_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-idle-time',
    moduleIdx: null,
  };
  
  
  function trampoline116(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-idle-time"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveIdleTime?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'keepAliveIdleTime',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveIdleTime()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-idle-time"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-idle-time',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_103_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-idle-time',
    moduleIdx: null,
  };
  
  
  function trampoline117(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-idle-time"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveIdleTime?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setKeepAliveIdleTime',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveIdleTime(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-idle-time"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-idle-time',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_104_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-interval',
    moduleIdx: null,
  };
  
  
  function trampoline118(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-interval"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveInterval?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'keepAliveInterval',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveInterval()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-interval"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-interval',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_105_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-interval',
    moduleIdx: null,
  };
  
  
  function trampoline119(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-interval"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveInterval?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setKeepAliveInterval',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveInterval(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-interval"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-interval',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_106_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-count',
    moduleIdx: null,
  };
  
  
  function trampoline120(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-count"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveCount?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'keepAliveCount',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveCount()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setInt32(arg1 + 4, toUint32(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-count"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-count',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_107_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-count',
    moduleIdx: null,
  };
  
  
  function trampoline121(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-count"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveCount?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setKeepAliveCount',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveCount(arg1 >>> 0)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-count"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-count',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_108_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline122(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.hopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'hopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.hopLimit()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setInt8(arg1 + 1, toUint8(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.hop-limit"][Instruction::Return]', {
      funcName: '[method]tcp-socket.hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_109_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline123(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setHopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setHopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setHopLimit(clampGuest(arg1, 0, 255))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-hop-limit"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_110_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline124(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.receiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'receiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.receiveBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_111_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline125(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setReceiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setReceiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setReceiveBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_112_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline126(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.sendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'sendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.sendBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.send-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_113_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline127(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setSendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'setSendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setSendBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-send-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_114_metadata = {
    qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.3#resolve-addresses',
    moduleIdx: null,
  };
  
  
  function trampoline128(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable18[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable8.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Network.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="resolve-addresses"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = resolveAddresses?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'resolveAddresses',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  resolveAddresses(rsc0, result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 0, true);
        if (!(e instanceof ResolveAddressStream)) {
          throw new TypeError('Resource error: Not a valid "ResolveAddressStream" resource.');
        }
        var handle4 = e[symbolRscHandle];
        if (!handle4) {
          const rep = e[symbolRscRep] || ++captureCnt13;
          captureTable13.set(rep, e);
          handle4 = rscTableCreateOwn(handleTable25, rep);
        }
        dataView(memory0).setInt32(arg3 + 4, handle4, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg3 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'unknown': {
            enum5 = 0;
            break;
          }
          case 'access-denied': {
            enum5 = 1;
            break;
          }
          case 'not-supported': {
            enum5 = 2;
            break;
          }
          case 'invalid-argument': {
            enum5 = 3;
            break;
          }
          case 'out-of-memory': {
            enum5 = 4;
            break;
          }
          case 'timeout': {
            enum5 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum5 = 6;
            break;
          }
          case 'not-in-progress': {
            enum5 = 7;
            break;
          }
          case 'would-block': {
            enum5 = 8;
            break;
          }
          case 'invalid-state': {
            enum5 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum5 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum5 = 11;
            break;
          }
          case 'address-in-use': {
            enum5 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum5 = 13;
            break;
          }
          case 'connection-refused': {
            enum5 = 14;
            break;
          }
          case 'connection-reset': {
            enum5 = 15;
            break;
          }
          case 'connection-aborted': {
            enum5 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum5 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum5 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum5 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum5 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg3 + 4, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="resolve-addresses"][Instruction::Return]', {
      funcName: 'resolve-addresses',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_115_metadata = {
    qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.3#[method]resolve-address-stream.resolve-next-address',
    moduleIdx: null,
  };
  
  
  function trampoline129(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable25[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable13.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(ResolveAddressStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.resolve-next-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.resolveNextAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'resolveNextAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.resolveNextAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var variant6 = e;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory0).setInt8(arg1 + 2, 0, true);
        } else {
          const e = variant6;
          dataView(memory0).setInt8(arg1 + 2, 1, true);
          var variant5 = e;
          switch (variant5.tag) {
            case 'ipv4': {
              const e = variant5.val;
              dataView(memory0).setInt8(arg1 + 4, 0, true);
              var [tuple3_0, tuple3_1, tuple3_2, tuple3_3] = e;
              dataView(memory0).setInt8(arg1 + 6, toUint8(tuple3_0), true);
              dataView(memory0).setInt8(arg1 + 7, toUint8(tuple3_1), true);
              dataView(memory0).setInt8(arg1 + 8, toUint8(tuple3_2), true);
              dataView(memory0).setInt8(arg1 + 9, toUint8(tuple3_3), true);
              break;
            }
            case 'ipv6': {
              const e = variant5.val;
              dataView(memory0).setInt8(arg1 + 4, 1, true);
              var [tuple4_0, tuple4_1, tuple4_2, tuple4_3, tuple4_4, tuple4_5, tuple4_6, tuple4_7] = e;
              dataView(memory0).setInt16(arg1 + 6, toUint16(tuple4_0), true);
              dataView(memory0).setInt16(arg1 + 8, toUint16(tuple4_1), true);
              dataView(memory0).setInt16(arg1 + 10, toUint16(tuple4_2), true);
              dataView(memory0).setInt16(arg1 + 12, toUint16(tuple4_3), true);
              dataView(memory0).setInt16(arg1 + 14, toUint16(tuple4_4), true);
              dataView(memory0).setInt16(arg1 + 16, toUint16(tuple4_5), true);
              dataView(memory0).setInt16(arg1 + 18, toUint16(tuple4_6), true);
              dataView(memory0).setInt16(arg1 + 20, toUint16(tuple4_7), true);
              break;
            }
            default: {
              throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`IpAddress\``);
            }
          }
        }
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 2, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.resolve-next-address"][Instruction::Return]', {
      funcName: '[method]resolve-address-stream.resolve-next-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_116_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-arguments',
    moduleIdx: null,
  };
  
  
  function trampoline130(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getArguments?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getArguments',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getArguments();
    endCurrentTask(1);
    var vec1 = ret;
    var len1 = vec1.length;
    var result1 = realloc1(0, 0, 4, len1 * 8);
    for (let i = 0; i < vec1.length; i++) {
      const e = vec1[i];
      const base = result1 + i * 8;
      var encodeRes = _utf8AllocateAndEncode(e, realloc1, memory0);
      var ptr0= encodeRes.ptr;
      var len0 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 4, len0, true);
      dataView(memory0).setUint32(base + 0, ptr0, true);
    }
    dataView(memory0).setUint32(arg0 + 4, len1, true);
    dataView(memory0).setUint32(arg0 + 0, result1, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"][Instruction::Return]', {
      funcName: 'get-arguments',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_117_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-environment',
    moduleIdx: null,
  };
  
  
  function trampoline131(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getEnvironment?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getEnvironment',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getEnvironment();
    endCurrentTask(1);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc1(0, 0, 4, len3 * 16);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 16;var [tuple0_0, tuple0_1] = e;
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_0, realloc1, memory0);
      var ptr1= encodeRes.ptr;
      var len1 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 4, len1, true);
      dataView(memory0).setUint32(base + 0, ptr1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc1, memory0);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 12, len2, true);
      dataView(memory0).setUint32(base + 8, ptr2, true);
    }
    dataView(memory0).setUint32(arg0 + 4, len3, true);
    dataView(memory0).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"][Instruction::Return]', {
      funcName: 'get-environment',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_118_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]directory-entry-stream.read-directory-entry',
    moduleIdx: null,
  };
  
  
  function trampoline132(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable21[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable7.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(DirectoryEntryStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readDirectoryEntry?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'readDirectoryEntry',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readDirectoryEntry()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 0, true);
        var variant6 = e;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory0).setInt8(arg1 + 4, 0, true);
        } else {
          const e = variant6;
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          var {type: v3_0, name: v3_1 } = e;
          var val4 = v3_0;
          let enum4;
          switch (val4) {
            case 'unknown': {
              enum4 = 0;
              break;
            }
            case 'block-device': {
              enum4 = 1;
              break;
            }
            case 'character-device': {
              enum4 = 2;
              break;
            }
            case 'directory': {
              enum4 = 3;
              break;
            }
            case 'fifo': {
              enum4 = 4;
              break;
            }
            case 'symbolic-link': {
              enum4 = 5;
              break;
            }
            case 'regular-file': {
              enum4 = 6;
              break;
            }
            case 'socket': {
              enum4 = 7;
              break;
            }
            default: {
              if ((v3_0) instanceof Error) {
                console.error(v3_0);
              }
              
              throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
            }
          }
          dataView(memory0).setInt8(arg1 + 8, enum4, true);
          
          var encodeRes = _utf8AllocateAndEncode(v3_1, realloc1, memory0);
          var ptr5= encodeRes.ptr;
          var len5 = encodeRes.len;
          
          dataView(memory0).setUint32(arg1 + 16, len5, true);
          dataView(memory0).setUint32(arg1 + 12, ptr5, true);
        }
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory0).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'access': {
            enum7 = 0;
            break;
          }
          case 'would-block': {
            enum7 = 1;
            break;
          }
          case 'already': {
            enum7 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum7 = 3;
            break;
          }
          case 'busy': {
            enum7 = 4;
            break;
          }
          case 'deadlock': {
            enum7 = 5;
            break;
          }
          case 'quota': {
            enum7 = 6;
            break;
          }
          case 'exist': {
            enum7 = 7;
            break;
          }
          case 'file-too-large': {
            enum7 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum7 = 9;
            break;
          }
          case 'in-progress': {
            enum7 = 10;
            break;
          }
          case 'interrupted': {
            enum7 = 11;
            break;
          }
          case 'invalid': {
            enum7 = 12;
            break;
          }
          case 'io': {
            enum7 = 13;
            break;
          }
          case 'is-directory': {
            enum7 = 14;
            break;
          }
          case 'loop': {
            enum7 = 15;
            break;
          }
          case 'too-many-links': {
            enum7 = 16;
            break;
          }
          case 'message-size': {
            enum7 = 17;
            break;
          }
          case 'name-too-long': {
            enum7 = 18;
            break;
          }
          case 'no-device': {
            enum7 = 19;
            break;
          }
          case 'no-entry': {
            enum7 = 20;
            break;
          }
          case 'no-lock': {
            enum7 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum7 = 22;
            break;
          }
          case 'insufficient-space': {
            enum7 = 23;
            break;
          }
          case 'not-directory': {
            enum7 = 24;
            break;
          }
          case 'not-empty': {
            enum7 = 25;
            break;
          }
          case 'not-recoverable': {
            enum7 = 26;
            break;
          }
          case 'unsupported': {
            enum7 = 27;
            break;
          }
          case 'no-tty': {
            enum7 = 28;
            break;
          }
          case 'no-such-device': {
            enum7 = 29;
            break;
          }
          case 'overflow': {
            enum7 = 30;
            break;
          }
          case 'not-permitted': {
            enum7 = 31;
            break;
          }
          case 'pipe': {
            enum7 = 32;
            break;
          }
          case 'read-only': {
            enum7 = 33;
            break;
          }
          case 'invalid-seek': {
            enum7 = 34;
            break;
          }
          case 'text-file-busy': {
            enum7 = 35;
            break;
          }
          case 'cross-device': {
            enum7 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory0).setInt8(arg1 + 4, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"][Instruction::Return]', {
      funcName: '[method]directory-entry-stream.read-directory-entry',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_119_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.read',
    moduleIdx: null,
  };
  
  
  function trampoline133(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable15[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.read?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'read',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc1(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory0.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory0.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory0).setUint32(arg2 + 8, len3, true);
        dataView(memory0).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"][Instruction::Return]', {
      funcName: '[method]input-stream.read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_120_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.blocking-read',
    moduleIdx: null,
  };
  
  
  function trampoline134(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable15[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingRead?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'blockingRead',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingRead(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(1);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc1(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory0.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory0.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory0).setUint32(arg2 + 8, len3, true);
        dataView(memory0).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory0).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable19, rep);
            }
            dataView(memory0).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory0).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"][Instruction::Return]', {
      funcName: '[method]input-stream.blocking-read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_121_metadata = {
    qualifiedImportFn: 'wasi:filesystem/preopens@0.2.3#get-directories',
    moduleIdx: null,
  };
  
  
  function trampoline135(arg0) {
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getDirectories?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 1,
        isAsync: false,
        entryFnName: 'getDirectories',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(1)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getDirectories();
    endCurrentTask(1);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc1(0, 0, 4, len3 * 12);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 12;var [tuple0_0, tuple0_1] = e;
      if (!(tuple0_0 instanceof Descriptor)) {
        throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
      }
      var handle1 = tuple0_0[symbolRscHandle];
      if (!handle1) {
        const rep = tuple0_0[symbolRscRep] || ++captureCnt6;
        captureTable6.set(rep, tuple0_0);
        handle1 = rscTableCreateOwn(handleTable20, rep);
      }
      dataView(memory0).setInt32(base + 0, handle1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc1, memory0);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory0).setUint32(base + 8, len2, true);
      dataView(memory0).setUint32(base + 4, ptr2, true);
    }
    dataView(memory0).setUint32(arg0 + 4, len3, true);
    dataView(memory0).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"][Instruction::Return]', {
      funcName: 'get-directories',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  let exports3;
  let exports4;
  
  let lowered_import_122_metadata = {
    qualifiedImportFn: 'wasi:io/poll@0.2.3#[method]pollable.block',
    moduleIdx: null,
  };
  
  const handleTable28 = [T_FLAG, 0];
  handleTables[28] = handleTable28;
  
  function trampoline140(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable28[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable1.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Pollable.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.block"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.block?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'block',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret; rsc0.block();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.block"][Instruction::Return]', {
      funcName: '[method]pollable.block',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_123_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable29 = [T_FLAG, 0];
  handleTables[29] = handleTable29;
  
  function trampoline141(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable29[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]input-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_124_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable30 = [T_FLAG, 0];
  handleTables[30] = handleTable30;
  
  function trampoline142(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]output-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_125_metadata = {
    qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.3#now',
    moduleIdx: null,
  };
  
  
  function trampoline143() {
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="now"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = now?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'now',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  now();
    endCurrentTask(3);
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="now"][Instruction::Return]', {
      funcName: 'now',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return toUint64(ret);
  }
  
  
  let lowered_import_126_metadata = {
    qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.3#subscribe-instant',
    moduleIdx: null,
  };
  
  
  function trampoline144(arg0) {
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-instant"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = subscribeInstant?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribeInstant',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  subscribeInstant(BigInt.asUintN(64, arg0));
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-instant"][Instruction::Return]', {
      funcName: 'subscribe-instant',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_127_metadata = {
    qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.3#subscribe-duration',
    moduleIdx: null,
  };
  
  
  function trampoline145(arg0) {
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-duration"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = subscribeDuration?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribeDuration',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  subscribeDuration(BigInt.asUintN(64, arg0));
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.3", function="subscribe-duration"][Instruction::Return]', {
      funcName: 'subscribe-duration',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_128_metadata = {
    qualifiedImportFn: 'wasi:sockets/instance-network@0.2.3#instance-network',
    moduleIdx: null,
  };
  
  const handleTable32 = [T_FLAG, 0];
  handleTables[32] = handleTable32;
  
  function trampoline146() {
    _debugLog('[iface="wasi:sockets/instance-network@0.2.3", function="instance-network"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = instanceNetwork?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'instanceNetwork',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  instanceNetwork();
    endCurrentTask(3);
    if (!(ret instanceof Network)) {
      throw new TypeError('Resource error: Not a valid "Network" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt8;
      captureTable8.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable32, rep);
    }
    _debugLog('[iface="wasi:sockets/instance-network@0.2.3", function="instance-network"][Instruction::Return]', {
      funcName: 'instance-network',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_129_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.subscribe',
    moduleIdx: null,
  };
  
  const handleTable31 = [T_FLAG, 0];
  handleTables[31] = handleTable31;
  
  function trampoline147(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.subscribe"][Instruction::Return]', {
      funcName: '[method]tcp-socket.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_130_metadata = {
    qualifiedImportFn: 'wasi:random/random@0.2.3#get-random-u64',
    moduleIdx: null,
  };
  
  
  function trampoline148() {
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-u64"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getRandomU64?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getRandomU64',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getRandomU64();
    endCurrentTask(3);
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-u64"][Instruction::Return]', {
      funcName: 'get-random-u64',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return toUint64(ret);
  }
  
  
  let lowered_import_131_metadata = {
    qualifiedImportFn: 'wasi:cli/exit@0.2.3#exit',
    moduleIdx: null,
  };
  
  
  function trampoline149(arg0) {
    let variant0;
    switch (arg0) {
      case 0: {
        variant0= {
          tag: 'ok',
          val: undefined
        };
        break;
      }
      case 1: {
        variant0= {
          tag: 'err',
          val: undefined
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for expected');
      }
    }
    _debugLog('[iface="wasi:cli/exit@0.2.3", function="exit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = exit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'exit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret; exit(variant0);
    endCurrentTask(3);
    _debugLog('[iface="wasi:cli/exit@0.2.3", function="exit"][Instruction::Return]', {
      funcName: 'exit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_132_metadata = {
    qualifiedImportFn: 'wasi:io/poll@0.2.3#[method]pollable.ready',
    moduleIdx: null,
  };
  
  
  function trampoline150(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable28[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable1.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Pollable.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.ready"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.ready?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'ready',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.ready();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="[method]pollable.ready"][Instruction::Return]', {
      funcName: '[method]pollable.ready',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return ret ? 1 : 0;
  }
  
  
  let lowered_import_133_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.is-same-object',
    moduleIdx: null,
  };
  
  const handleTable34 = [T_FLAG, 0];
  handleTables[34] = handleTable34;
  
  function trampoline151(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable34[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable6.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.is-same-object"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.isSameObject?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'isSameObject',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.isSameObject(rsc3);
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.is-same-object"][Instruction::Return]', {
      funcName: '[method]descriptor.is-same-object',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return ret ? 1 : 0;
  }
  
  
  let lowered_import_134_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.address-family',
    moduleIdx: null,
  };
  
  const handleTable36 = [T_FLAG, 0];
  handleTables[36] = handleTable36;
  
  function trampoline152(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.address-family"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.addressFamily?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'addressFamily',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.addressFamily();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var val3 = ret;
    let enum3;
    switch (val3) {
      case 'ipv4': {
        enum3 = 0;
        break;
      }
      case 'ipv6': {
        enum3 = 1;
        break;
      }
      default: {
        if ((ret) instanceof Error) {
          console.error(ret);
        }
        
        throw new TypeError(`"${val3}" is not one of the cases of ip-address-family`);
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.address-family"][Instruction::Return]', {
      funcName: '[method]udp-socket.address-family',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return enum3;
  }
  
  
  let lowered_import_135_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.subscribe',
    moduleIdx: null,
  };
  
  
  function trampoline153(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.subscribe"][Instruction::Return]', {
      funcName: '[method]udp-socket.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_136_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]incoming-datagram-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable37 = [T_FLAG, 0];
  handleTables[37] = handleTable37;
  
  function trampoline154(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable37[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable10.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(IncomingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]incoming-datagram-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_137_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]outgoing-datagram-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable38 = [T_FLAG, 0];
  handleTables[38] = handleTable38;
  
  function trampoline155(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable38[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable11.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutgoingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]outgoing-datagram-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  
  let lowered_import_138_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.is-listening',
    moduleIdx: null,
  };
  
  
  function trampoline156(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.is-listening"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.isListening?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'isListening',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.isListening();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.is-listening"][Instruction::Return]', {
      funcName: '[method]tcp-socket.is-listening',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return ret ? 1 : 0;
  }
  
  
  let lowered_import_139_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.address-family',
    moduleIdx: null,
  };
  
  
  function trampoline157(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.address-family"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.addressFamily?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'addressFamily',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.addressFamily();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var val3 = ret;
    let enum3;
    switch (val3) {
      case 'ipv4': {
        enum3 = 0;
        break;
      }
      case 'ipv6': {
        enum3 = 1;
        break;
      }
      default: {
        if ((ret) instanceof Error) {
          console.error(ret);
        }
        
        throw new TypeError(`"${val3}" is not one of the cases of ip-address-family`);
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.address-family"][Instruction::Return]', {
      funcName: '[method]tcp-socket.address-family',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return enum3;
  }
  
  
  let lowered_import_140_metadata = {
    qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.3#[method]resolve-address-stream.subscribe',
    moduleIdx: null,
  };
  
  const handleTable39 = [T_FLAG, 0];
  handleTables[39] = handleTable39;
  
  function trampoline158(arg0) {
    var handle1 = arg0;
    var rep2 = handleTable39[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable13.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(ResolveAddressStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.subscribe?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'subscribe',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.subscribe();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    if (!(ret instanceof Pollable)) {
      throw new TypeError('Resource error: Not a valid "Pollable" resource.');
    }
    var handle3 = ret[symbolRscHandle];
    if (!handle3) {
      const rep = ret[symbolRscRep] || ++captureCnt1;
      captureTable1.set(rep, ret);
      handle3 = rscTableCreateOwn(handleTable28, rep);
    }
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.subscribe"][Instruction::Return]', {
      funcName: '[method]resolve-address-stream.subscribe',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle3;
  }
  
  let exports5;
  
  let lowered_import_141_metadata = {
    qualifiedImportFn: 'docs:calculator/stream-sink@0.1.0#on-number',
    moduleIdx: null,
  };
  
  
  function trampoline159(arg0) {
    _debugLog('[iface="docs:calculator/stream-sink@0.1.0", function="on-number"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = onNumber?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'onNumber',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  onNumber(arg0 >>> 0);
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/stream-sink@0.1.0", function="on-number"][Instruction::Return]', {
      funcName: 'on-number',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return ret ? 1 : 0;
  }
  
  
  let lowered_import_142_metadata = {
    qualifiedImportFn: 'docs:calculator/stream-sink@0.1.0#on-done',
    moduleIdx: null,
  };
  
  
  function trampoline160() {
    _debugLog('[iface="docs:calculator/stream-sink@0.1.0", function="on-done"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = onDone?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'onDone',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret; onDone();
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/stream-sink@0.1.0", function="on-done"][Instruction::Return]', {
      funcName: 'on-done',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  let exports6;
  
  let lowered_import_143_metadata = {
    qualifiedImportFn: 'wasi:cli/stderr@0.2.3#get-stderr',
    moduleIdx: null,
  };
  
  
  function trampoline177() {
    _debugLog('[iface="wasi:cli/stderr@0.2.3", function="get-stderr"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getStderr?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getStderr',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getStderr();
    endCurrentTask(3);
    if (!(ret instanceof OutputStream)) {
      throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt3;
      captureTable3.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable30, rep);
    }
    _debugLog('[iface="wasi:cli/stderr@0.2.3", function="get-stderr"][Instruction::Return]', {
      funcName: 'get-stderr',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_144_metadata = {
    qualifiedImportFn: 'wasi:cli/stdin@0.2.3#get-stdin',
    moduleIdx: null,
  };
  
  
  function trampoline178() {
    _debugLog('[iface="wasi:cli/stdin@0.2.3", function="get-stdin"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getStdin?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getStdin',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getStdin();
    endCurrentTask(3);
    if (!(ret instanceof InputStream)) {
      throw new TypeError('Resource error: Not a valid "InputStream" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt2;
      captureTable2.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable29, rep);
    }
    _debugLog('[iface="wasi:cli/stdin@0.2.3", function="get-stdin"][Instruction::Return]', {
      funcName: 'get-stdin',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  
  let lowered_import_145_metadata = {
    qualifiedImportFn: 'wasi:cli/stdout@0.2.3#get-stdout',
    moduleIdx: null,
  };
  
  
  function trampoline179() {
    _debugLog('[iface="wasi:cli/stdout@0.2.3", function="get-stdout"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getStdout?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getStdout',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getStdout();
    endCurrentTask(3);
    if (!(ret instanceof OutputStream)) {
      throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
    }
    var handle0 = ret[symbolRscHandle];
    if (!handle0) {
      const rep = ret[symbolRscRep] || ++captureCnt3;
      captureTable3.set(rep, ret);
      handle0 = rscTableCreateOwn(handleTable30, rep);
    }
    _debugLog('[iface="wasi:cli/stdout@0.2.3", function="get-stdout"][Instruction::Return]', {
      funcName: 'get-stdout',
      paramCount: 1,
      async: false,
      postReturn: false
    });
    return handle0;
  }
  
  let exports7;
  let memory1;
  let realloc2;
  let realloc3;
  
  let lowered_import_146_metadata = {
    qualifiedImportFn: 'wasi:io/poll@0.2.3#poll',
    moduleIdx: null,
  };
  
  
  function trampoline180(arg0, arg1, arg2) {
    var len3 = arg1;
    var base3 = arg0;
    var result3 = [];
    for (let i = 0; i < len3; i++) {
      const base = base3 + i * 4;
      var handle1 = dataView(memory1).getInt32(base + 0, true);
      var rep2 = handleTable28[(handle1 << 1) + 1] & ~T_FLAG;
      var rsc0 = captureTable1.get(rep2);
      if (!rsc0) {
        rsc0 = Object.create(Pollable.prototype);
        Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
        Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
      }
      curResourceBorrows.push(rsc0);
      result3.push(rsc0);
    }
    _debugLog('[iface="wasi:io/poll@0.2.3", function="poll"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = poll?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'poll',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  poll(result3);
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var val4 = ret;
    var len4 = val4.length;
    var ptr4 = realloc2(0, 0, 4, len4 * 4);
    
    let valData4;
    const valLenBytes4 = len4 * 4;
    if (Array.isArray(val4)) {
      // Regular array likely containing numbers, write values to memory
      let offset = 0;
      const dv4 = new DataView(memory1.buffer);
      for (const v of val4) {
        dv4.setUint32(ptr4+ offset, v, true);
        offset += 4;
      }
    } else {
      // TypedArray / ArrayBuffer-like, direct copy
      valData4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, valLenBytes4);
      const out4 = new Uint8Array(memory1.buffer, ptr4,valLenBytes4);
      out4.set(valData4);
    }
    
    dataView(memory1).setUint32(arg2 + 4, len4, true);
    dataView(memory1).setUint32(arg2 + 0, ptr4, true);
    _debugLog('[iface="wasi:io/poll@0.2.3", function="poll"][Instruction::Return]', {
      funcName: 'poll',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_147_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.read',
    moduleIdx: null,
  };
  
  const handleTable33 = [T_FLAG, 0];
  handleTables[33] = handleTable33;
  
  function trampoline181(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable29[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.read?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'read',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc2(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory1.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory1.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory1).setUint32(arg2 + 8, len3, true);
        dataView(memory1).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory1).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"][Instruction::Return]', {
      funcName: '[method]input-stream.read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_148_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.blocking-read',
    moduleIdx: null,
  };
  
  
  function trampoline182(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable29[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingRead?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'blockingRead',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingRead(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc2(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory1.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory1.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory1).setUint32(arg2 + 8, len3, true);
        dataView(memory1).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory1).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"][Instruction::Return]', {
      funcName: '[method]input-stream.blocking-read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_149_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.check-write',
    moduleIdx: null,
  };
  
  
  function trampoline183(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.check-write"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.checkWrite?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'checkWrite',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.checkWrite()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory1).setInt8(arg1 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg1 + 12, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg1 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.check-write"][Instruction::Return]', {
      funcName: '[method]output-stream.check-write',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_150_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.write',
    moduleIdx: null,
  };
  
  
  function trampoline184(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = new Uint8Array(memory1.buffer.slice(ptr3, ptr3 + len3 * 1));
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.write?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'write',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.write(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory1).setInt8(arg3 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg3 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg3 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write"][Instruction::Return]', {
      funcName: '[method]output-stream.write',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_151_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-flush',
    moduleIdx: null,
  };
  
  
  function trampoline185(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingFlush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'blockingFlush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingFlush()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory1).setInt8(arg1 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg1 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg1 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-flush"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_152_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.start-connect',
    moduleIdx: null,
  };
  
  
  function trampoline186(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable32[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable8.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Network.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    let variant6;
    switch (arg2) {
      case 0: {
        variant6= {
          tag: 'ipv4',
          val: {
            port: clampGuest(arg3, 0, 65535),
            address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
          }
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'ipv6',
          val: {
            port: clampGuest(arg3, 0, 65535),
            flowInfo: arg4 >>> 0,
            address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
            scopeId: arg13 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for IpSocketAddress');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-connect"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startConnect?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'startConnect',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startConnect(rsc3, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg14 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg14 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg14 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-connect"][Instruction::Return]', {
      funcName: '[method]tcp-socket.start-connect',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_153_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.finish-connect',
    moduleIdx: null,
  };
  
  
  function trampoline187(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-connect"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishConnect?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'finishConnect',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishConnect()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant7 = ret;
    switch (variant7.tag) {
      case 'ok': {
        const e = variant7.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var [tuple3_0, tuple3_1] = e;
        if (!(tuple3_0 instanceof InputStream)) {
          throw new TypeError('Resource error: Not a valid "InputStream" resource.');
        }
        var handle4 = tuple3_0[symbolRscHandle];
        if (!handle4) {
          const rep = tuple3_0[symbolRscRep] || ++captureCnt2;
          captureTable2.set(rep, tuple3_0);
          handle4 = rscTableCreateOwn(handleTable29, rep);
        }
        dataView(memory1).setInt32(arg1 + 4, handle4, true);
        if (!(tuple3_1 instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle5 = tuple3_1[symbolRscHandle];
        if (!handle5) {
          const rep = tuple3_1[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, tuple3_1);
          handle5 = rscTableCreateOwn(handleTable30, rep);
        }
        dataView(memory1).setInt32(arg1 + 8, handle5, true);
        break;
      }
      case 'err': {
        const e = variant7.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val6 = e;
        let enum6;
        switch (val6) {
          case 'unknown': {
            enum6 = 0;
            break;
          }
          case 'access-denied': {
            enum6 = 1;
            break;
          }
          case 'not-supported': {
            enum6 = 2;
            break;
          }
          case 'invalid-argument': {
            enum6 = 3;
            break;
          }
          case 'out-of-memory': {
            enum6 = 4;
            break;
          }
          case 'timeout': {
            enum6 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum6 = 6;
            break;
          }
          case 'not-in-progress': {
            enum6 = 7;
            break;
          }
          case 'would-block': {
            enum6 = 8;
            break;
          }
          case 'invalid-state': {
            enum6 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum6 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum6 = 11;
            break;
          }
          case 'address-in-use': {
            enum6 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum6 = 13;
            break;
          }
          case 'connection-refused': {
            enum6 = 14;
            break;
          }
          case 'connection-reset': {
            enum6 = 15;
            break;
          }
          case 'connection-aborted': {
            enum6 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum6 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum6 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum6 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum6 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val6}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum6, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-connect"][Instruction::Return]', {
      funcName: '[method]tcp-socket.finish-connect',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_154_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.shutdown',
    moduleIdx: null,
  };
  
  
  function trampoline188(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let enum3;
    switch (arg1) {
      case 0: {
        enum3 = 'receive';
        break;
      }
      case 1: {
        enum3 = 'send';
        break;
      }
      case 2: {
        enum3 = 'both';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for ShutdownType');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.shutdown"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.shutdown?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'shutdown',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.shutdown(enum3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'access-denied': {
            enum4 = 1;
            break;
          }
          case 'not-supported': {
            enum4 = 2;
            break;
          }
          case 'invalid-argument': {
            enum4 = 3;
            break;
          }
          case 'out-of-memory': {
            enum4 = 4;
            break;
          }
          case 'timeout': {
            enum4 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum4 = 6;
            break;
          }
          case 'not-in-progress': {
            enum4 = 7;
            break;
          }
          case 'would-block': {
            enum4 = 8;
            break;
          }
          case 'invalid-state': {
            enum4 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum4 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum4 = 11;
            break;
          }
          case 'address-in-use': {
            enum4 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum4 = 13;
            break;
          }
          case 'connection-refused': {
            enum4 = 14;
            break;
          }
          case 'connection-reset': {
            enum4 = 15;
            break;
          }
          case 'connection-aborted': {
            enum4 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum4 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum4 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum4 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum4 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.shutdown"][Instruction::Return]', {
      funcName: '[method]tcp-socket.shutdown',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_155_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-arguments',
    moduleIdx: null,
  };
  
  
  function trampoline189(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getArguments?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getArguments',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getArguments();
    endCurrentTask(3);
    var vec1 = ret;
    var len1 = vec1.length;
    var result1 = realloc2(0, 0, 4, len1 * 8);
    for (let i = 0; i < vec1.length; i++) {
      const e = vec1[i];
      const base = result1 + i * 8;
      var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory1);
      var ptr0= encodeRes.ptr;
      var len0 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 4, len0, true);
      dataView(memory1).setUint32(base + 0, ptr0, true);
    }
    dataView(memory1).setUint32(arg0 + 4, len1, true);
    dataView(memory1).setUint32(arg0 + 0, result1, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"][Instruction::Return]', {
      funcName: 'get-arguments',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_156_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp-create-socket@0.2.3#create-tcp-socket',
    moduleIdx: null,
  };
  
  
  function trampoline190(arg0, arg1) {
    let enum0;
    switch (arg0) {
      case 0: {
        enum0 = 'ipv4';
        break;
      }
      case 1: {
        enum0 = 'ipv6';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for IpAddressFamily');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp-create-socket@0.2.3", function="create-tcp-socket"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = createTcpSocket?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'createTcpSocket',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  createTcpSocket(enum0)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    endCurrentTask(3);
    var variant3 = ret;
    switch (variant3.tag) {
      case 'ok': {
        const e = variant3.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof TcpSocket)) {
          throw new TypeError('Resource error: Not a valid "TcpSocket" resource.');
        }
        var handle1 = e[symbolRscHandle];
        if (!handle1) {
          const rep = e[symbolRscRep] || ++captureCnt12;
          captureTable12.set(rep, e);
          handle1 = rscTableCreateOwn(handleTable31, rep);
        }
        dataView(memory1).setInt32(arg1 + 4, handle1, true);
        break;
      }
      case 'err': {
        const e = variant3.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val2 = e;
        let enum2;
        switch (val2) {
          case 'unknown': {
            enum2 = 0;
            break;
          }
          case 'access-denied': {
            enum2 = 1;
            break;
          }
          case 'not-supported': {
            enum2 = 2;
            break;
          }
          case 'invalid-argument': {
            enum2 = 3;
            break;
          }
          case 'out-of-memory': {
            enum2 = 4;
            break;
          }
          case 'timeout': {
            enum2 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum2 = 6;
            break;
          }
          case 'not-in-progress': {
            enum2 = 7;
            break;
          }
          case 'would-block': {
            enum2 = 8;
            break;
          }
          case 'invalid-state': {
            enum2 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum2 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum2 = 11;
            break;
          }
          case 'address-in-use': {
            enum2 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum2 = 13;
            break;
          }
          case 'connection-refused': {
            enum2 = 14;
            break;
          }
          case 'connection-reset': {
            enum2 = 15;
            break;
          }
          case 'connection-aborted': {
            enum2 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum2 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum2 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum2 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum2 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val2}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum2, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp-create-socket@0.2.3", function="create-tcp-socket"][Instruction::Return]', {
      funcName: 'create-tcp-socket',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_157_metadata = {
    qualifiedImportFn: 'wasi:random/random@0.2.3#get-random-bytes',
    moduleIdx: null,
  };
  
  
  function trampoline191(arg0, arg1) {
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-bytes"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getRandomBytes?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getRandomBytes',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getRandomBytes(BigInt.asUintN(64, arg0));
    endCurrentTask(3);
    var val0 = ret;
    var len0 = val0.byteLength;
    var ptr0 = realloc2(0, 0, 1, len0 * 1);
    
    let valData0;
    const valLenBytes0 = len0 * 1;
    if (Array.isArray(val0)) {
      // Regular array likely containing numbers, write values to memory
      let offset = 0;
      const dv0 = new DataView(memory1.buffer);
      for (const v of val0) {
        dv0.setUint8(ptr0+ offset, v, true);
        offset += 1;
      }
    } else {
      // TypedArray / ArrayBuffer-like, direct copy
      valData0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, valLenBytes0);
      const out0 = new Uint8Array(memory1.buffer, ptr0,valLenBytes0);
      out0.set(valData0);
    }
    
    dataView(memory1).setUint32(arg1 + 4, len0, true);
    dataView(memory1).setUint32(arg1 + 0, ptr0, true);
    _debugLog('[iface="wasi:random/random@0.2.3", function="get-random-bytes"][Instruction::Return]', {
      funcName: 'get-random-bytes',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_158_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-environment',
    moduleIdx: null,
  };
  
  
  function trampoline192(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getEnvironment?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getEnvironment',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getEnvironment();
    endCurrentTask(3);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc2(0, 0, 4, len3 * 16);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 16;var [tuple0_0, tuple0_1] = e;
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_0, realloc2, memory1);
      var ptr1= encodeRes.ptr;
      var len1 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 4, len1, true);
      dataView(memory1).setUint32(base + 0, ptr1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc2, memory1);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 12, len2, true);
      dataView(memory1).setUint32(base + 8, ptr2, true);
    }
    dataView(memory1).setUint32(arg0 + 4, len3, true);
    dataView(memory1).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"][Instruction::Return]', {
      funcName: 'get-environment',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_159_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#initial-cwd',
    moduleIdx: null,
  };
  
  
  function trampoline193(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="initial-cwd"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = initialCwd?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'initialCwd',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  initialCwd();
    endCurrentTask(3);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory1).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory1).setInt8(arg0 + 0, 1, true);
      
      var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory1);
      var ptr0= encodeRes.ptr;
      var len0 = encodeRes.len;
      
      dataView(memory1).setUint32(arg0 + 8, len0, true);
      dataView(memory1).setUint32(arg0 + 4, ptr0, true);
    }
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="initial-cwd"][Instruction::Return]', {
      funcName: 'initial-cwd',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_160_metadata = {
    qualifiedImportFn: 'wasi:io/error@0.2.3#[method]error.to-debug-string',
    moduleIdx: null,
  };
  
  
  function trampoline194(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable33[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable0.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Error$1.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/error@0.2.3", function="[method]error.to-debug-string"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.toDebugString?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'toDebugString',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  rsc0.toDebugString();
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    
    var encodeRes = _utf8AllocateAndEncode(ret, realloc2, memory1);
    var ptr3= encodeRes.ptr;
    var len3 = encodeRes.len;
    
    dataView(memory1).setUint32(arg1 + 4, len3, true);
    dataView(memory1).setUint32(arg1 + 0, ptr3, true);
    _debugLog('[iface="wasi:io/error@0.2.3", function="[method]error.to-debug-string"][Instruction::Return]', {
      funcName: '[method]error.to-debug-string',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_161_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.skip',
    moduleIdx: null,
  };
  
  
  function trampoline195(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable29[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.skip"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.skip?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'skip',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.skip(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        dataView(memory1).setBigInt64(arg2 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory1).setInt8(arg2 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 12, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.skip"][Instruction::Return]', {
      funcName: '[method]input-stream.skip',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_162_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.blocking-skip',
    moduleIdx: null,
  };
  
  
  function trampoline196(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable29[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-skip"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingSkip?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'blockingSkip',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingSkip(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        dataView(memory1).setBigInt64(arg2 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory1).setInt8(arg2 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 12, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-skip"][Instruction::Return]', {
      funcName: '[method]input-stream.blocking-skip',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_163_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-write-and-flush',
    moduleIdx: null,
  };
  
  
  function trampoline197(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = new Uint8Array(memory1.buffer.slice(ptr3, ptr3 + len3 * 1));
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-and-flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingWriteAndFlush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'blockingWriteAndFlush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingWriteAndFlush(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory1).setInt8(arg3 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg3 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg3 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-and-flush"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-write-and-flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_164_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.flush',
    moduleIdx: null,
  };
  
  
  function trampoline198(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.flush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'flush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.flush()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory1).setInt8(arg1 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg1 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg1 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.flush"][Instruction::Return]', {
      funcName: '[method]output-stream.flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_165_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.write-zeroes',
    moduleIdx: null,
  };
  
  
  function trampoline199(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write-zeroes"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.writeZeroes?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'writeZeroes',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.writeZeroes(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory1).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.write-zeroes"][Instruction::Return]', {
      funcName: '[method]output-stream.write-zeroes',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_166_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-write-zeroes-and-flush',
    moduleIdx: null,
  };
  
  
  function trampoline200(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-zeroes-and-flush"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingWriteZeroesAndFlush?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'blockingWriteZeroesAndFlush',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingWriteZeroesAndFlush(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant4 = e;
        switch (variant4.tag) {
          case 'last-operation-failed': {
            const e = variant4.val;
            dataView(memory1).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle3 = e[symbolRscHandle];
            if (!handle3) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle3 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 8, handle3, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-write-zeroes-and-flush"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-write-zeroes-and-flush',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_167_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.splice',
    moduleIdx: null,
  };
  
  
  function trampoline201(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable29[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable2.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.splice"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.splice?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'splice',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.splice(rsc3, BigInt.asUintN(64, arg2))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        dataView(memory1).setBigInt64(arg3 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'last-operation-failed': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg3 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle6 = e[symbolRscHandle];
            if (!handle6) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle6 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg3 + 12, handle6, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg3 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.splice"][Instruction::Return]', {
      funcName: '[method]output-stream.splice',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_168_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]output-stream.blocking-splice',
    moduleIdx: null,
  };
  
  
  function trampoline202(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable30[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable3.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable29[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable2.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-splice"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingSplice?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'blockingSplice',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingSplice(rsc3, BigInt.asUintN(64, arg2))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        dataView(memory1).setBigInt64(arg3 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'last-operation-failed': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg3 + 8, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle6 = e[symbolRscHandle];
            if (!handle6) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle6 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg3 + 12, handle6, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg3 + 8, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]output-stream.blocking-splice"][Instruction::Return]', {
      funcName: '[method]output-stream.blocking-splice',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_169_metadata = {
    qualifiedImportFn: 'wasi:cli/terminal-stdin@0.2.3#get-terminal-stdin',
    moduleIdx: null,
  };
  
  const handleTable42 = [T_FLAG, 0];
  handleTables[42] = handleTable42;
  
  function trampoline203(arg0) {
    _debugLog('[iface="wasi:cli/terminal-stdin@0.2.3", function="get-terminal-stdin"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getTerminalStdin?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getTerminalStdin',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getTerminalStdin();
    endCurrentTask(3);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory1).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory1).setInt8(arg0 + 0, 1, true);
      if (!(e instanceof TerminalInput)) {
        throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');
      }
      var handle0 = e[symbolRscHandle];
      if (!handle0) {
        const rep = e[symbolRscRep] || ++captureCnt4;
        captureTable4.set(rep, e);
        handle0 = rscTableCreateOwn(handleTable42, rep);
      }
      dataView(memory1).setInt32(arg0 + 4, handle0, true);
    }
    _debugLog('[iface="wasi:cli/terminal-stdin@0.2.3", function="get-terminal-stdin"][Instruction::Return]', {
      funcName: 'get-terminal-stdin',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_170_metadata = {
    qualifiedImportFn: 'wasi:cli/terminal-stdout@0.2.3#get-terminal-stdout',
    moduleIdx: null,
  };
  
  const handleTable43 = [T_FLAG, 0];
  handleTables[43] = handleTable43;
  
  function trampoline204(arg0) {
    _debugLog('[iface="wasi:cli/terminal-stdout@0.2.3", function="get-terminal-stdout"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getTerminalStdout?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getTerminalStdout',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getTerminalStdout();
    endCurrentTask(3);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory1).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory1).setInt8(arg0 + 0, 1, true);
      if (!(e instanceof TerminalOutput)) {
        throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');
      }
      var handle0 = e[symbolRscHandle];
      if (!handle0) {
        const rep = e[symbolRscRep] || ++captureCnt5;
        captureTable5.set(rep, e);
        handle0 = rscTableCreateOwn(handleTable43, rep);
      }
      dataView(memory1).setInt32(arg0 + 4, handle0, true);
    }
    _debugLog('[iface="wasi:cli/terminal-stdout@0.2.3", function="get-terminal-stdout"][Instruction::Return]', {
      funcName: 'get-terminal-stdout',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_171_metadata = {
    qualifiedImportFn: 'wasi:cli/terminal-stderr@0.2.3#get-terminal-stderr',
    moduleIdx: null,
  };
  
  
  function trampoline205(arg0) {
    _debugLog('[iface="wasi:cli/terminal-stderr@0.2.3", function="get-terminal-stderr"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getTerminalStderr?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getTerminalStderr',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getTerminalStderr();
    endCurrentTask(3);
    var variant1 = ret;
    if (variant1 === null || variant1=== undefined) {
      dataView(memory1).setInt8(arg0 + 0, 0, true);
    } else {
      const e = variant1;
      dataView(memory1).setInt8(arg0 + 0, 1, true);
      if (!(e instanceof TerminalOutput)) {
        throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');
      }
      var handle0 = e[symbolRscHandle];
      if (!handle0) {
        const rep = e[symbolRscRep] || ++captureCnt5;
        captureTable5.set(rep, e);
        handle0 = rscTableCreateOwn(handleTable43, rep);
      }
      dataView(memory1).setInt32(arg0 + 4, handle0, true);
    }
    _debugLog('[iface="wasi:cli/terminal-stderr@0.2.3", function="get-terminal-stderr"][Instruction::Return]', {
      funcName: 'get-terminal-stderr',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_172_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#filesystem-error-code',
    moduleIdx: null,
  };
  
  
  function trampoline206(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable33[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable0.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Error$1.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="filesystem-error-code"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = filesystemErrorCode?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'filesystemErrorCode',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  filesystemErrorCode(rsc0);
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    if (variant4 === null || variant4=== undefined) {
      dataView(memory1).setInt8(arg1 + 0, 0, true);
    } else {
      const e = variant4;
      dataView(memory1).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'access': {
          enum3 = 0;
          break;
        }
        case 'would-block': {
          enum3 = 1;
          break;
        }
        case 'already': {
          enum3 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum3 = 3;
          break;
        }
        case 'busy': {
          enum3 = 4;
          break;
        }
        case 'deadlock': {
          enum3 = 5;
          break;
        }
        case 'quota': {
          enum3 = 6;
          break;
        }
        case 'exist': {
          enum3 = 7;
          break;
        }
        case 'file-too-large': {
          enum3 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum3 = 9;
          break;
        }
        case 'in-progress': {
          enum3 = 10;
          break;
        }
        case 'interrupted': {
          enum3 = 11;
          break;
        }
        case 'invalid': {
          enum3 = 12;
          break;
        }
        case 'io': {
          enum3 = 13;
          break;
        }
        case 'is-directory': {
          enum3 = 14;
          break;
        }
        case 'loop': {
          enum3 = 15;
          break;
        }
        case 'too-many-links': {
          enum3 = 16;
          break;
        }
        case 'message-size': {
          enum3 = 17;
          break;
        }
        case 'name-too-long': {
          enum3 = 18;
          break;
        }
        case 'no-device': {
          enum3 = 19;
          break;
        }
        case 'no-entry': {
          enum3 = 20;
          break;
        }
        case 'no-lock': {
          enum3 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum3 = 22;
          break;
        }
        case 'insufficient-space': {
          enum3 = 23;
          break;
        }
        case 'not-directory': {
          enum3 = 24;
          break;
        }
        case 'not-empty': {
          enum3 = 25;
          break;
        }
        case 'not-recoverable': {
          enum3 = 26;
          break;
        }
        case 'unsupported': {
          enum3 = 27;
          break;
        }
        case 'no-tty': {
          enum3 = 28;
          break;
        }
        case 'no-such-device': {
          enum3 = 29;
          break;
        }
        case 'overflow': {
          enum3 = 30;
          break;
        }
        case 'not-permitted': {
          enum3 = 31;
          break;
        }
        case 'pipe': {
          enum3 = 32;
          break;
        }
        case 'read-only': {
          enum3 = 33;
          break;
        }
        case 'invalid-seek': {
          enum3 = 34;
          break;
        }
        case 'text-file-busy': {
          enum3 = 35;
          break;
        }
        case 'cross-device': {
          enum3 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory1).setInt8(arg1 + 1, enum3, true);
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="filesystem-error-code"][Instruction::Return]', {
      funcName: 'filesystem-error-code',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_173_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.read-via-stream',
    moduleIdx: null,
  };
  
  
  function trampoline207(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readViaStream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'readViaStream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readViaStream(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        if (!(e instanceof InputStream)) {
          throw new TypeError('Resource error: Not a valid "InputStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt2;
          captureTable2.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable29, rep);
        }
        dataView(memory1).setInt32(arg2 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-via-stream"][Instruction::Return]', {
      funcName: '[method]descriptor.read-via-stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_174_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.write-via-stream',
    moduleIdx: null,
  };
  
  
  function trampoline208(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.writeViaStream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'writeViaStream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.writeViaStream(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        if (!(e instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable30, rep);
        }
        dataView(memory1).setInt32(arg2 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write-via-stream"][Instruction::Return]', {
      funcName: '[method]descriptor.write-via-stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_175_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.append-via-stream',
    moduleIdx: null,
  };
  
  
  function trampoline209(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.append-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.appendViaStream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'appendViaStream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.appendViaStream()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable30, rep);
        }
        dataView(memory1).setInt32(arg1 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.append-via-stream"][Instruction::Return]', {
      funcName: '[method]descriptor.append-via-stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_176_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.advise',
    moduleIdx: null,
  };
  
  
  function trampoline210(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let enum3;
    switch (arg3) {
      case 0: {
        enum3 = 'normal';
        break;
      }
      case 1: {
        enum3 = 'sequential';
        break;
      }
      case 2: {
        enum3 = 'random';
        break;
      }
      case 3: {
        enum3 = 'will-need';
        break;
      }
      case 4: {
        enum3 = 'dont-need';
        break;
      }
      case 5: {
        enum3 = 'no-reuse';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for Advice');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.advise"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.advise?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'advise',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.advise(BigInt.asUintN(64, arg1), BigInt.asUintN(64, arg2), enum3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg4 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg4 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg4 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.advise"][Instruction::Return]', {
      funcName: '[method]descriptor.advise',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_177_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.sync-data',
    moduleIdx: null,
  };
  
  
  function trampoline211(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync-data"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.syncData?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'syncData',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.syncData()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'access': {
            enum3 = 0;
            break;
          }
          case 'would-block': {
            enum3 = 1;
            break;
          }
          case 'already': {
            enum3 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum3 = 3;
            break;
          }
          case 'busy': {
            enum3 = 4;
            break;
          }
          case 'deadlock': {
            enum3 = 5;
            break;
          }
          case 'quota': {
            enum3 = 6;
            break;
          }
          case 'exist': {
            enum3 = 7;
            break;
          }
          case 'file-too-large': {
            enum3 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum3 = 9;
            break;
          }
          case 'in-progress': {
            enum3 = 10;
            break;
          }
          case 'interrupted': {
            enum3 = 11;
            break;
          }
          case 'invalid': {
            enum3 = 12;
            break;
          }
          case 'io': {
            enum3 = 13;
            break;
          }
          case 'is-directory': {
            enum3 = 14;
            break;
          }
          case 'loop': {
            enum3 = 15;
            break;
          }
          case 'too-many-links': {
            enum3 = 16;
            break;
          }
          case 'message-size': {
            enum3 = 17;
            break;
          }
          case 'name-too-long': {
            enum3 = 18;
            break;
          }
          case 'no-device': {
            enum3 = 19;
            break;
          }
          case 'no-entry': {
            enum3 = 20;
            break;
          }
          case 'no-lock': {
            enum3 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum3 = 22;
            break;
          }
          case 'insufficient-space': {
            enum3 = 23;
            break;
          }
          case 'not-directory': {
            enum3 = 24;
            break;
          }
          case 'not-empty': {
            enum3 = 25;
            break;
          }
          case 'not-recoverable': {
            enum3 = 26;
            break;
          }
          case 'unsupported': {
            enum3 = 27;
            break;
          }
          case 'no-tty': {
            enum3 = 28;
            break;
          }
          case 'no-such-device': {
            enum3 = 29;
            break;
          }
          case 'overflow': {
            enum3 = 30;
            break;
          }
          case 'not-permitted': {
            enum3 = 31;
            break;
          }
          case 'pipe': {
            enum3 = 32;
            break;
          }
          case 'read-only': {
            enum3 = 33;
            break;
          }
          case 'invalid-seek': {
            enum3 = 34;
            break;
          }
          case 'text-file-busy': {
            enum3 = 35;
            break;
          }
          case 'cross-device': {
            enum3 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync-data"][Instruction::Return]', {
      funcName: '[method]descriptor.sync-data',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_178_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.get-flags',
    moduleIdx: null,
  };
  
  
  function trampoline212(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-flags"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.getFlags?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getFlags',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.getFlags()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        let flags3 = 0;
        if (typeof e === 'object' && e !== null) {
          flags3 = Boolean(e.read) << 0 | Boolean(e.write) << 1 | Boolean(e.fileIntegritySync) << 2 | Boolean(e.dataIntegritySync) << 3 | Boolean(e.requestedWriteSync) << 4 | Boolean(e.mutateDirectory) << 5;
        } else if (e !== null && e!== undefined) {
          throw new TypeError('only an object, undefined or null can be converted to flags');
        }
        dataView(memory1).setInt8(arg1 + 1, flags3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-flags"][Instruction::Return]', {
      funcName: '[method]descriptor.get-flags',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_179_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.get-type',
    moduleIdx: null,
  };
  
  
  function trampoline213(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-type"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.getType?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getType',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.getType()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'block-device': {
            enum3 = 1;
            break;
          }
          case 'character-device': {
            enum3 = 2;
            break;
          }
          case 'directory': {
            enum3 = 3;
            break;
          }
          case 'fifo': {
            enum3 = 4;
            break;
          }
          case 'symbolic-link': {
            enum3 = 5;
            break;
          }
          case 'regular-file': {
            enum3 = 6;
            break;
          }
          case 'socket': {
            enum3 = 7;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.get-type"][Instruction::Return]', {
      funcName: '[method]descriptor.get-type',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_180_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.set-size',
    moduleIdx: null,
  };
  
  
  function trampoline214(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'access': {
            enum3 = 0;
            break;
          }
          case 'would-block': {
            enum3 = 1;
            break;
          }
          case 'already': {
            enum3 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum3 = 3;
            break;
          }
          case 'busy': {
            enum3 = 4;
            break;
          }
          case 'deadlock': {
            enum3 = 5;
            break;
          }
          case 'quota': {
            enum3 = 6;
            break;
          }
          case 'exist': {
            enum3 = 7;
            break;
          }
          case 'file-too-large': {
            enum3 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum3 = 9;
            break;
          }
          case 'in-progress': {
            enum3 = 10;
            break;
          }
          case 'interrupted': {
            enum3 = 11;
            break;
          }
          case 'invalid': {
            enum3 = 12;
            break;
          }
          case 'io': {
            enum3 = 13;
            break;
          }
          case 'is-directory': {
            enum3 = 14;
            break;
          }
          case 'loop': {
            enum3 = 15;
            break;
          }
          case 'too-many-links': {
            enum3 = 16;
            break;
          }
          case 'message-size': {
            enum3 = 17;
            break;
          }
          case 'name-too-long': {
            enum3 = 18;
            break;
          }
          case 'no-device': {
            enum3 = 19;
            break;
          }
          case 'no-entry': {
            enum3 = 20;
            break;
          }
          case 'no-lock': {
            enum3 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum3 = 22;
            break;
          }
          case 'insufficient-space': {
            enum3 = 23;
            break;
          }
          case 'not-directory': {
            enum3 = 24;
            break;
          }
          case 'not-empty': {
            enum3 = 25;
            break;
          }
          case 'not-recoverable': {
            enum3 = 26;
            break;
          }
          case 'unsupported': {
            enum3 = 27;
            break;
          }
          case 'no-tty': {
            enum3 = 28;
            break;
          }
          case 'no-such-device': {
            enum3 = 29;
            break;
          }
          case 'overflow': {
            enum3 = 30;
            break;
          }
          case 'not-permitted': {
            enum3 = 31;
            break;
          }
          case 'pipe': {
            enum3 = 32;
            break;
          }
          case 'read-only': {
            enum3 = 33;
            break;
          }
          case 'invalid-seek': {
            enum3 = 34;
            break;
          }
          case 'text-file-busy': {
            enum3 = 35;
            break;
          }
          case 'cross-device': {
            enum3 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-size"][Instruction::Return]', {
      funcName: '[method]descriptor.set-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_181_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.set-times',
    moduleIdx: null,
  };
  
  
  function trampoline215(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let variant3;
    switch (arg1) {
      case 0: {
        variant3= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant3= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant3= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg2),
            nanoseconds: arg3 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    let variant4;
    switch (arg4) {
      case 0: {
        variant4= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant4= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant4= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg5),
            nanoseconds: arg6 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setTimes?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setTimes',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setTimes(variant3, variant4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg7 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg7 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg7 + 1, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times"][Instruction::Return]', {
      funcName: '[method]descriptor.set-times',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_182_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.read',
    moduleIdx: null,
  };
  
  
  function trampoline216(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.read?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'read',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1), BigInt.asUintN(64, arg2))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        var [tuple3_0, tuple3_1] = e;
        var val4 = tuple3_0;
        var len4 = val4.byteLength;
        var ptr4 = realloc2(0, 0, 1, len4 * 1);
        
        let valData4;
        const valLenBytes4 = len4 * 1;
        if (Array.isArray(val4)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv4 = new DataView(memory1.buffer);
          for (const v of val4) {
            dv4.setUint8(ptr4+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, valLenBytes4);
          const out4 = new Uint8Array(memory1.buffer, ptr4,valLenBytes4);
          out4.set(valData4);
        }
        
        dataView(memory1).setUint32(arg3 + 8, len4, true);
        dataView(memory1).setUint32(arg3 + 4, ptr4, true);
        dataView(memory1).setInt8(arg3 + 12, tuple3_1 ? 1 : 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg3 + 4, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read"][Instruction::Return]', {
      funcName: '[method]descriptor.read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_183_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.write',
    moduleIdx: null,
  };
  
  
  function trampoline217(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = new Uint8Array(memory1.buffer.slice(ptr3, ptr3 + len3 * 1));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.write?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'write',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.write(result3, BigInt.asUintN(64, arg3))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg4 + 0, 0, true);
        dataView(memory1).setBigInt64(arg4 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg4 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg4 + 8, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.write"][Instruction::Return]', {
      funcName: '[method]descriptor.write',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_184_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.read-directory',
    moduleIdx: null,
  };
  
  const handleTable35 = [T_FLAG, 0];
  handleTables[35] = handleTable35;
  
  function trampoline218(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-directory"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readDirectory?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'readDirectory',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readDirectory()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof DirectoryEntryStream)) {
          throw new TypeError('Resource error: Not a valid "DirectoryEntryStream" resource.');
        }
        var handle3 = e[symbolRscHandle];
        if (!handle3) {
          const rep = e[symbolRscRep] || ++captureCnt7;
          captureTable7.set(rep, e);
          handle3 = rscTableCreateOwn(handleTable35, rep);
        }
        dataView(memory1).setInt32(arg1 + 4, handle3, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.read-directory"][Instruction::Return]', {
      funcName: '[method]descriptor.read-directory',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_185_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.sync',
    moduleIdx: null,
  };
  
  
  function trampoline219(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.sync?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'sync',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.sync()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'access': {
            enum3 = 0;
            break;
          }
          case 'would-block': {
            enum3 = 1;
            break;
          }
          case 'already': {
            enum3 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum3 = 3;
            break;
          }
          case 'busy': {
            enum3 = 4;
            break;
          }
          case 'deadlock': {
            enum3 = 5;
            break;
          }
          case 'quota': {
            enum3 = 6;
            break;
          }
          case 'exist': {
            enum3 = 7;
            break;
          }
          case 'file-too-large': {
            enum3 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum3 = 9;
            break;
          }
          case 'in-progress': {
            enum3 = 10;
            break;
          }
          case 'interrupted': {
            enum3 = 11;
            break;
          }
          case 'invalid': {
            enum3 = 12;
            break;
          }
          case 'io': {
            enum3 = 13;
            break;
          }
          case 'is-directory': {
            enum3 = 14;
            break;
          }
          case 'loop': {
            enum3 = 15;
            break;
          }
          case 'too-many-links': {
            enum3 = 16;
            break;
          }
          case 'message-size': {
            enum3 = 17;
            break;
          }
          case 'name-too-long': {
            enum3 = 18;
            break;
          }
          case 'no-device': {
            enum3 = 19;
            break;
          }
          case 'no-entry': {
            enum3 = 20;
            break;
          }
          case 'no-lock': {
            enum3 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum3 = 22;
            break;
          }
          case 'insufficient-space': {
            enum3 = 23;
            break;
          }
          case 'not-directory': {
            enum3 = 24;
            break;
          }
          case 'not-empty': {
            enum3 = 25;
            break;
          }
          case 'not-recoverable': {
            enum3 = 26;
            break;
          }
          case 'unsupported': {
            enum3 = 27;
            break;
          }
          case 'no-tty': {
            enum3 = 28;
            break;
          }
          case 'no-such-device': {
            enum3 = 29;
            break;
          }
          case 'overflow': {
            enum3 = 30;
            break;
          }
          case 'not-permitted': {
            enum3 = 31;
            break;
          }
          case 'pipe': {
            enum3 = 32;
            break;
          }
          case 'read-only': {
            enum3 = 33;
            break;
          }
          case 'invalid-seek': {
            enum3 = 34;
            break;
          }
          case 'text-file-busy': {
            enum3 = 35;
            break;
          }
          case 'cross-device': {
            enum3 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.sync"][Instruction::Return]', {
      funcName: '[method]descriptor.sync',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_186_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.create-directory-at',
    moduleIdx: null,
  };
  
  
  function trampoline220(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.create-directory-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.createDirectoryAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'createDirectoryAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.createDirectoryAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg3 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.create-directory-at"][Instruction::Return]', {
      funcName: '[method]descriptor.create-directory-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_187_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.stat',
    moduleIdx: null,
  };
  
  
  function trampoline221(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.stat?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'stat',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.stat()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant12 = ret;
    switch (variant12.tag) {
      case 'ok': {
        const e = variant12.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var {type: v3_0, linkCount: v3_1, size: v3_2, dataAccessTimestamp: v3_3, dataModificationTimestamp: v3_4, statusChangeTimestamp: v3_5 } = e;
        var val4 = v3_0;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'block-device': {
            enum4 = 1;
            break;
          }
          case 'character-device': {
            enum4 = 2;
            break;
          }
          case 'directory': {
            enum4 = 3;
            break;
          }
          case 'fifo': {
            enum4 = 4;
            break;
          }
          case 'symbolic-link': {
            enum4 = 5;
            break;
          }
          case 'regular-file': {
            enum4 = 6;
            break;
          }
          case 'socket': {
            enum4 = 7;
            break;
          }
          default: {
            if ((v3_0) instanceof Error) {
              console.error(v3_0);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum4, true);
        dataView(memory1).setBigInt64(arg1 + 16, toUint64(v3_1), true);
        dataView(memory1).setBigInt64(arg1 + 24, toUint64(v3_2), true);
        var variant6 = v3_3;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory1).setInt8(arg1 + 32, 0, true);
        } else {
          const e = variant6;
          dataView(memory1).setInt8(arg1 + 32, 1, true);
          var {seconds: v5_0, nanoseconds: v5_1 } = e;
          dataView(memory1).setBigInt64(arg1 + 40, toUint64(v5_0), true);
          dataView(memory1).setInt32(arg1 + 48, toUint32(v5_1), true);
        }
        var variant8 = v3_4;
        if (variant8 === null || variant8=== undefined) {
          dataView(memory1).setInt8(arg1 + 56, 0, true);
        } else {
          const e = variant8;
          dataView(memory1).setInt8(arg1 + 56, 1, true);
          var {seconds: v7_0, nanoseconds: v7_1 } = e;
          dataView(memory1).setBigInt64(arg1 + 64, toUint64(v7_0), true);
          dataView(memory1).setInt32(arg1 + 72, toUint32(v7_1), true);
        }
        var variant10 = v3_5;
        if (variant10 === null || variant10=== undefined) {
          dataView(memory1).setInt8(arg1 + 80, 0, true);
        } else {
          const e = variant10;
          dataView(memory1).setInt8(arg1 + 80, 1, true);
          var {seconds: v9_0, nanoseconds: v9_1 } = e;
          dataView(memory1).setBigInt64(arg1 + 88, toUint64(v9_0), true);
          dataView(memory1).setInt32(arg1 + 96, toUint32(v9_1), true);
        }
        break;
      }
      case 'err': {
        const e = variant12.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val11 = e;
        let enum11;
        switch (val11) {
          case 'access': {
            enum11 = 0;
            break;
          }
          case 'would-block': {
            enum11 = 1;
            break;
          }
          case 'already': {
            enum11 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum11 = 3;
            break;
          }
          case 'busy': {
            enum11 = 4;
            break;
          }
          case 'deadlock': {
            enum11 = 5;
            break;
          }
          case 'quota': {
            enum11 = 6;
            break;
          }
          case 'exist': {
            enum11 = 7;
            break;
          }
          case 'file-too-large': {
            enum11 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum11 = 9;
            break;
          }
          case 'in-progress': {
            enum11 = 10;
            break;
          }
          case 'interrupted': {
            enum11 = 11;
            break;
          }
          case 'invalid': {
            enum11 = 12;
            break;
          }
          case 'io': {
            enum11 = 13;
            break;
          }
          case 'is-directory': {
            enum11 = 14;
            break;
          }
          case 'loop': {
            enum11 = 15;
            break;
          }
          case 'too-many-links': {
            enum11 = 16;
            break;
          }
          case 'message-size': {
            enum11 = 17;
            break;
          }
          case 'name-too-long': {
            enum11 = 18;
            break;
          }
          case 'no-device': {
            enum11 = 19;
            break;
          }
          case 'no-entry': {
            enum11 = 20;
            break;
          }
          case 'no-lock': {
            enum11 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum11 = 22;
            break;
          }
          case 'insufficient-space': {
            enum11 = 23;
            break;
          }
          case 'not-directory': {
            enum11 = 24;
            break;
          }
          case 'not-empty': {
            enum11 = 25;
            break;
          }
          case 'not-recoverable': {
            enum11 = 26;
            break;
          }
          case 'unsupported': {
            enum11 = 27;
            break;
          }
          case 'no-tty': {
            enum11 = 28;
            break;
          }
          case 'no-such-device': {
            enum11 = 29;
            break;
          }
          case 'overflow': {
            enum11 = 30;
            break;
          }
          case 'not-permitted': {
            enum11 = 31;
            break;
          }
          case 'pipe': {
            enum11 = 32;
            break;
          }
          case 'read-only': {
            enum11 = 33;
            break;
          }
          case 'invalid-seek': {
            enum11 = 34;
            break;
          }
          case 'text-file-busy': {
            enum11 = 35;
            break;
          }
          case 'cross-device': {
            enum11 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val11}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum11, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat"][Instruction::Return]', {
      funcName: '[method]descriptor.stat',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_188_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.stat-at',
    moduleIdx: null,
  };
  
  
  function trampoline222(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr4, len4));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.statAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'statAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.statAt(flags3, result4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant14 = ret;
    switch (variant14.tag) {
      case 'ok': {
        const e = variant14.val;
        dataView(memory1).setInt8(arg4 + 0, 0, true);
        var {type: v5_0, linkCount: v5_1, size: v5_2, dataAccessTimestamp: v5_3, dataModificationTimestamp: v5_4, statusChangeTimestamp: v5_5 } = e;
        var val6 = v5_0;
        let enum6;
        switch (val6) {
          case 'unknown': {
            enum6 = 0;
            break;
          }
          case 'block-device': {
            enum6 = 1;
            break;
          }
          case 'character-device': {
            enum6 = 2;
            break;
          }
          case 'directory': {
            enum6 = 3;
            break;
          }
          case 'fifo': {
            enum6 = 4;
            break;
          }
          case 'symbolic-link': {
            enum6 = 5;
            break;
          }
          case 'regular-file': {
            enum6 = 6;
            break;
          }
          case 'socket': {
            enum6 = 7;
            break;
          }
          default: {
            if ((v5_0) instanceof Error) {
              console.error(v5_0);
            }
            
            throw new TypeError(`"${val6}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory1).setInt8(arg4 + 8, enum6, true);
        dataView(memory1).setBigInt64(arg4 + 16, toUint64(v5_1), true);
        dataView(memory1).setBigInt64(arg4 + 24, toUint64(v5_2), true);
        var variant8 = v5_3;
        if (variant8 === null || variant8=== undefined) {
          dataView(memory1).setInt8(arg4 + 32, 0, true);
        } else {
          const e = variant8;
          dataView(memory1).setInt8(arg4 + 32, 1, true);
          var {seconds: v7_0, nanoseconds: v7_1 } = e;
          dataView(memory1).setBigInt64(arg4 + 40, toUint64(v7_0), true);
          dataView(memory1).setInt32(arg4 + 48, toUint32(v7_1), true);
        }
        var variant10 = v5_4;
        if (variant10 === null || variant10=== undefined) {
          dataView(memory1).setInt8(arg4 + 56, 0, true);
        } else {
          const e = variant10;
          dataView(memory1).setInt8(arg4 + 56, 1, true);
          var {seconds: v9_0, nanoseconds: v9_1 } = e;
          dataView(memory1).setBigInt64(arg4 + 64, toUint64(v9_0), true);
          dataView(memory1).setInt32(arg4 + 72, toUint32(v9_1), true);
        }
        var variant12 = v5_5;
        if (variant12 === null || variant12=== undefined) {
          dataView(memory1).setInt8(arg4 + 80, 0, true);
        } else {
          const e = variant12;
          dataView(memory1).setInt8(arg4 + 80, 1, true);
          var {seconds: v11_0, nanoseconds: v11_1 } = e;
          dataView(memory1).setBigInt64(arg4 + 88, toUint64(v11_0), true);
          dataView(memory1).setInt32(arg4 + 96, toUint32(v11_1), true);
        }
        break;
      }
      case 'err': {
        const e = variant14.val;
        dataView(memory1).setInt8(arg4 + 0, 1, true);
        var val13 = e;
        let enum13;
        switch (val13) {
          case 'access': {
            enum13 = 0;
            break;
          }
          case 'would-block': {
            enum13 = 1;
            break;
          }
          case 'already': {
            enum13 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum13 = 3;
            break;
          }
          case 'busy': {
            enum13 = 4;
            break;
          }
          case 'deadlock': {
            enum13 = 5;
            break;
          }
          case 'quota': {
            enum13 = 6;
            break;
          }
          case 'exist': {
            enum13 = 7;
            break;
          }
          case 'file-too-large': {
            enum13 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum13 = 9;
            break;
          }
          case 'in-progress': {
            enum13 = 10;
            break;
          }
          case 'interrupted': {
            enum13 = 11;
            break;
          }
          case 'invalid': {
            enum13 = 12;
            break;
          }
          case 'io': {
            enum13 = 13;
            break;
          }
          case 'is-directory': {
            enum13 = 14;
            break;
          }
          case 'loop': {
            enum13 = 15;
            break;
          }
          case 'too-many-links': {
            enum13 = 16;
            break;
          }
          case 'message-size': {
            enum13 = 17;
            break;
          }
          case 'name-too-long': {
            enum13 = 18;
            break;
          }
          case 'no-device': {
            enum13 = 19;
            break;
          }
          case 'no-entry': {
            enum13 = 20;
            break;
          }
          case 'no-lock': {
            enum13 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum13 = 22;
            break;
          }
          case 'insufficient-space': {
            enum13 = 23;
            break;
          }
          case 'not-directory': {
            enum13 = 24;
            break;
          }
          case 'not-empty': {
            enum13 = 25;
            break;
          }
          case 'not-recoverable': {
            enum13 = 26;
            break;
          }
          case 'unsupported': {
            enum13 = 27;
            break;
          }
          case 'no-tty': {
            enum13 = 28;
            break;
          }
          case 'no-such-device': {
            enum13 = 29;
            break;
          }
          case 'overflow': {
            enum13 = 30;
            break;
          }
          case 'not-permitted': {
            enum13 = 31;
            break;
          }
          case 'pipe': {
            enum13 = 32;
            break;
          }
          case 'read-only': {
            enum13 = 33;
            break;
          }
          case 'invalid-seek': {
            enum13 = 34;
            break;
          }
          case 'text-file-busy': {
            enum13 = 35;
            break;
          }
          case 'cross-device': {
            enum13 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val13}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg4 + 8, enum13, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.stat-at"][Instruction::Return]', {
      funcName: '[method]descriptor.stat-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_189_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.set-times-at',
    moduleIdx: null,
  };
  
  
  function trampoline223(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr4, len4));
    let variant5;
    switch (arg4) {
      case 0: {
        variant5= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant5= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant5= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg5),
            nanoseconds: arg6 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    let variant6;
    switch (arg7) {
      case 0: {
        variant6= {
          tag: 'no-change',
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'now',
        };
        break;
      }
      case 2: {
        variant6= {
          tag: 'timestamp',
          val: {
            seconds: BigInt.asUintN(64, arg8),
            nanoseconds: arg9 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for NewTimestamp');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setTimesAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setTimesAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setTimesAt(flags3, result4, variant5, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg10 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg10 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'access': {
            enum7 = 0;
            break;
          }
          case 'would-block': {
            enum7 = 1;
            break;
          }
          case 'already': {
            enum7 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum7 = 3;
            break;
          }
          case 'busy': {
            enum7 = 4;
            break;
          }
          case 'deadlock': {
            enum7 = 5;
            break;
          }
          case 'quota': {
            enum7 = 6;
            break;
          }
          case 'exist': {
            enum7 = 7;
            break;
          }
          case 'file-too-large': {
            enum7 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum7 = 9;
            break;
          }
          case 'in-progress': {
            enum7 = 10;
            break;
          }
          case 'interrupted': {
            enum7 = 11;
            break;
          }
          case 'invalid': {
            enum7 = 12;
            break;
          }
          case 'io': {
            enum7 = 13;
            break;
          }
          case 'is-directory': {
            enum7 = 14;
            break;
          }
          case 'loop': {
            enum7 = 15;
            break;
          }
          case 'too-many-links': {
            enum7 = 16;
            break;
          }
          case 'message-size': {
            enum7 = 17;
            break;
          }
          case 'name-too-long': {
            enum7 = 18;
            break;
          }
          case 'no-device': {
            enum7 = 19;
            break;
          }
          case 'no-entry': {
            enum7 = 20;
            break;
          }
          case 'no-lock': {
            enum7 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum7 = 22;
            break;
          }
          case 'insufficient-space': {
            enum7 = 23;
            break;
          }
          case 'not-directory': {
            enum7 = 24;
            break;
          }
          case 'not-empty': {
            enum7 = 25;
            break;
          }
          case 'not-recoverable': {
            enum7 = 26;
            break;
          }
          case 'unsupported': {
            enum7 = 27;
            break;
          }
          case 'no-tty': {
            enum7 = 28;
            break;
          }
          case 'no-such-device': {
            enum7 = 29;
            break;
          }
          case 'overflow': {
            enum7 = 30;
            break;
          }
          case 'not-permitted': {
            enum7 = 31;
            break;
          }
          case 'pipe': {
            enum7 = 32;
            break;
          }
          case 'read-only': {
            enum7 = 33;
            break;
          }
          case 'invalid-seek': {
            enum7 = 34;
            break;
          }
          case 'text-file-busy': {
            enum7 = 35;
            break;
          }
          case 'cross-device': {
            enum7 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg10 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.set-times-at"][Instruction::Return]', {
      funcName: '[method]descriptor.set-times-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_190_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.link-at',
    moduleIdx: null,
  };
  
  
  function trampoline224(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr4, len4));
    var handle6 = arg4;
    var rep7 = handleTable34[(handle6 << 1) + 1] & ~T_FLAG;
    var rsc5 = captureTable6.get(rep7);
    if (!rsc5) {
      rsc5 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc5, symbolRscHandle, { writable: true, value: handle6});
      Object.defineProperty(rsc5, symbolRscRep, { writable: true, value: rep7});
    }
    curResourceBorrows.push(rsc5);
    var ptr8 = arg5;
    var len8 = arg6;
    var result8 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr8, len8));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.link-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.linkAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'linkAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.linkAt(flags3, result4, rsc5, result8)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant10 = ret;
    switch (variant10.tag) {
      case 'ok': {
        const e = variant10.val;
        dataView(memory1).setInt8(arg7 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant10.val;
        dataView(memory1).setInt8(arg7 + 0, 1, true);
        var val9 = e;
        let enum9;
        switch (val9) {
          case 'access': {
            enum9 = 0;
            break;
          }
          case 'would-block': {
            enum9 = 1;
            break;
          }
          case 'already': {
            enum9 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum9 = 3;
            break;
          }
          case 'busy': {
            enum9 = 4;
            break;
          }
          case 'deadlock': {
            enum9 = 5;
            break;
          }
          case 'quota': {
            enum9 = 6;
            break;
          }
          case 'exist': {
            enum9 = 7;
            break;
          }
          case 'file-too-large': {
            enum9 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum9 = 9;
            break;
          }
          case 'in-progress': {
            enum9 = 10;
            break;
          }
          case 'interrupted': {
            enum9 = 11;
            break;
          }
          case 'invalid': {
            enum9 = 12;
            break;
          }
          case 'io': {
            enum9 = 13;
            break;
          }
          case 'is-directory': {
            enum9 = 14;
            break;
          }
          case 'loop': {
            enum9 = 15;
            break;
          }
          case 'too-many-links': {
            enum9 = 16;
            break;
          }
          case 'message-size': {
            enum9 = 17;
            break;
          }
          case 'name-too-long': {
            enum9 = 18;
            break;
          }
          case 'no-device': {
            enum9 = 19;
            break;
          }
          case 'no-entry': {
            enum9 = 20;
            break;
          }
          case 'no-lock': {
            enum9 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum9 = 22;
            break;
          }
          case 'insufficient-space': {
            enum9 = 23;
            break;
          }
          case 'not-directory': {
            enum9 = 24;
            break;
          }
          case 'not-empty': {
            enum9 = 25;
            break;
          }
          case 'not-recoverable': {
            enum9 = 26;
            break;
          }
          case 'unsupported': {
            enum9 = 27;
            break;
          }
          case 'no-tty': {
            enum9 = 28;
            break;
          }
          case 'no-such-device': {
            enum9 = 29;
            break;
          }
          case 'overflow': {
            enum9 = 30;
            break;
          }
          case 'not-permitted': {
            enum9 = 31;
            break;
          }
          case 'pipe': {
            enum9 = 32;
            break;
          }
          case 'read-only': {
            enum9 = 33;
            break;
          }
          case 'invalid-seek': {
            enum9 = 34;
            break;
          }
          case 'text-file-busy': {
            enum9 = 35;
            break;
          }
          case 'cross-device': {
            enum9 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val9}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg7 + 1, enum9, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.link-at"][Instruction::Return]', {
      funcName: '[method]descriptor.link-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_191_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.open-at',
    moduleIdx: null,
  };
  
  
  function trampoline225(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr4, len4));
    if ((arg4 & 4294967280) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags5 = {
      create: Boolean(arg4 & 1),
      directory: Boolean(arg4 & 2),
      exclusive: Boolean(arg4 & 4),
      truncate: Boolean(arg4 & 8),
    };
    if ((arg5 & 4294967232) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags6 = {
      read: Boolean(arg5 & 1),
      write: Boolean(arg5 & 2),
      fileIntegritySync: Boolean(arg5 & 4),
      dataIntegritySync: Boolean(arg5 & 8),
      requestedWriteSync: Boolean(arg5 & 16),
      mutateDirectory: Boolean(arg5 & 32),
    };
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.open-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.openAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'openAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.openAt(flags3, result4, flags5, flags6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg6 + 0, 0, true);
        if (!(e instanceof Descriptor)) {
          throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
        }
        var handle7 = e[symbolRscHandle];
        if (!handle7) {
          const rep = e[symbolRscRep] || ++captureCnt6;
          captureTable6.set(rep, e);
          handle7 = rscTableCreateOwn(handleTable34, rep);
        }
        dataView(memory1).setInt32(arg6 + 4, handle7, true);
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg6 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'access': {
            enum8 = 0;
            break;
          }
          case 'would-block': {
            enum8 = 1;
            break;
          }
          case 'already': {
            enum8 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum8 = 3;
            break;
          }
          case 'busy': {
            enum8 = 4;
            break;
          }
          case 'deadlock': {
            enum8 = 5;
            break;
          }
          case 'quota': {
            enum8 = 6;
            break;
          }
          case 'exist': {
            enum8 = 7;
            break;
          }
          case 'file-too-large': {
            enum8 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum8 = 9;
            break;
          }
          case 'in-progress': {
            enum8 = 10;
            break;
          }
          case 'interrupted': {
            enum8 = 11;
            break;
          }
          case 'invalid': {
            enum8 = 12;
            break;
          }
          case 'io': {
            enum8 = 13;
            break;
          }
          case 'is-directory': {
            enum8 = 14;
            break;
          }
          case 'loop': {
            enum8 = 15;
            break;
          }
          case 'too-many-links': {
            enum8 = 16;
            break;
          }
          case 'message-size': {
            enum8 = 17;
            break;
          }
          case 'name-too-long': {
            enum8 = 18;
            break;
          }
          case 'no-device': {
            enum8 = 19;
            break;
          }
          case 'no-entry': {
            enum8 = 20;
            break;
          }
          case 'no-lock': {
            enum8 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum8 = 22;
            break;
          }
          case 'insufficient-space': {
            enum8 = 23;
            break;
          }
          case 'not-directory': {
            enum8 = 24;
            break;
          }
          case 'not-empty': {
            enum8 = 25;
            break;
          }
          case 'not-recoverable': {
            enum8 = 26;
            break;
          }
          case 'unsupported': {
            enum8 = 27;
            break;
          }
          case 'no-tty': {
            enum8 = 28;
            break;
          }
          case 'no-such-device': {
            enum8 = 29;
            break;
          }
          case 'overflow': {
            enum8 = 30;
            break;
          }
          case 'not-permitted': {
            enum8 = 31;
            break;
          }
          case 'pipe': {
            enum8 = 32;
            break;
          }
          case 'read-only': {
            enum8 = 33;
            break;
          }
          case 'invalid-seek': {
            enum8 = 34;
            break;
          }
          case 'text-file-busy': {
            enum8 = 35;
            break;
          }
          case 'cross-device': {
            enum8 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg6 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.open-at"][Instruction::Return]', {
      funcName: '[method]descriptor.open-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_192_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.readlink-at',
    moduleIdx: null,
  };
  
  
  function trampoline226(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.readlink-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readlinkAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'readlinkAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readlinkAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        
        var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory1);
        var ptr4= encodeRes.ptr;
        var len4 = encodeRes.len;
        
        dataView(memory1).setUint32(arg3 + 8, len4, true);
        dataView(memory1).setUint32(arg3 + 4, ptr4, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg3 + 4, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.readlink-at"][Instruction::Return]', {
      funcName: '[method]descriptor.readlink-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_193_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.remove-directory-at',
    moduleIdx: null,
  };
  
  
  function trampoline227(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.remove-directory-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.removeDirectoryAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'removeDirectoryAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.removeDirectoryAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg3 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.remove-directory-at"][Instruction::Return]', {
      funcName: '[method]descriptor.remove-directory-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_194_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.rename-at',
    moduleIdx: null,
  };
  
  
  function trampoline228(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr3, len3));
    var handle5 = arg3;
    var rep6 = handleTable34[(handle5 << 1) + 1] & ~T_FLAG;
    var rsc4 = captureTable6.get(rep6);
    if (!rsc4) {
      rsc4 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
      Object.defineProperty(rsc4, symbolRscRep, { writable: true, value: rep6});
    }
    curResourceBorrows.push(rsc4);
    var ptr7 = arg4;
    var len7 = arg5;
    var result7 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr7, len7));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.rename-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.renameAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'renameAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.renameAt(result3, rsc4, result7)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg6 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg6 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'access': {
            enum8 = 0;
            break;
          }
          case 'would-block': {
            enum8 = 1;
            break;
          }
          case 'already': {
            enum8 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum8 = 3;
            break;
          }
          case 'busy': {
            enum8 = 4;
            break;
          }
          case 'deadlock': {
            enum8 = 5;
            break;
          }
          case 'quota': {
            enum8 = 6;
            break;
          }
          case 'exist': {
            enum8 = 7;
            break;
          }
          case 'file-too-large': {
            enum8 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum8 = 9;
            break;
          }
          case 'in-progress': {
            enum8 = 10;
            break;
          }
          case 'interrupted': {
            enum8 = 11;
            break;
          }
          case 'invalid': {
            enum8 = 12;
            break;
          }
          case 'io': {
            enum8 = 13;
            break;
          }
          case 'is-directory': {
            enum8 = 14;
            break;
          }
          case 'loop': {
            enum8 = 15;
            break;
          }
          case 'too-many-links': {
            enum8 = 16;
            break;
          }
          case 'message-size': {
            enum8 = 17;
            break;
          }
          case 'name-too-long': {
            enum8 = 18;
            break;
          }
          case 'no-device': {
            enum8 = 19;
            break;
          }
          case 'no-entry': {
            enum8 = 20;
            break;
          }
          case 'no-lock': {
            enum8 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum8 = 22;
            break;
          }
          case 'insufficient-space': {
            enum8 = 23;
            break;
          }
          case 'not-directory': {
            enum8 = 24;
            break;
          }
          case 'not-empty': {
            enum8 = 25;
            break;
          }
          case 'not-recoverable': {
            enum8 = 26;
            break;
          }
          case 'unsupported': {
            enum8 = 27;
            break;
          }
          case 'no-tty': {
            enum8 = 28;
            break;
          }
          case 'no-such-device': {
            enum8 = 29;
            break;
          }
          case 'overflow': {
            enum8 = 30;
            break;
          }
          case 'not-permitted': {
            enum8 = 31;
            break;
          }
          case 'pipe': {
            enum8 = 32;
            break;
          }
          case 'read-only': {
            enum8 = 33;
            break;
          }
          case 'invalid-seek': {
            enum8 = 34;
            break;
          }
          case 'text-file-busy': {
            enum8 = 35;
            break;
          }
          case 'cross-device': {
            enum8 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg6 + 1, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.rename-at"][Instruction::Return]', {
      funcName: '[method]descriptor.rename-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_195_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.symlink-at',
    moduleIdx: null,
  };
  
  
  function trampoline229(arg0, arg1, arg2, arg3, arg4, arg5) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr3, len3));
    var ptr4 = arg3;
    var len4 = arg4;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr4, len4));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.symlink-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.symlinkAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'symlinkAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.symlinkAt(result3, result4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg5 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg5 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'access': {
            enum5 = 0;
            break;
          }
          case 'would-block': {
            enum5 = 1;
            break;
          }
          case 'already': {
            enum5 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum5 = 3;
            break;
          }
          case 'busy': {
            enum5 = 4;
            break;
          }
          case 'deadlock': {
            enum5 = 5;
            break;
          }
          case 'quota': {
            enum5 = 6;
            break;
          }
          case 'exist': {
            enum5 = 7;
            break;
          }
          case 'file-too-large': {
            enum5 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum5 = 9;
            break;
          }
          case 'in-progress': {
            enum5 = 10;
            break;
          }
          case 'interrupted': {
            enum5 = 11;
            break;
          }
          case 'invalid': {
            enum5 = 12;
            break;
          }
          case 'io': {
            enum5 = 13;
            break;
          }
          case 'is-directory': {
            enum5 = 14;
            break;
          }
          case 'loop': {
            enum5 = 15;
            break;
          }
          case 'too-many-links': {
            enum5 = 16;
            break;
          }
          case 'message-size': {
            enum5 = 17;
            break;
          }
          case 'name-too-long': {
            enum5 = 18;
            break;
          }
          case 'no-device': {
            enum5 = 19;
            break;
          }
          case 'no-entry': {
            enum5 = 20;
            break;
          }
          case 'no-lock': {
            enum5 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum5 = 22;
            break;
          }
          case 'insufficient-space': {
            enum5 = 23;
            break;
          }
          case 'not-directory': {
            enum5 = 24;
            break;
          }
          case 'not-empty': {
            enum5 = 25;
            break;
          }
          case 'not-recoverable': {
            enum5 = 26;
            break;
          }
          case 'unsupported': {
            enum5 = 27;
            break;
          }
          case 'no-tty': {
            enum5 = 28;
            break;
          }
          case 'no-such-device': {
            enum5 = 29;
            break;
          }
          case 'overflow': {
            enum5 = 30;
            break;
          }
          case 'not-permitted': {
            enum5 = 31;
            break;
          }
          case 'pipe': {
            enum5 = 32;
            break;
          }
          case 'read-only': {
            enum5 = 33;
            break;
          }
          case 'invalid-seek': {
            enum5 = 34;
            break;
          }
          case 'text-file-busy': {
            enum5 = 35;
            break;
          }
          case 'cross-device': {
            enum5 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg5 + 1, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.symlink-at"][Instruction::Return]', {
      funcName: '[method]descriptor.symlink-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_196_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.unlink-file-at',
    moduleIdx: null,
  };
  
  
  function trampoline230(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr3, len3));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.unlink-file-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.unlinkFileAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'unlinkFileAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.unlinkFileAt(result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg3 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.unlink-file-at"][Instruction::Return]', {
      funcName: '[method]descriptor.unlink-file-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_197_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.metadata-hash',
    moduleIdx: null,
  };
  
  
  function trampoline231(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.metadataHash?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'metadataHash',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.metadataHash()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var {lower: v3_0, upper: v3_1 } = e;
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(v3_0), true);
        dataView(memory1).setBigInt64(arg1 + 16, toUint64(v3_1), true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'access': {
            enum4 = 0;
            break;
          }
          case 'would-block': {
            enum4 = 1;
            break;
          }
          case 'already': {
            enum4 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum4 = 3;
            break;
          }
          case 'busy': {
            enum4 = 4;
            break;
          }
          case 'deadlock': {
            enum4 = 5;
            break;
          }
          case 'quota': {
            enum4 = 6;
            break;
          }
          case 'exist': {
            enum4 = 7;
            break;
          }
          case 'file-too-large': {
            enum4 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum4 = 9;
            break;
          }
          case 'in-progress': {
            enum4 = 10;
            break;
          }
          case 'interrupted': {
            enum4 = 11;
            break;
          }
          case 'invalid': {
            enum4 = 12;
            break;
          }
          case 'io': {
            enum4 = 13;
            break;
          }
          case 'is-directory': {
            enum4 = 14;
            break;
          }
          case 'loop': {
            enum4 = 15;
            break;
          }
          case 'too-many-links': {
            enum4 = 16;
            break;
          }
          case 'message-size': {
            enum4 = 17;
            break;
          }
          case 'name-too-long': {
            enum4 = 18;
            break;
          }
          case 'no-device': {
            enum4 = 19;
            break;
          }
          case 'no-entry': {
            enum4 = 20;
            break;
          }
          case 'no-lock': {
            enum4 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum4 = 22;
            break;
          }
          case 'insufficient-space': {
            enum4 = 23;
            break;
          }
          case 'not-directory': {
            enum4 = 24;
            break;
          }
          case 'not-empty': {
            enum4 = 25;
            break;
          }
          case 'not-recoverable': {
            enum4 = 26;
            break;
          }
          case 'unsupported': {
            enum4 = 27;
            break;
          }
          case 'no-tty': {
            enum4 = 28;
            break;
          }
          case 'no-such-device': {
            enum4 = 29;
            break;
          }
          case 'overflow': {
            enum4 = 30;
            break;
          }
          case 'not-permitted': {
            enum4 = 31;
            break;
          }
          case 'pipe': {
            enum4 = 32;
            break;
          }
          case 'read-only': {
            enum4 = 33;
            break;
          }
          case 'invalid-seek': {
            enum4 = 34;
            break;
          }
          case 'text-file-busy': {
            enum4 = 35;
            break;
          }
          case 'cross-device': {
            enum4 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash"][Instruction::Return]', {
      funcName: '[method]descriptor.metadata-hash',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_198_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]descriptor.metadata-hash-at',
    moduleIdx: null,
  };
  
  
  function trampoline232(arg0, arg1, arg2, arg3, arg4) {
    var handle1 = arg0;
    var rep2 = handleTable34[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable6.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Descriptor.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    if ((arg1 & 4294967294) !== 0) {
      throw new TypeError('flags have extraneous bits set');
    }
    var flags3 = {
      symlinkFollow: Boolean(arg1 & 1),
    };
    var ptr4 = arg2;
    var len4 = arg3;
    var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr4, len4));
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash-at"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.metadataHashAt?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'metadataHashAt',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.metadataHashAt(flags3, result4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant7 = ret;
    switch (variant7.tag) {
      case 'ok': {
        const e = variant7.val;
        dataView(memory1).setInt8(arg4 + 0, 0, true);
        var {lower: v5_0, upper: v5_1 } = e;
        dataView(memory1).setBigInt64(arg4 + 8, toUint64(v5_0), true);
        dataView(memory1).setBigInt64(arg4 + 16, toUint64(v5_1), true);
        break;
      }
      case 'err': {
        const e = variant7.val;
        dataView(memory1).setInt8(arg4 + 0, 1, true);
        var val6 = e;
        let enum6;
        switch (val6) {
          case 'access': {
            enum6 = 0;
            break;
          }
          case 'would-block': {
            enum6 = 1;
            break;
          }
          case 'already': {
            enum6 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum6 = 3;
            break;
          }
          case 'busy': {
            enum6 = 4;
            break;
          }
          case 'deadlock': {
            enum6 = 5;
            break;
          }
          case 'quota': {
            enum6 = 6;
            break;
          }
          case 'exist': {
            enum6 = 7;
            break;
          }
          case 'file-too-large': {
            enum6 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum6 = 9;
            break;
          }
          case 'in-progress': {
            enum6 = 10;
            break;
          }
          case 'interrupted': {
            enum6 = 11;
            break;
          }
          case 'invalid': {
            enum6 = 12;
            break;
          }
          case 'io': {
            enum6 = 13;
            break;
          }
          case 'is-directory': {
            enum6 = 14;
            break;
          }
          case 'loop': {
            enum6 = 15;
            break;
          }
          case 'too-many-links': {
            enum6 = 16;
            break;
          }
          case 'message-size': {
            enum6 = 17;
            break;
          }
          case 'name-too-long': {
            enum6 = 18;
            break;
          }
          case 'no-device': {
            enum6 = 19;
            break;
          }
          case 'no-entry': {
            enum6 = 20;
            break;
          }
          case 'no-lock': {
            enum6 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum6 = 22;
            break;
          }
          case 'insufficient-space': {
            enum6 = 23;
            break;
          }
          case 'not-directory': {
            enum6 = 24;
            break;
          }
          case 'not-empty': {
            enum6 = 25;
            break;
          }
          case 'not-recoverable': {
            enum6 = 26;
            break;
          }
          case 'unsupported': {
            enum6 = 27;
            break;
          }
          case 'no-tty': {
            enum6 = 28;
            break;
          }
          case 'no-such-device': {
            enum6 = 29;
            break;
          }
          case 'overflow': {
            enum6 = 30;
            break;
          }
          case 'not-permitted': {
            enum6 = 31;
            break;
          }
          case 'pipe': {
            enum6 = 32;
            break;
          }
          case 'read-only': {
            enum6 = 33;
            break;
          }
          case 'invalid-seek': {
            enum6 = 34;
            break;
          }
          case 'text-file-busy': {
            enum6 = 35;
            break;
          }
          case 'cross-device': {
            enum6 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val6}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg4 + 8, enum6, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]descriptor.metadata-hash-at"][Instruction::Return]', {
      funcName: '[method]descriptor.metadata-hash-at',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_199_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]directory-entry-stream.read-directory-entry',
    moduleIdx: null,
  };
  
  
  function trampoline233(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable35[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable7.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(DirectoryEntryStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readDirectoryEntry?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'readDirectoryEntry',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readDirectoryEntry()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var variant6 = e;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory1).setInt8(arg1 + 4, 0, true);
        } else {
          const e = variant6;
          dataView(memory1).setInt8(arg1 + 4, 1, true);
          var {type: v3_0, name: v3_1 } = e;
          var val4 = v3_0;
          let enum4;
          switch (val4) {
            case 'unknown': {
              enum4 = 0;
              break;
            }
            case 'block-device': {
              enum4 = 1;
              break;
            }
            case 'character-device': {
              enum4 = 2;
              break;
            }
            case 'directory': {
              enum4 = 3;
              break;
            }
            case 'fifo': {
              enum4 = 4;
              break;
            }
            case 'symbolic-link': {
              enum4 = 5;
              break;
            }
            case 'regular-file': {
              enum4 = 6;
              break;
            }
            case 'socket': {
              enum4 = 7;
              break;
            }
            default: {
              if ((v3_0) instanceof Error) {
                console.error(v3_0);
              }
              
              throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
            }
          }
          dataView(memory1).setInt8(arg1 + 8, enum4, true);
          
          var encodeRes = _utf8AllocateAndEncode(v3_1, realloc2, memory1);
          var ptr5= encodeRes.ptr;
          var len5 = encodeRes.len;
          
          dataView(memory1).setUint32(arg1 + 16, len5, true);
          dataView(memory1).setUint32(arg1 + 12, ptr5, true);
        }
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'access': {
            enum7 = 0;
            break;
          }
          case 'would-block': {
            enum7 = 1;
            break;
          }
          case 'already': {
            enum7 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum7 = 3;
            break;
          }
          case 'busy': {
            enum7 = 4;
            break;
          }
          case 'deadlock': {
            enum7 = 5;
            break;
          }
          case 'quota': {
            enum7 = 6;
            break;
          }
          case 'exist': {
            enum7 = 7;
            break;
          }
          case 'file-too-large': {
            enum7 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum7 = 9;
            break;
          }
          case 'in-progress': {
            enum7 = 10;
            break;
          }
          case 'interrupted': {
            enum7 = 11;
            break;
          }
          case 'invalid': {
            enum7 = 12;
            break;
          }
          case 'io': {
            enum7 = 13;
            break;
          }
          case 'is-directory': {
            enum7 = 14;
            break;
          }
          case 'loop': {
            enum7 = 15;
            break;
          }
          case 'too-many-links': {
            enum7 = 16;
            break;
          }
          case 'message-size': {
            enum7 = 17;
            break;
          }
          case 'name-too-long': {
            enum7 = 18;
            break;
          }
          case 'no-device': {
            enum7 = 19;
            break;
          }
          case 'no-entry': {
            enum7 = 20;
            break;
          }
          case 'no-lock': {
            enum7 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum7 = 22;
            break;
          }
          case 'insufficient-space': {
            enum7 = 23;
            break;
          }
          case 'not-directory': {
            enum7 = 24;
            break;
          }
          case 'not-empty': {
            enum7 = 25;
            break;
          }
          case 'not-recoverable': {
            enum7 = 26;
            break;
          }
          case 'unsupported': {
            enum7 = 27;
            break;
          }
          case 'no-tty': {
            enum7 = 28;
            break;
          }
          case 'no-such-device': {
            enum7 = 29;
            break;
          }
          case 'overflow': {
            enum7 = 30;
            break;
          }
          case 'not-permitted': {
            enum7 = 31;
            break;
          }
          case 'pipe': {
            enum7 = 32;
            break;
          }
          case 'read-only': {
            enum7 = 33;
            break;
          }
          case 'invalid-seek': {
            enum7 = 34;
            break;
          }
          case 'text-file-busy': {
            enum7 = 35;
            break;
          }
          case 'cross-device': {
            enum7 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"][Instruction::Return]', {
      funcName: '[method]directory-entry-stream.read-directory-entry',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_200_metadata = {
    qualifiedImportFn: 'wasi:filesystem/preopens@0.2.3#get-directories',
    moduleIdx: null,
  };
  
  
  function trampoline234(arg0) {
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getDirectories?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getDirectories',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getDirectories();
    endCurrentTask(3);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc2(0, 0, 4, len3 * 12);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 12;var [tuple0_0, tuple0_1] = e;
      if (!(tuple0_0 instanceof Descriptor)) {
        throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
      }
      var handle1 = tuple0_0[symbolRscHandle];
      if (!handle1) {
        const rep = tuple0_0[symbolRscRep] || ++captureCnt6;
        captureTable6.set(rep, tuple0_0);
        handle1 = rscTableCreateOwn(handleTable34, rep);
      }
      dataView(memory1).setInt32(base + 0, handle1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc2, memory1);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 8, len2, true);
      dataView(memory1).setUint32(base + 4, ptr2, true);
    }
    dataView(memory1).setUint32(arg0 + 4, len3, true);
    dataView(memory1).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"][Instruction::Return]', {
      funcName: 'get-directories',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_201_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.start-bind',
    moduleIdx: null,
  };
  
  
  function trampoline235(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable32[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable8.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Network.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    let variant6;
    switch (arg2) {
      case 0: {
        variant6= {
          tag: 'ipv4',
          val: {
            port: clampGuest(arg3, 0, 65535),
            address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
          }
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'ipv6',
          val: {
            port: clampGuest(arg3, 0, 65535),
            flowInfo: arg4 >>> 0,
            address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
            scopeId: arg13 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for IpSocketAddress');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.start-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'startBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startBind(rsc3, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg14 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg14 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg14 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.start-bind"][Instruction::Return]', {
      funcName: '[method]udp-socket.start-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_202_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.finish-bind',
    moduleIdx: null,
  };
  
  
  function trampoline236(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.finish-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'finishBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishBind()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.finish-bind"][Instruction::Return]', {
      funcName: '[method]udp-socket.finish-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_203_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.stream',
    moduleIdx: null,
  };
  
  
  function trampoline237(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    let variant4;
    switch (arg1) {
      case 0: {
        variant4 = undefined;
        break;
      }
      case 1: {
        let variant3;
        switch (arg2) {
          case 0: {
            variant3= {
              tag: 'ipv4',
              val: {
                port: clampGuest(arg3, 0, 65535),
                address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
              }
            };
            break;
          }
          case 1: {
            variant3= {
              tag: 'ipv6',
              val: {
                port: clampGuest(arg3, 0, 65535),
                flowInfo: arg4 >>> 0,
                address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
                scopeId: arg13 >>> 0,
              }
            };
            break;
          }
          default: {
            throw new TypeError('invalid variant discriminant for IpSocketAddress');
          }
        }
        variant4 = variant3;
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for option');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.stream"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.stream?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'stream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.stream(variant4)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg14 + 0, 0, true);
        var [tuple5_0, tuple5_1] = e;
        if (!(tuple5_0 instanceof IncomingDatagramStream)) {
          throw new TypeError('Resource error: Not a valid "IncomingDatagramStream" resource.');
        }
        var handle6 = tuple5_0[symbolRscHandle];
        if (!handle6) {
          const rep = tuple5_0[symbolRscRep] || ++captureCnt10;
          captureTable10.set(rep, tuple5_0);
          handle6 = rscTableCreateOwn(handleTable37, rep);
        }
        dataView(memory1).setInt32(arg14 + 4, handle6, true);
        if (!(tuple5_1 instanceof OutgoingDatagramStream)) {
          throw new TypeError('Resource error: Not a valid "OutgoingDatagramStream" resource.');
        }
        var handle7 = tuple5_1[symbolRscHandle];
        if (!handle7) {
          const rep = tuple5_1[symbolRscRep] || ++captureCnt11;
          captureTable11.set(rep, tuple5_1);
          handle7 = rscTableCreateOwn(handleTable38, rep);
        }
        dataView(memory1).setInt32(arg14 + 8, handle7, true);
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg14 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg14 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.stream"][Instruction::Return]', {
      funcName: '[method]udp-socket.stream',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_204_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.local-address',
    moduleIdx: null,
  };
  
  
  function trampoline238(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.local-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.localAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'localAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.localAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory1).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory1).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory1).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory1).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory1).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory1).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory1).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory1).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory1).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory1).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory1).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory1).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory1).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory1).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.local-address"][Instruction::Return]', {
      funcName: '[method]udp-socket.local-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_205_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.remote-address',
    moduleIdx: null,
  };
  
  
  function trampoline239(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.remote-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.remoteAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'remoteAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.remoteAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory1).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory1).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory1).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory1).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory1).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory1).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory1).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory1).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory1).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory1).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory1).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory1).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory1).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory1).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.remote-address"][Instruction::Return]', {
      funcName: '[method]udp-socket.remote-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_206_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.unicast-hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline240(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.unicast-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.unicastHopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'unicastHopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.unicastHopLimit()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setInt8(arg1 + 1, toUint8(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.unicast-hop-limit"][Instruction::Return]', {
      funcName: '[method]udp-socket.unicast-hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_207_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.set-unicast-hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline241(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-unicast-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setUnicastHopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setUnicastHopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setUnicastHopLimit(clampGuest(arg1, 0, 255))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-unicast-hop-limit"][Instruction::Return]', {
      funcName: '[method]udp-socket.set-unicast-hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_208_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline242(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.receiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'receiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.receiveBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_209_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.set-receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline243(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setReceiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setReceiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setReceiveBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.set-receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_210_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline244(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.sendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'sendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.sendBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.send-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_211_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]udp-socket.set-send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline245(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable36[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable9.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(UdpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setSendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setSendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setSendBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]udp-socket.set-send-buffer-size"][Instruction::Return]', {
      funcName: '[method]udp-socket.set-send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_212_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]incoming-datagram-stream.receive',
    moduleIdx: null,
  };
  
  
  function trampoline246(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable37[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable10.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(IncomingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.receive"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.receive?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'receive',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.receive(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant12 = ret;
    switch (variant12.tag) {
      case 'ok': {
        const e = variant12.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        var vec10 = e;
        var len10 = vec10.length;
        var result10 = realloc2(0, 0, 4, len10 * 40);
        for (let i = 0; i < vec10.length; i++) {
          const e = vec10[i];
          const base = result10 + i * 40;var {data: v3_0, remoteAddress: v3_1 } = e;
          var val4 = v3_0;
          var len4 = val4.byteLength;
          var ptr4 = realloc2(0, 0, 1, len4 * 1);
          
          let valData4;
          const valLenBytes4 = len4 * 1;
          if (Array.isArray(val4)) {
            // Regular array likely containing numbers, write values to memory
            let offset = 0;
            const dv4 = new DataView(memory1.buffer);
            for (const v of val4) {
              dv4.setUint8(ptr4+ offset, v, true);
              offset += 1;
            }
          } else {
            // TypedArray / ArrayBuffer-like, direct copy
            valData4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, valLenBytes4);
            const out4 = new Uint8Array(memory1.buffer, ptr4,valLenBytes4);
            out4.set(valData4);
          }
          
          dataView(memory1).setUint32(base + 4, len4, true);
          dataView(memory1).setUint32(base + 0, ptr4, true);
          var variant9 = v3_1;
          switch (variant9.tag) {
            case 'ipv4': {
              const e = variant9.val;
              dataView(memory1).setInt8(base + 8, 0, true);
              var {port: v5_0, address: v5_1 } = e;
              dataView(memory1).setInt16(base + 12, toUint16(v5_0), true);
              var [tuple6_0, tuple6_1, tuple6_2, tuple6_3] = v5_1;
              dataView(memory1).setInt8(base + 14, toUint8(tuple6_0), true);
              dataView(memory1).setInt8(base + 15, toUint8(tuple6_1), true);
              dataView(memory1).setInt8(base + 16, toUint8(tuple6_2), true);
              dataView(memory1).setInt8(base + 17, toUint8(tuple6_3), true);
              break;
            }
            case 'ipv6': {
              const e = variant9.val;
              dataView(memory1).setInt8(base + 8, 1, true);
              var {port: v7_0, flowInfo: v7_1, address: v7_2, scopeId: v7_3 } = e;
              dataView(memory1).setInt16(base + 12, toUint16(v7_0), true);
              dataView(memory1).setInt32(base + 16, toUint32(v7_1), true);
              var [tuple8_0, tuple8_1, tuple8_2, tuple8_3, tuple8_4, tuple8_5, tuple8_6, tuple8_7] = v7_2;
              dataView(memory1).setInt16(base + 20, toUint16(tuple8_0), true);
              dataView(memory1).setInt16(base + 22, toUint16(tuple8_1), true);
              dataView(memory1).setInt16(base + 24, toUint16(tuple8_2), true);
              dataView(memory1).setInt16(base + 26, toUint16(tuple8_3), true);
              dataView(memory1).setInt16(base + 28, toUint16(tuple8_4), true);
              dataView(memory1).setInt16(base + 30, toUint16(tuple8_5), true);
              dataView(memory1).setInt16(base + 32, toUint16(tuple8_6), true);
              dataView(memory1).setInt16(base + 34, toUint16(tuple8_7), true);
              dataView(memory1).setInt32(base + 36, toUint32(v7_3), true);
              break;
            }
            default: {
              throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant9.tag)}\` (received \`${variant9}\`) specified for \`IpSocketAddress\``);
            }
          }
        }
        dataView(memory1).setUint32(arg2 + 8, len10, true);
        dataView(memory1).setUint32(arg2 + 4, result10, true);
        break;
      }
      case 'err': {
        const e = variant12.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val11 = e;
        let enum11;
        switch (val11) {
          case 'unknown': {
            enum11 = 0;
            break;
          }
          case 'access-denied': {
            enum11 = 1;
            break;
          }
          case 'not-supported': {
            enum11 = 2;
            break;
          }
          case 'invalid-argument': {
            enum11 = 3;
            break;
          }
          case 'out-of-memory': {
            enum11 = 4;
            break;
          }
          case 'timeout': {
            enum11 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum11 = 6;
            break;
          }
          case 'not-in-progress': {
            enum11 = 7;
            break;
          }
          case 'would-block': {
            enum11 = 8;
            break;
          }
          case 'invalid-state': {
            enum11 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum11 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum11 = 11;
            break;
          }
          case 'address-in-use': {
            enum11 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum11 = 13;
            break;
          }
          case 'connection-refused': {
            enum11 = 14;
            break;
          }
          case 'connection-reset': {
            enum11 = 15;
            break;
          }
          case 'connection-aborted': {
            enum11 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum11 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum11 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum11 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum11 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val11}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 4, enum11, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]incoming-datagram-stream.receive"][Instruction::Return]', {
      funcName: '[method]incoming-datagram-stream.receive',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_213_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]outgoing-datagram-stream.check-send',
    moduleIdx: null,
  };
  
  
  function trampoline247(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable38[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable11.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutgoingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.check-send"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.checkSend?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'checkSend',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.checkSend()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.check-send"][Instruction::Return]', {
      funcName: '[method]outgoing-datagram-stream.check-send',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_214_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp@0.2.3#[method]outgoing-datagram-stream.send',
    moduleIdx: null,
  };
  
  
  function trampoline248(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable38[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable11.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(OutgoingDatagramStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var len6 = arg2;
    var base6 = arg1;
    var result6 = [];
    for (let i = 0; i < len6; i++) {
      const base = base6 + i * 44;
      var ptr3 = dataView(memory1).getUint32(base + 0, true);
      var len3 = dataView(memory1).getUint32(base + 4, true);
      var result3 = new Uint8Array(memory1.buffer.slice(ptr3, ptr3 + len3 * 1));
      let variant5;
      switch (dataView(memory1).getUint8(base + 8, true)) {
        case 0: {
          variant5 = undefined;
          break;
        }
        case 1: {
          let variant4;
          switch (dataView(memory1).getUint8(base + 12, true)) {
            case 0: {
              variant4= {
                tag: 'ipv4',
                val: {
                  port: clampGuest(dataView(memory1).getUint16(base + 16, true), 0, 65535),
                  address: [clampGuest(dataView(memory1).getUint8(base + 18, true), 0, 255), clampGuest(dataView(memory1).getUint8(base + 19, true), 0, 255), clampGuest(dataView(memory1).getUint8(base + 20, true), 0, 255), clampGuest(dataView(memory1).getUint8(base + 21, true), 0, 255)],
                }
              };
              break;
            }
            case 1: {
              variant4= {
                tag: 'ipv6',
                val: {
                  port: clampGuest(dataView(memory1).getUint16(base + 16, true), 0, 65535),
                  flowInfo: dataView(memory1).getInt32(base + 20, true) >>> 0,
                  address: [clampGuest(dataView(memory1).getUint16(base + 24, true), 0, 65535), clampGuest(dataView(memory1).getUint16(base + 26, true), 0, 65535), clampGuest(dataView(memory1).getUint16(base + 28, true), 0, 65535), clampGuest(dataView(memory1).getUint16(base + 30, true), 0, 65535), clampGuest(dataView(memory1).getUint16(base + 32, true), 0, 65535), clampGuest(dataView(memory1).getUint16(base + 34, true), 0, 65535), clampGuest(dataView(memory1).getUint16(base + 36, true), 0, 65535), clampGuest(dataView(memory1).getUint16(base + 38, true), 0, 65535)],
                  scopeId: dataView(memory1).getInt32(base + 40, true) >>> 0,
                }
              };
              break;
            }
            default: {
              throw new TypeError('invalid variant discriminant for IpSocketAddress');
            }
          }
          variant5 = variant4;
          break;
        }
        default: {
          throw new TypeError('invalid variant discriminant for option');
        }
      }
      result6.push({
        data: result3,
        remoteAddress: variant5,
      });
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.send"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.send?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'send',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.send(result6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        dataView(memory1).setBigInt64(arg3 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg3 + 8, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp@0.2.3", function="[method]outgoing-datagram-stream.send"][Instruction::Return]', {
      funcName: '[method]outgoing-datagram-stream.send',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_215_metadata = {
    qualifiedImportFn: 'wasi:sockets/udp-create-socket@0.2.3#create-udp-socket',
    moduleIdx: null,
  };
  
  
  function trampoline249(arg0, arg1) {
    let enum0;
    switch (arg0) {
      case 0: {
        enum0 = 'ipv4';
        break;
      }
      case 1: {
        enum0 = 'ipv6';
        break;
      }
      default: {
        throw new TypeError('invalid discriminant specified for IpAddressFamily');
      }
    }
    _debugLog('[iface="wasi:sockets/udp-create-socket@0.2.3", function="create-udp-socket"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = createUdpSocket?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'createUdpSocket',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  createUdpSocket(enum0)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    endCurrentTask(3);
    var variant3 = ret;
    switch (variant3.tag) {
      case 'ok': {
        const e = variant3.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        if (!(e instanceof UdpSocket)) {
          throw new TypeError('Resource error: Not a valid "UdpSocket" resource.');
        }
        var handle1 = e[symbolRscHandle];
        if (!handle1) {
          const rep = e[symbolRscRep] || ++captureCnt9;
          captureTable9.set(rep, e);
          handle1 = rscTableCreateOwn(handleTable36, rep);
        }
        dataView(memory1).setInt32(arg1 + 4, handle1, true);
        break;
      }
      case 'err': {
        const e = variant3.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val2 = e;
        let enum2;
        switch (val2) {
          case 'unknown': {
            enum2 = 0;
            break;
          }
          case 'access-denied': {
            enum2 = 1;
            break;
          }
          case 'not-supported': {
            enum2 = 2;
            break;
          }
          case 'invalid-argument': {
            enum2 = 3;
            break;
          }
          case 'out-of-memory': {
            enum2 = 4;
            break;
          }
          case 'timeout': {
            enum2 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum2 = 6;
            break;
          }
          case 'not-in-progress': {
            enum2 = 7;
            break;
          }
          case 'would-block': {
            enum2 = 8;
            break;
          }
          case 'invalid-state': {
            enum2 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum2 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum2 = 11;
            break;
          }
          case 'address-in-use': {
            enum2 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum2 = 13;
            break;
          }
          case 'connection-refused': {
            enum2 = 14;
            break;
          }
          case 'connection-reset': {
            enum2 = 15;
            break;
          }
          case 'connection-aborted': {
            enum2 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum2 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum2 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum2 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum2 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val2}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum2, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/udp-create-socket@0.2.3", function="create-udp-socket"][Instruction::Return]', {
      funcName: 'create-udp-socket',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_216_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.start-bind',
    moduleIdx: null,
  };
  
  
  function trampoline250(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var handle4 = arg1;
    var rep5 = handleTable32[(handle4 << 1) + 1] & ~T_FLAG;
    var rsc3 = captureTable8.get(rep5);
    if (!rsc3) {
      rsc3 = Object.create(Network.prototype);
      Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
      Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
    }
    curResourceBorrows.push(rsc3);
    let variant6;
    switch (arg2) {
      case 0: {
        variant6= {
          tag: 'ipv4',
          val: {
            port: clampGuest(arg3, 0, 65535),
            address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
          }
        };
        break;
      }
      case 1: {
        variant6= {
          tag: 'ipv6',
          val: {
            port: clampGuest(arg3, 0, 65535),
            flowInfo: arg4 >>> 0,
            address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
            scopeId: arg13 >>> 0,
          }
        };
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for IpSocketAddress');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'startBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startBind(rsc3, variant6)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg14 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg14 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg14 + 1, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-bind"][Instruction::Return]', {
      funcName: '[method]tcp-socket.start-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_217_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.finish-bind',
    moduleIdx: null,
  };
  
  
  function trampoline251(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-bind"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishBind?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'finishBind',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishBind()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-bind"][Instruction::Return]', {
      funcName: '[method]tcp-socket.finish-bind',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_218_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.start-listen',
    moduleIdx: null,
  };
  
  
  function trampoline252(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-listen"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.startListen?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'startListen',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.startListen()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.start-listen"][Instruction::Return]', {
      funcName: '[method]tcp-socket.start-listen',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_219_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.finish-listen',
    moduleIdx: null,
  };
  
  
  function trampoline253(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-listen"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.finishListen?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'finishListen',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.finishListen()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.finish-listen"][Instruction::Return]', {
      funcName: '[method]tcp-socket.finish-listen',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_220_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.accept',
    moduleIdx: null,
  };
  
  
  function trampoline254(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.accept"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.accept?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'accept',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.accept()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var [tuple3_0, tuple3_1, tuple3_2] = e;
        if (!(tuple3_0 instanceof TcpSocket)) {
          throw new TypeError('Resource error: Not a valid "TcpSocket" resource.');
        }
        var handle4 = tuple3_0[symbolRscHandle];
        if (!handle4) {
          const rep = tuple3_0[symbolRscRep] || ++captureCnt12;
          captureTable12.set(rep, tuple3_0);
          handle4 = rscTableCreateOwn(handleTable31, rep);
        }
        dataView(memory1).setInt32(arg1 + 4, handle4, true);
        if (!(tuple3_1 instanceof InputStream)) {
          throw new TypeError('Resource error: Not a valid "InputStream" resource.');
        }
        var handle5 = tuple3_1[symbolRscHandle];
        if (!handle5) {
          const rep = tuple3_1[symbolRscRep] || ++captureCnt2;
          captureTable2.set(rep, tuple3_1);
          handle5 = rscTableCreateOwn(handleTable29, rep);
        }
        dataView(memory1).setInt32(arg1 + 8, handle5, true);
        if (!(tuple3_2 instanceof OutputStream)) {
          throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
        }
        var handle6 = tuple3_2[symbolRscHandle];
        if (!handle6) {
          const rep = tuple3_2[symbolRscRep] || ++captureCnt3;
          captureTable3.set(rep, tuple3_2);
          handle6 = rscTableCreateOwn(handleTable30, rep);
        }
        dataView(memory1).setInt32(arg1 + 12, handle6, true);
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.accept"][Instruction::Return]', {
      funcName: '[method]tcp-socket.accept',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_221_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.local-address',
    moduleIdx: null,
  };
  
  
  function trampoline255(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.local-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.localAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'localAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.localAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory1).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory1).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory1).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory1).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory1).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory1).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory1).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory1).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory1).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory1).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory1).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory1).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory1).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory1).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.local-address"][Instruction::Return]', {
      funcName: '[method]tcp-socket.local-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_222_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.remote-address',
    moduleIdx: null,
  };
  
  
  function trampoline256(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.remote-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.remoteAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'remoteAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.remoteAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant9 = ret;
    switch (variant9.tag) {
      case 'ok': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var variant7 = e;
        switch (variant7.tag) {
          case 'ipv4': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 0, true);
            var {port: v3_0, address: v3_1 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v3_0), true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
            dataView(memory1).setInt8(arg1 + 10, toUint8(tuple4_0), true);
            dataView(memory1).setInt8(arg1 + 11, toUint8(tuple4_1), true);
            dataView(memory1).setInt8(arg1 + 12, toUint8(tuple4_2), true);
            dataView(memory1).setInt8(arg1 + 13, toUint8(tuple4_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant7.val;
            dataView(memory1).setInt8(arg1 + 4, 1, true);
            var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
            dataView(memory1).setInt16(arg1 + 8, toUint16(v5_0), true);
            dataView(memory1).setInt32(arg1 + 12, toUint32(v5_1), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
            dataView(memory1).setInt16(arg1 + 16, toUint16(tuple6_0), true);
            dataView(memory1).setInt16(arg1 + 18, toUint16(tuple6_1), true);
            dataView(memory1).setInt16(arg1 + 20, toUint16(tuple6_2), true);
            dataView(memory1).setInt16(arg1 + 22, toUint16(tuple6_3), true);
            dataView(memory1).setInt16(arg1 + 24, toUint16(tuple6_4), true);
            dataView(memory1).setInt16(arg1 + 26, toUint16(tuple6_5), true);
            dataView(memory1).setInt16(arg1 + 28, toUint16(tuple6_6), true);
            dataView(memory1).setInt16(arg1 + 30, toUint16(tuple6_7), true);
            dataView(memory1).setInt32(arg1 + 32, toUint32(v5_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
          }
        }
        break;
      }
      case 'err': {
        const e = variant9.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val8 = e;
        let enum8;
        switch (val8) {
          case 'unknown': {
            enum8 = 0;
            break;
          }
          case 'access-denied': {
            enum8 = 1;
            break;
          }
          case 'not-supported': {
            enum8 = 2;
            break;
          }
          case 'invalid-argument': {
            enum8 = 3;
            break;
          }
          case 'out-of-memory': {
            enum8 = 4;
            break;
          }
          case 'timeout': {
            enum8 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum8 = 6;
            break;
          }
          case 'not-in-progress': {
            enum8 = 7;
            break;
          }
          case 'would-block': {
            enum8 = 8;
            break;
          }
          case 'invalid-state': {
            enum8 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum8 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum8 = 11;
            break;
          }
          case 'address-in-use': {
            enum8 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum8 = 13;
            break;
          }
          case 'connection-refused': {
            enum8 = 14;
            break;
          }
          case 'connection-reset': {
            enum8 = 15;
            break;
          }
          case 'connection-aborted': {
            enum8 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum8 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum8 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum8 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum8 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val8}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum8, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.remote-address"][Instruction::Return]', {
      funcName: '[method]tcp-socket.remote-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_223_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-listen-backlog-size',
    moduleIdx: null,
  };
  
  
  function trampoline257(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-listen-backlog-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setListenBacklogSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setListenBacklogSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setListenBacklogSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-listen-backlog-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-listen-backlog-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_224_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-enabled',
    moduleIdx: null,
  };
  
  
  function trampoline258(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-enabled"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveEnabled?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'keepAliveEnabled',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveEnabled()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setInt8(arg1 + 1, e ? 1 : 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-enabled"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-enabled',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_225_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-enabled',
    moduleIdx: null,
  };
  
  
  function trampoline259(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var bool3 = arg1;
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-enabled"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveEnabled?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setKeepAliveEnabled',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveEnabled(bool3 == 0 ? false : (bool3 == 1 ? true : throwInvalidBool()))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant5 = ret;
    switch (variant5.tag) {
      case 'ok': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant5.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val4 = e;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'access-denied': {
            enum4 = 1;
            break;
          }
          case 'not-supported': {
            enum4 = 2;
            break;
          }
          case 'invalid-argument': {
            enum4 = 3;
            break;
          }
          case 'out-of-memory': {
            enum4 = 4;
            break;
          }
          case 'timeout': {
            enum4 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum4 = 6;
            break;
          }
          case 'not-in-progress': {
            enum4 = 7;
            break;
          }
          case 'would-block': {
            enum4 = 8;
            break;
          }
          case 'invalid-state': {
            enum4 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum4 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum4 = 11;
            break;
          }
          case 'address-in-use': {
            enum4 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum4 = 13;
            break;
          }
          case 'connection-refused': {
            enum4 = 14;
            break;
          }
          case 'connection-reset': {
            enum4 = 15;
            break;
          }
          case 'connection-aborted': {
            enum4 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum4 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum4 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum4 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum4 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum4, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-enabled"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-enabled',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_226_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-idle-time',
    moduleIdx: null,
  };
  
  
  function trampoline260(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-idle-time"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveIdleTime?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'keepAliveIdleTime',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveIdleTime()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-idle-time"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-idle-time',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_227_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-idle-time',
    moduleIdx: null,
  };
  
  
  function trampoline261(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-idle-time"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveIdleTime?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setKeepAliveIdleTime',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveIdleTime(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-idle-time"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-idle-time',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_228_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-interval',
    moduleIdx: null,
  };
  
  
  function trampoline262(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-interval"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveInterval?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'keepAliveInterval',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveInterval()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-interval"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-interval',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_229_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-interval',
    moduleIdx: null,
  };
  
  
  function trampoline263(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-interval"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveInterval?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setKeepAliveInterval',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveInterval(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-interval"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-interval',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_230_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.keep-alive-count',
    moduleIdx: null,
  };
  
  
  function trampoline264(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-count"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.keepAliveCount?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'keepAliveCount',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.keepAliveCount()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setInt32(arg1 + 4, toUint32(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.keep-alive-count"][Instruction::Return]', {
      funcName: '[method]tcp-socket.keep-alive-count',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_231_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-keep-alive-count',
    moduleIdx: null,
  };
  
  
  function trampoline265(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-count"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setKeepAliveCount?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setKeepAliveCount',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setKeepAliveCount(arg1 >>> 0)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-keep-alive-count"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-keep-alive-count',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_232_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline266(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.hopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'hopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.hopLimit()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setInt8(arg1 + 1, toUint8(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.hop-limit"][Instruction::Return]', {
      funcName: '[method]tcp-socket.hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_233_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-hop-limit',
    moduleIdx: null,
  };
  
  
  function trampoline267(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setHopLimit?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setHopLimit',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setHopLimit(clampGuest(arg1, 0, 255))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-hop-limit"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-hop-limit',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_234_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline268(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.receiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'receiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.receiveBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_235_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-receive-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline269(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setReceiveBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setReceiveBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setReceiveBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-receive-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-receive-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_236_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline270(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.sendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'sendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.sendBufferSize()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        dataView(memory1).setBigInt64(arg1 + 8, toUint64(e), true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 8, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.send-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_237_metadata = {
    qualifiedImportFn: 'wasi:sockets/tcp@0.2.3#[method]tcp-socket.set-send-buffer-size',
    moduleIdx: null,
  };
  
  
  function trampoline271(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable31[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable12.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(TcpSocket.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.setSendBufferSize?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'setSendBufferSize',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.setSendBufferSize(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant4 = ret;
    switch (variant4.tag) {
      case 'ok': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        break;
      }
      case 'err': {
        const e = variant4.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var val3 = e;
        let enum3;
        switch (val3) {
          case 'unknown': {
            enum3 = 0;
            break;
          }
          case 'access-denied': {
            enum3 = 1;
            break;
          }
          case 'not-supported': {
            enum3 = 2;
            break;
          }
          case 'invalid-argument': {
            enum3 = 3;
            break;
          }
          case 'out-of-memory': {
            enum3 = 4;
            break;
          }
          case 'timeout': {
            enum3 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum3 = 6;
            break;
          }
          case 'not-in-progress': {
            enum3 = 7;
            break;
          }
          case 'would-block': {
            enum3 = 8;
            break;
          }
          case 'invalid-state': {
            enum3 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum3 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum3 = 11;
            break;
          }
          case 'address-in-use': {
            enum3 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum3 = 13;
            break;
          }
          case 'connection-refused': {
            enum3 = 14;
            break;
          }
          case 'connection-reset': {
            enum3 = 15;
            break;
          }
          case 'connection-aborted': {
            enum3 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum3 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum3 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum3 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum3 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val3}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg2 + 1, enum3, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/tcp@0.2.3", function="[method]tcp-socket.set-send-buffer-size"][Instruction::Return]', {
      funcName: '[method]tcp-socket.set-send-buffer-size',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_238_metadata = {
    qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.3#resolve-addresses',
    moduleIdx: null,
  };
  
  
  function trampoline272(arg0, arg1, arg2, arg3) {
    var handle1 = arg0;
    var rep2 = handleTable32[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable8.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Network.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    var ptr3 = arg1;
    var len3 = arg2;
    var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr3, len3));
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="resolve-addresses"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = resolveAddresses?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'resolveAddresses',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  resolveAddresses(rsc0, result3)};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 0, true);
        if (!(e instanceof ResolveAddressStream)) {
          throw new TypeError('Resource error: Not a valid "ResolveAddressStream" resource.');
        }
        var handle4 = e[symbolRscHandle];
        if (!handle4) {
          const rep = e[symbolRscRep] || ++captureCnt13;
          captureTable13.set(rep, e);
          handle4 = rscTableCreateOwn(handleTable39, rep);
        }
        dataView(memory1).setInt32(arg3 + 4, handle4, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg3 + 0, 1, true);
        var val5 = e;
        let enum5;
        switch (val5) {
          case 'unknown': {
            enum5 = 0;
            break;
          }
          case 'access-denied': {
            enum5 = 1;
            break;
          }
          case 'not-supported': {
            enum5 = 2;
            break;
          }
          case 'invalid-argument': {
            enum5 = 3;
            break;
          }
          case 'out-of-memory': {
            enum5 = 4;
            break;
          }
          case 'timeout': {
            enum5 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum5 = 6;
            break;
          }
          case 'not-in-progress': {
            enum5 = 7;
            break;
          }
          case 'would-block': {
            enum5 = 8;
            break;
          }
          case 'invalid-state': {
            enum5 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum5 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum5 = 11;
            break;
          }
          case 'address-in-use': {
            enum5 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum5 = 13;
            break;
          }
          case 'connection-refused': {
            enum5 = 14;
            break;
          }
          case 'connection-reset': {
            enum5 = 15;
            break;
          }
          case 'connection-aborted': {
            enum5 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum5 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum5 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum5 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum5 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val5}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg3 + 4, enum5, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="resolve-addresses"][Instruction::Return]', {
      funcName: 'resolve-addresses',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_239_metadata = {
    qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.3#[method]resolve-address-stream.resolve-next-address',
    moduleIdx: null,
  };
  
  
  function trampoline273(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable39[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable13.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(ResolveAddressStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.resolve-next-address"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.resolveNextAddress?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'resolveNextAddress',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.resolveNextAddress()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var variant6 = e;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory1).setInt8(arg1 + 2, 0, true);
        } else {
          const e = variant6;
          dataView(memory1).setInt8(arg1 + 2, 1, true);
          var variant5 = e;
          switch (variant5.tag) {
            case 'ipv4': {
              const e = variant5.val;
              dataView(memory1).setInt8(arg1 + 4, 0, true);
              var [tuple3_0, tuple3_1, tuple3_2, tuple3_3] = e;
              dataView(memory1).setInt8(arg1 + 6, toUint8(tuple3_0), true);
              dataView(memory1).setInt8(arg1 + 7, toUint8(tuple3_1), true);
              dataView(memory1).setInt8(arg1 + 8, toUint8(tuple3_2), true);
              dataView(memory1).setInt8(arg1 + 9, toUint8(tuple3_3), true);
              break;
            }
            case 'ipv6': {
              const e = variant5.val;
              dataView(memory1).setInt8(arg1 + 4, 1, true);
              var [tuple4_0, tuple4_1, tuple4_2, tuple4_3, tuple4_4, tuple4_5, tuple4_6, tuple4_7] = e;
              dataView(memory1).setInt16(arg1 + 6, toUint16(tuple4_0), true);
              dataView(memory1).setInt16(arg1 + 8, toUint16(tuple4_1), true);
              dataView(memory1).setInt16(arg1 + 10, toUint16(tuple4_2), true);
              dataView(memory1).setInt16(arg1 + 12, toUint16(tuple4_3), true);
              dataView(memory1).setInt16(arg1 + 14, toUint16(tuple4_4), true);
              dataView(memory1).setInt16(arg1 + 16, toUint16(tuple4_5), true);
              dataView(memory1).setInt16(arg1 + 18, toUint16(tuple4_6), true);
              dataView(memory1).setInt16(arg1 + 20, toUint16(tuple4_7), true);
              break;
            }
            default: {
              throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`IpAddress\``);
            }
          }
        }
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'unknown': {
            enum7 = 0;
            break;
          }
          case 'access-denied': {
            enum7 = 1;
            break;
          }
          case 'not-supported': {
            enum7 = 2;
            break;
          }
          case 'invalid-argument': {
            enum7 = 3;
            break;
          }
          case 'out-of-memory': {
            enum7 = 4;
            break;
          }
          case 'timeout': {
            enum7 = 5;
            break;
          }
          case 'concurrency-conflict': {
            enum7 = 6;
            break;
          }
          case 'not-in-progress': {
            enum7 = 7;
            break;
          }
          case 'would-block': {
            enum7 = 8;
            break;
          }
          case 'invalid-state': {
            enum7 = 9;
            break;
          }
          case 'new-socket-limit': {
            enum7 = 10;
            break;
          }
          case 'address-not-bindable': {
            enum7 = 11;
            break;
          }
          case 'address-in-use': {
            enum7 = 12;
            break;
          }
          case 'remote-unreachable': {
            enum7 = 13;
            break;
          }
          case 'connection-refused': {
            enum7 = 14;
            break;
          }
          case 'connection-reset': {
            enum7 = 15;
            break;
          }
          case 'connection-aborted': {
            enum7 = 16;
            break;
          }
          case 'datagram-too-large': {
            enum7 = 17;
            break;
          }
          case 'name-unresolvable': {
            enum7 = 18;
            break;
          }
          case 'temporary-resolver-failure': {
            enum7 = 19;
            break;
          }
          case 'permanent-resolver-failure': {
            enum7 = 20;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 2, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.3", function="[method]resolve-address-stream.resolve-next-address"][Instruction::Return]', {
      funcName: '[method]resolve-address-stream.resolve-next-address',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_240_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-arguments',
    moduleIdx: null,
  };
  
  
  function trampoline274(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getArguments?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getArguments',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getArguments();
    endCurrentTask(3);
    var vec1 = ret;
    var len1 = vec1.length;
    var result1 = realloc3(0, 0, 4, len1 * 8);
    for (let i = 0; i < vec1.length; i++) {
      const e = vec1[i];
      const base = result1 + i * 8;
      var encodeRes = _utf8AllocateAndEncode(e, realloc3, memory1);
      var ptr0= encodeRes.ptr;
      var len0 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 4, len0, true);
      dataView(memory1).setUint32(base + 0, ptr0, true);
    }
    dataView(memory1).setUint32(arg0 + 4, len1, true);
    dataView(memory1).setUint32(arg0 + 0, result1, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-arguments"][Instruction::Return]', {
      funcName: 'get-arguments',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_241_metadata = {
    qualifiedImportFn: 'wasi:cli/environment@0.2.3#get-environment',
    moduleIdx: null,
  };
  
  
  function trampoline275(arg0) {
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getEnvironment?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getEnvironment',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getEnvironment();
    endCurrentTask(3);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc3(0, 0, 4, len3 * 16);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 16;var [tuple0_0, tuple0_1] = e;
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_0, realloc3, memory1);
      var ptr1= encodeRes.ptr;
      var len1 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 4, len1, true);
      dataView(memory1).setUint32(base + 0, ptr1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc3, memory1);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 12, len2, true);
      dataView(memory1).setUint32(base + 8, ptr2, true);
    }
    dataView(memory1).setUint32(arg0 + 4, len3, true);
    dataView(memory1).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:cli/environment@0.2.3", function="get-environment"][Instruction::Return]', {
      funcName: 'get-environment',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_242_metadata = {
    qualifiedImportFn: 'wasi:filesystem/types@0.2.3#[method]directory-entry-stream.read-directory-entry',
    moduleIdx: null,
  };
  
  
  function trampoline276(arg0, arg1) {
    var handle1 = arg0;
    var rep2 = handleTable35[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable7.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(DirectoryEntryStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.readDirectoryEntry?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'readDirectoryEntry',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.readDirectoryEntry()};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant8 = ret;
    switch (variant8.tag) {
      case 'ok': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 0, true);
        var variant6 = e;
        if (variant6 === null || variant6=== undefined) {
          dataView(memory1).setInt8(arg1 + 4, 0, true);
        } else {
          const e = variant6;
          dataView(memory1).setInt8(arg1 + 4, 1, true);
          var {type: v3_0, name: v3_1 } = e;
          var val4 = v3_0;
          let enum4;
          switch (val4) {
            case 'unknown': {
              enum4 = 0;
              break;
            }
            case 'block-device': {
              enum4 = 1;
              break;
            }
            case 'character-device': {
              enum4 = 2;
              break;
            }
            case 'directory': {
              enum4 = 3;
              break;
            }
            case 'fifo': {
              enum4 = 4;
              break;
            }
            case 'symbolic-link': {
              enum4 = 5;
              break;
            }
            case 'regular-file': {
              enum4 = 6;
              break;
            }
            case 'socket': {
              enum4 = 7;
              break;
            }
            default: {
              if ((v3_0) instanceof Error) {
                console.error(v3_0);
              }
              
              throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
            }
          }
          dataView(memory1).setInt8(arg1 + 8, enum4, true);
          
          var encodeRes = _utf8AllocateAndEncode(v3_1, realloc3, memory1);
          var ptr5= encodeRes.ptr;
          var len5 = encodeRes.len;
          
          dataView(memory1).setUint32(arg1 + 16, len5, true);
          dataView(memory1).setUint32(arg1 + 12, ptr5, true);
        }
        break;
      }
      case 'err': {
        const e = variant8.val;
        dataView(memory1).setInt8(arg1 + 0, 1, true);
        var val7 = e;
        let enum7;
        switch (val7) {
          case 'access': {
            enum7 = 0;
            break;
          }
          case 'would-block': {
            enum7 = 1;
            break;
          }
          case 'already': {
            enum7 = 2;
            break;
          }
          case 'bad-descriptor': {
            enum7 = 3;
            break;
          }
          case 'busy': {
            enum7 = 4;
            break;
          }
          case 'deadlock': {
            enum7 = 5;
            break;
          }
          case 'quota': {
            enum7 = 6;
            break;
          }
          case 'exist': {
            enum7 = 7;
            break;
          }
          case 'file-too-large': {
            enum7 = 8;
            break;
          }
          case 'illegal-byte-sequence': {
            enum7 = 9;
            break;
          }
          case 'in-progress': {
            enum7 = 10;
            break;
          }
          case 'interrupted': {
            enum7 = 11;
            break;
          }
          case 'invalid': {
            enum7 = 12;
            break;
          }
          case 'io': {
            enum7 = 13;
            break;
          }
          case 'is-directory': {
            enum7 = 14;
            break;
          }
          case 'loop': {
            enum7 = 15;
            break;
          }
          case 'too-many-links': {
            enum7 = 16;
            break;
          }
          case 'message-size': {
            enum7 = 17;
            break;
          }
          case 'name-too-long': {
            enum7 = 18;
            break;
          }
          case 'no-device': {
            enum7 = 19;
            break;
          }
          case 'no-entry': {
            enum7 = 20;
            break;
          }
          case 'no-lock': {
            enum7 = 21;
            break;
          }
          case 'insufficient-memory': {
            enum7 = 22;
            break;
          }
          case 'insufficient-space': {
            enum7 = 23;
            break;
          }
          case 'not-directory': {
            enum7 = 24;
            break;
          }
          case 'not-empty': {
            enum7 = 25;
            break;
          }
          case 'not-recoverable': {
            enum7 = 26;
            break;
          }
          case 'unsupported': {
            enum7 = 27;
            break;
          }
          case 'no-tty': {
            enum7 = 28;
            break;
          }
          case 'no-such-device': {
            enum7 = 29;
            break;
          }
          case 'overflow': {
            enum7 = 30;
            break;
          }
          case 'not-permitted': {
            enum7 = 31;
            break;
          }
          case 'pipe': {
            enum7 = 32;
            break;
          }
          case 'read-only': {
            enum7 = 33;
            break;
          }
          case 'invalid-seek': {
            enum7 = 34;
            break;
          }
          case 'text-file-busy': {
            enum7 = 35;
            break;
          }
          case 'cross-device': {
            enum7 = 36;
            break;
          }
          default: {
            if ((e) instanceof Error) {
              console.error(e);
            }
            
            throw new TypeError(`"${val7}" is not one of the cases of error-code`);
          }
        }
        dataView(memory1).setInt8(arg1 + 4, enum7, true);
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:filesystem/types@0.2.3", function="[method]directory-entry-stream.read-directory-entry"][Instruction::Return]', {
      funcName: '[method]directory-entry-stream.read-directory-entry',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_243_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.read',
    moduleIdx: null,
  };
  
  
  function trampoline277(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable29[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.read?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'read',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc3(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory1.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory1.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory1).setUint32(arg2 + 8, len3, true);
        dataView(memory1).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory1).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.read"][Instruction::Return]', {
      funcName: '[method]input-stream.read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_244_metadata = {
    qualifiedImportFn: 'wasi:io/streams@0.2.3#[method]input-stream.blocking-read',
    moduleIdx: null,
  };
  
  
  function trampoline278(arg0, arg1, arg2) {
    var handle1 = arg0;
    var rep2 = handleTable29[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable2.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(InputStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = rsc0.blockingRead?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'blockingRead',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'result-catch-handler',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    
    let ret;
    try {
      ret = { tag: 'ok', val:  rsc0.blockingRead(BigInt.asUintN(64, arg1))};
    } catch (e) {
      ret = { tag: 'err', val: getErrorPayload(e) };
    }
    
    for (const rsc of curResourceBorrows) {
      rsc[symbolRscHandle] = undefined;
    }
    curResourceBorrows = [];
    endCurrentTask(3);
    var variant6 = ret;
    switch (variant6.tag) {
      case 'ok': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 0, true);
        var val3 = e;
        var len3 = val3.byteLength;
        var ptr3 = realloc3(0, 0, 1, len3 * 1);
        
        let valData3;
        const valLenBytes3 = len3 * 1;
        if (Array.isArray(val3)) {
          // Regular array likely containing numbers, write values to memory
          let offset = 0;
          const dv3 = new DataView(memory1.buffer);
          for (const v of val3) {
            dv3.setUint8(ptr3+ offset, v, true);
            offset += 1;
          }
        } else {
          // TypedArray / ArrayBuffer-like, direct copy
          valData3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, valLenBytes3);
          const out3 = new Uint8Array(memory1.buffer, ptr3,valLenBytes3);
          out3.set(valData3);
        }
        
        dataView(memory1).setUint32(arg2 + 8, len3, true);
        dataView(memory1).setUint32(arg2 + 4, ptr3, true);
        break;
      }
      case 'err': {
        const e = variant6.val;
        dataView(memory1).setInt8(arg2 + 0, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'last-operation-failed': {
            const e = variant5.val;
            dataView(memory1).setInt8(arg2 + 4, 0, true);
            if (!(e instanceof Error$1)) {
              throw new TypeError('Resource error: Not a valid "Error" resource.');
            }
            var handle4 = e[symbolRscHandle];
            if (!handle4) {
              const rep = e[symbolRscRep] || ++captureCnt0;
              captureTable0.set(rep, e);
              handle4 = rscTableCreateOwn(handleTable33, rep);
            }
            dataView(memory1).setInt32(arg2 + 8, handle4, true);
            break;
          }
          case 'closed': {
            dataView(memory1).setInt8(arg2 + 4, 1, true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
          }
        }
        break;
      }
      default: {
        throw new TypeError('invalid variant specified for result');
      }
    }
    _debugLog('[iface="wasi:io/streams@0.2.3", function="[method]input-stream.blocking-read"][Instruction::Return]', {
      funcName: '[method]input-stream.blocking-read',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  
  let lowered_import_245_metadata = {
    qualifiedImportFn: 'wasi:filesystem/preopens@0.2.3#get-directories',
    moduleIdx: null,
  };
  
  
  function trampoline279(arg0) {
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"] [Instruction::CallInterface] (sync, @ enter)');
    let hostProvided = false;
    hostProvided = getDirectories?._isHostProvided;
    
    let parentTask;
    let task;
    let subtask;
    
    const createTask = () => {
      const results = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'getDirectories',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: false,
      });
      task = results[0];
    };
    
    taskCreation: {
      parentTask = getCurrentTask(3)?.task;
      if (!parentTask) {
        createTask();
        break taskCreation;
      }
      
      createTask();
      
      const isHostAsyncImport = hostProvided && false;
      if (isHostAsyncImport) {
        subtask = parentTask.getLatestSubtask();
        if (!subtask) {
          throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
        }
        subtask.setChildTask(task);
        task.setParentSubtask(subtask);
      }
    }
    
    let ret =  getDirectories();
    endCurrentTask(3);
    var vec3 = ret;
    var len3 = vec3.length;
    var result3 = realloc3(0, 0, 4, len3 * 12);
    for (let i = 0; i < vec3.length; i++) {
      const e = vec3[i];
      const base = result3 + i * 12;var [tuple0_0, tuple0_1] = e;
      if (!(tuple0_0 instanceof Descriptor)) {
        throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
      }
      var handle1 = tuple0_0[symbolRscHandle];
      if (!handle1) {
        const rep = tuple0_0[symbolRscRep] || ++captureCnt6;
        captureTable6.set(rep, tuple0_0);
        handle1 = rscTableCreateOwn(handleTable34, rep);
      }
      dataView(memory1).setInt32(base + 0, handle1, true);
      
      var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc3, memory1);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      dataView(memory1).setUint32(base + 8, len2, true);
      dataView(memory1).setUint32(base + 4, ptr2, true);
    }
    dataView(memory1).setUint32(arg0 + 4, len3, true);
    dataView(memory1).setUint32(arg0 + 0, result3, true);
    _debugLog('[iface="wasi:filesystem/preopens@0.2.3", function="get-directories"][Instruction::Return]', {
      funcName: 'get-directories',
      paramCount: 0,
      async: false,
      postReturn: false
    });
  }
  
  let exports8;
  let postReturn0;
  let postReturn1;
  let postReturn2;
  let postReturn3;
  let postReturn4;
  let postReturn5;
  let postReturn6;
  let postReturn7;
  let postReturn8;
  let postReturn9;
  let postReturn10;
  let postReturn11;
  let postReturn12;
  let postReturn13;
  let postReturn14;
  let postReturn15;
  function trampoline0(handle) {
    const handleEntry = rscTableRemove(handleTable14, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable1.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable1.delete(handleEntry.rep);
      } else if (Pollable[symbolCabiDispose]) {
        Pollable[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline1(handle) {
    const handleEntry = rscTableRemove(handleTable15, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable2.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable2.delete(handleEntry.rep);
      } else if (InputStream[symbolCabiDispose]) {
        InputStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline2(handle) {
    const handleEntry = rscTableRemove(handleTable16, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable3.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable3.delete(handleEntry.rep);
      } else if (OutputStream[symbolCabiDispose]) {
        OutputStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline3(handle) {
    const handleEntry = rscTableRemove(handleTable17, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable12.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable12.delete(handleEntry.rep);
      } else if (TcpSocket[symbolCabiDispose]) {
        TcpSocket[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_0_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_0_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 4,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 14)],
      metadata: lowered_import_0_metadata,
      resultLowerFns: [],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_1_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_1_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 5,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 15)],
      metadata: lowered_import_1_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_2_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_2_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 6,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16)],
      metadata: lowered_import_2_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_3_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_3_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 7,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_3_metadata,
      resultLowerFns: [_lowerFlatU64],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_4_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_4_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 8,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatU64],
      metadata: lowered_import_4_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_5_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_5_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 9,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatU64],
      metadata: lowered_import_5_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_6_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_6_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 10,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_6_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 18)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_7_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_7_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 11,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_7_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_8_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_8_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 12,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_8_metadata,
      resultLowerFns: [_lowerFlatU64],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_9_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_9_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 13,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatResult([['ok', null, null],['error', null, null],])],
      metadata: lowered_import_9_metadata,
      resultLowerFns: [],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_10_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_10_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 14,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 14)],
      metadata: lowered_import_10_metadata,
      resultLowerFns: [_lowerFlatBool],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_11_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_11_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 15,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_11_metadata,
      resultLowerFns: [_lowerFlatBool],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_12_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_12_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 16,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_12_metadata,
      resultLowerFns: [_lowerFlatEnum.bind(null, 4)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_13_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_13_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 17,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_13_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_14_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_14_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 18,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 23)],
      metadata: lowered_import_14_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_15_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_15_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 19,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 24)],
      metadata: lowered_import_15_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_16_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_16_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 20,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_16_metadata,
      resultLowerFns: [_lowerFlatBool],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_17_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_17_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 21,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_17_metadata,
      resultLowerFns: [_lowerFlatEnum.bind(null, 4)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_18_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_18_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 22,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 25)],
      metadata: lowered_import_18_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 14)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  function trampoline23(handle) {
    const handleEntry = rscTableRemove(handleTable19, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable0.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable0.delete(handleEntry.rep);
      } else if (Error$1[symbolCabiDispose]) {
        Error$1[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline24(handle) {
    const handleEntry = rscTableRemove(handleTable20, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable6.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable6.delete(handleEntry.rep);
      } else if (Descriptor[symbolCabiDispose]) {
        Descriptor[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline25(handle) {
    const handleEntry = rscTableRemove(handleTable21, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable7.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable7.delete(handleEntry.rep);
      } else if (DirectoryEntryStream[symbolCabiDispose]) {
        DirectoryEntryStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline26(handle) {
    const handleEntry = rscTableRemove(handleTable18, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable8.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable8.delete(handleEntry.rep);
      } else if (Network[symbolCabiDispose]) {
        Network[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline27(handle) {
    const handleEntry = rscTableRemove(handleTable22, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable9.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable9.delete(handleEntry.rep);
      } else if (UdpSocket[symbolCabiDispose]) {
        UdpSocket[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline28(handle) {
    const handleEntry = rscTableRemove(handleTable23, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable10.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable10.delete(handleEntry.rep);
      } else if (IncomingDatagramStream[symbolCabiDispose]) {
        IncomingDatagramStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline29(handle) {
    const handleEntry = rscTableRemove(handleTable24, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable11.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable11.delete(handleEntry.rep);
      } else if (OutgoingDatagramStream[symbolCabiDispose]) {
        OutgoingDatagramStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline30(handle) {
    const handleEntry = rscTableRemove(handleTable25, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable13.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable13.delete(handleEntry.rep);
      } else if (ResolveAddressStream[symbolCabiDispose]) {
        ResolveAddressStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline31(handle) {
    const handleEntry = rscTableRemove(handleTable26, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable4.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable4.delete(handleEntry.rep);
      } else if (TerminalInput[symbolCabiDispose]) {
        TerminalInput[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline32(handle) {
    const handleEntry = rscTableRemove(handleTable27, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable5.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable5.delete(handleEntry.rep);
      } else if (TerminalOutput[symbolCabiDispose]) {
        TerminalOutput[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_19_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_19_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 33,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_19_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 16)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_20_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_20_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 34,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_20_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 15)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_21_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_21_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 35,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_21_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 16)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_22_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_22_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 36,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatList.bind(null, 8)],
      metadata: lowered_import_22_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatU32, typeIdx: 3 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_23_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_23_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 37,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_23_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_24_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_24_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 38,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_24_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_25_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_25_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 39,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16)],
      metadata: lowered_import_25_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_26_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_26_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 40,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16),_liftFlatList.bind(null, 4)],
      metadata: lowered_import_26_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_27_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_27_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 41,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16)],
      metadata: lowered_import_27_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_28_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_28_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 42,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatBorrow.bind(null, 18),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
      metadata: lowered_import_28_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_29_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_29_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 43,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_29_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 120), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_30_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_30_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 44,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatEnum.bind(null, 5)],
      metadata: lowered_import_30_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_31_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_31_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 45,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_31_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatStringUTF8, typeIdx: 1 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_32_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_32_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 46,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatEnum.bind(null, 4)],
      metadata: lowered_import_32_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 17), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_33_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_33_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 47,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatU64],
      metadata: lowered_import_33_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_34_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_34_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 48,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_34_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 3), typeIdx: 0 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_35_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_35_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 49,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_35_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 0)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_36_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_36_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 50,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 19)],
      metadata: lowered_import_36_metadata,
      resultLowerFns: [_lowerFlatStringUTF8],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_37_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_37_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 51,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_37_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_38_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_38_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 52,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_38_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_39_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_39_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 53,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16),_liftFlatList.bind(null, 4)],
      metadata: lowered_import_39_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_40_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_40_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 54,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16)],
      metadata: lowered_import_40_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_41_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_41_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 55,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16),_liftFlatU64],
      metadata: lowered_import_41_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_42_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_42_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 56,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16),_liftFlatU64],
      metadata: lowered_import_42_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_43_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_43_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 57,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16),_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_43_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_44_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_44_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 58,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 16),_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_44_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_45_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_45_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 59,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_45_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 8)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_46_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_46_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 60,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_46_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 9)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_47_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_47_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 61,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_47_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 9)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_48_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_48_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 62,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 19)],
      metadata: lowered_import_48_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 5)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_49_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_49_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 63,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatU64],
      metadata: lowered_import_49_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 15), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_50_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_50_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 64,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatU64],
      metadata: lowered_import_50_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 16), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_51_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_51_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 65,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_51_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 16), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_52_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_52_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 66,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatU64,_liftFlatU64,_liftFlatEnum.bind(null, 1)],
      metadata: lowered_import_52_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_53_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_53_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 67,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_53_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_54_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_54_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 68,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_54_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatFlags.bind(null, 0), align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_55_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_55_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 69,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_55_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_56_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_56_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 70,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatU64],
      metadata: lowered_import_56_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_57_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_57_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 71,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],]),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],])],
      metadata: lowered_import_57_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_58_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_58_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 72,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatU64,_liftFlatU64],
      metadata: lowered_import_58_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 37), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_59_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_59_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 73,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatList.bind(null, 4),_liftFlatU64],
      metadata: lowered_import_59_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_60_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_60_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 74,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_60_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 21), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_61_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_61_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 75,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_61_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_62_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_62_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 76,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8],
      metadata: lowered_import_62_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_63_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_63_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 77,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_63_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'type', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 8 },{ field: 'link-count', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'size', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'data-access-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'data-modification-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'status-change-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_64_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_64_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 78,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8],
      metadata: lowered_import_64_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'type', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 8 },{ field: 'link-count', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'size', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'data-access-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'data-modification-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'status-change-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_65_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_65_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 79,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],]),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],])],
      metadata: lowered_import_65_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_66_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_66_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 80,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8],
      metadata: lowered_import_66_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_67_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_67_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 81,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatFlags.bind(null, 2),_liftFlatFlags.bind(null, 0)],
      metadata: lowered_import_67_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 20), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_68_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_68_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 82,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8],
      metadata: lowered_import_68_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatStringUTF8, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_69_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_69_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 83,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8],
      metadata: lowered_import_69_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_70_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_70_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 84,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8,_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8],
      metadata: lowered_import_70_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_71_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_71_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 85,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8,_liftFlatStringUTF8],
      metadata: lowered_import_71_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_72_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_72_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 86,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatStringUTF8],
      metadata: lowered_import_72_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_73_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_73_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 87,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20)],
      metadata: lowered_import_73_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'lower', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'upper', lowerFn: _lowerFlatU64, align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_74_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_74_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 88,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 20),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8],
      metadata: lowered_import_74_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'lower', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'upper', lowerFn: _lowerFlatU64, align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_75_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_75_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 89,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 21)],
      metadata: lowered_import_75_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_76_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_76_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 90,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_76_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 147), typeIdx: 9 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_77_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_77_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 91,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22),_liftFlatBorrow.bind(null, 18),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
      metadata: lowered_import_77_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_78_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_78_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 92,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_78_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_79_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_79_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 93,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22),_liftFlatOption.bind(null, 6)],
      metadata: lowered_import_79_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 150), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_80_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_80_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 94,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_80_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_81_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_81_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 95,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_81_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_82_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_82_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 96,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_82_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU8, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_83_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_83_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 97,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22),_liftFlatU8],
      metadata: lowered_import_83_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_84_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_84_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 98,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_84_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_85_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_85_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 99,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22),_liftFlatU64],
      metadata: lowered_import_85_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_86_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_86_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 100,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22)],
      metadata: lowered_import_86_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_87_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_87_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 101,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 22),_liftFlatU64],
      metadata: lowered_import_87_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_88_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_88_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 102,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 23),_liftFlatU64],
      metadata: lowered_import_88_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatRecord([{ field: 'data', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ field: 'remote-address', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },]), typeIdx: 6 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc0,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_89_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_89_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 103,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 24)],
      metadata: lowered_import_89_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_90_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_90_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 104,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 24),_liftFlatList.bind(null, 7)],
      metadata: lowered_import_90_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_91_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_91_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 105,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatEnum.bind(null, 4)],
      metadata: lowered_import_91_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 22), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_92_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_92_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 106,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatBorrow.bind(null, 18),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
      metadata: lowered_import_92_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_93_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_93_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 107,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_93_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_94_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_94_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 108,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_94_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_95_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_95_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 109,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_95_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_96_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_96_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 110,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_96_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 158), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_97_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_97_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 111,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_97_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_98_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_98_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 112,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_98_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_99_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_99_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 113,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatU64],
      metadata: lowered_import_99_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_100_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_100_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 114,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_100_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatBool, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_101_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_101_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 115,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatBool],
      metadata: lowered_import_101_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_102_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_102_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 116,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_102_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_103_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_103_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 117,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatU64],
      metadata: lowered_import_103_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_104_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_104_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 118,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_104_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_105_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_105_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 119,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatU64],
      metadata: lowered_import_105_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_106_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_106_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 120,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_106_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU32, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_107_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_107_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 121,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatU32],
      metadata: lowered_import_107_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_108_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_108_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 122,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_108_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU8, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_109_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_109_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 123,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatU8],
      metadata: lowered_import_109_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_110_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_110_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 124,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_110_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_111_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_111_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 125,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatU64],
      metadata: lowered_import_111_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_112_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_112_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 126,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17)],
      metadata: lowered_import_112_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_113_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_113_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 127,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 17),_liftFlatU64],
      metadata: lowered_import_113_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_114_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_114_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 128,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 18),_liftFlatStringUTF8],
      metadata: lowered_import_114_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 25), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_115_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_115_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 129,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 25)],
      metadata: lowered_import_115_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 7), align32: 2 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_116_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_116_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 130,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_116_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatStringUTF8, typeIdx: 1 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc1,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_117_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_117_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 131,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_117_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 3), typeIdx: 0 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc1,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_118_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_118_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 132,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 21)],
      metadata: lowered_import_118_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc1,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_119_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_119_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 133,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_119_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc1,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_120_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_120_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 134,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 15),_liftFlatU64],
      metadata: lowered_import_120_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 19), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc1,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_121_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_121_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 135,
      componentIdx: 1,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_121_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 147), typeIdx: 9 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 0,
      getMemoryFn: () => memory0,
      getReallocFn: () => realloc1,
    },
    ),
  });
  
  function trampoline136(handle) {
    const handleEntry = rscTableRemove(handleTable28, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable1.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable1.delete(handleEntry.rep);
      } else if (Pollable[symbolCabiDispose]) {
        Pollable[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline137(handle) {
    const handleEntry = rscTableRemove(handleTable29, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable2.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable2.delete(handleEntry.rep);
      } else if (InputStream[symbolCabiDispose]) {
        InputStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline138(handle) {
    const handleEntry = rscTableRemove(handleTable30, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable3.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable3.delete(handleEntry.rep);
      } else if (OutputStream[symbolCabiDispose]) {
        OutputStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline139(handle) {
    const handleEntry = rscTableRemove(handleTable31, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable12.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable12.delete(handleEntry.rep);
      } else if (TcpSocket[symbolCabiDispose]) {
        TcpSocket[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_122_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_122_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 140,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 28)],
      metadata: lowered_import_122_metadata,
      resultLowerFns: [],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_123_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_123_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 141,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 29)],
      metadata: lowered_import_123_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_124_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_124_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 142,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30)],
      metadata: lowered_import_124_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_125_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_125_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 143,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_125_metadata,
      resultLowerFns: [_lowerFlatU64],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_126_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_126_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 144,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatU64],
      metadata: lowered_import_126_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_127_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_127_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 145,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatU64],
      metadata: lowered_import_127_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_128_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_128_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 146,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_128_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 32)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_129_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_129_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 147,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_129_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_130_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_130_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 148,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_130_metadata,
      resultLowerFns: [_lowerFlatU64],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_131_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_131_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 149,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatResult([['ok', null, null],['error', null, null],])],
      metadata: lowered_import_131_metadata,
      resultLowerFns: [],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_132_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_132_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 150,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 28)],
      metadata: lowered_import_132_metadata,
      resultLowerFns: [_lowerFlatBool],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_133_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_133_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 151,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_133_metadata,
      resultLowerFns: [_lowerFlatBool],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_134_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_134_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 152,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_134_metadata,
      resultLowerFns: [_lowerFlatEnum.bind(null, 4)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_135_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_135_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 153,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_135_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_136_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_136_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 154,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 37)],
      metadata: lowered_import_136_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_137_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_137_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 155,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 38)],
      metadata: lowered_import_137_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_138_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_138_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 156,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_138_metadata,
      resultLowerFns: [_lowerFlatBool],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_139_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_139_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 157,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_139_metadata,
      resultLowerFns: [_lowerFlatEnum.bind(null, 4)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_140_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_140_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 158,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 39)],
      metadata: lowered_import_140_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 28)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_141_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_141_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 159,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatU32],
      metadata: lowered_import_141_metadata,
      resultLowerFns: [_lowerFlatBool],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_142_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_142_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 160,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_142_metadata,
      resultLowerFns: [],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  const handleTable40 = [T_FLAG, 0];
  const finalizationRegistry40 = finalizationRegistryCreate((handle) => {
    const { rep } = rscTableRemove(handleTable40, handle);
  });
  
  handleTables[40] = handleTable40;
  const trampoline161 = rscTableCreateOwn.bind(null, handleTable40);
  function trampoline162(handle) {
    return handleTable40[(handle << 1) + 1] & ~T_FLAG;
  }
  function trampoline163(handle) {
    const handleEntry = rscTableRemove(handleTable40, handle);
    if (handleEntry.own) {
      
    }
  }
  const handleTable41 = [T_FLAG, 0];
  const finalizationRegistry41 = finalizationRegistryCreate((handle) => {
    const { rep } = rscTableRemove(handleTable41, handle);
  });
  
  handleTables[41] = handleTable41;
  const trampoline164 = rscTableCreateOwn.bind(null, handleTable41);
  function trampoline165(handle) {
    return handleTable41[(handle << 1) + 1] & ~T_FLAG;
  }
  function trampoline166(handle) {
    const handleEntry = rscTableRemove(handleTable41, handle);
    if (handleEntry.own) {
      
    }
  }
  function trampoline167(handle) {
    const handleEntry = rscTableRemove(handleTable33, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable0.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable0.delete(handleEntry.rep);
      } else if (Error$1[symbolCabiDispose]) {
        Error$1[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline168(handle) {
    const handleEntry = rscTableRemove(handleTable34, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable6.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable6.delete(handleEntry.rep);
      } else if (Descriptor[symbolCabiDispose]) {
        Descriptor[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline169(handle) {
    const handleEntry = rscTableRemove(handleTable35, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable7.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable7.delete(handleEntry.rep);
      } else if (DirectoryEntryStream[symbolCabiDispose]) {
        DirectoryEntryStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline170(handle) {
    const handleEntry = rscTableRemove(handleTable32, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable8.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable8.delete(handleEntry.rep);
      } else if (Network[symbolCabiDispose]) {
        Network[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline171(handle) {
    const handleEntry = rscTableRemove(handleTable36, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable9.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable9.delete(handleEntry.rep);
      } else if (UdpSocket[symbolCabiDispose]) {
        UdpSocket[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline172(handle) {
    const handleEntry = rscTableRemove(handleTable37, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable10.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable10.delete(handleEntry.rep);
      } else if (IncomingDatagramStream[symbolCabiDispose]) {
        IncomingDatagramStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline173(handle) {
    const handleEntry = rscTableRemove(handleTable38, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable11.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable11.delete(handleEntry.rep);
      } else if (OutgoingDatagramStream[symbolCabiDispose]) {
        OutgoingDatagramStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline174(handle) {
    const handleEntry = rscTableRemove(handleTable39, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable13.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable13.delete(handleEntry.rep);
      } else if (ResolveAddressStream[symbolCabiDispose]) {
        ResolveAddressStream[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline175(handle) {
    const handleEntry = rscTableRemove(handleTable42, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable4.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable4.delete(handleEntry.rep);
      } else if (TerminalInput[symbolCabiDispose]) {
        TerminalInput[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  function trampoline176(handle) {
    const handleEntry = rscTableRemove(handleTable43, handle);
    if (handleEntry.own) {
      
      const rsc = captureTable5.get(handleEntry.rep);
      if (rsc) {
        if (rsc[symbolDispose]) rsc[symbolDispose]();
        captureTable5.delete(handleEntry.rep);
      } else if (TerminalOutput[symbolCabiDispose]) {
        TerminalOutput[symbolCabiDispose](handleEntry.rep);
      }
    }
  }
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_143_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_143_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 177,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_143_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 30)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_144_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_144_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 178,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_144_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 29)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_145_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_145_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 179,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_145_metadata,
      resultLowerFns: [_lowerFlatOwn.bind(null, 30)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: null,
      getMemoryFn: () => null,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_146_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_146_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 180,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatList.bind(null, 10)],
      metadata: lowered_import_146_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatU32, typeIdx: 3 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_147_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_147_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 181,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_147_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_148_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_148_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 182,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_148_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_149_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_149_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 183,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30)],
      metadata: lowered_import_149_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_150_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_150_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 184,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30),_liftFlatList.bind(null, 4)],
      metadata: lowered_import_150_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_151_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_151_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 185,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30)],
      metadata: lowered_import_151_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_152_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_152_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 186,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatBorrow.bind(null, 32),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
      metadata: lowered_import_152_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_153_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_153_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 187,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_153_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 187), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_154_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_154_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 188,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatEnum.bind(null, 5)],
      metadata: lowered_import_154_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_155_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_155_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 189,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_155_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatStringUTF8, typeIdx: 1 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_156_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_156_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 190,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatEnum.bind(null, 4)],
      metadata: lowered_import_156_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 31), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_157_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_157_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 191,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatU64],
      metadata: lowered_import_157_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_158_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_158_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 192,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_158_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 3), typeIdx: 0 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_159_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_159_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 193,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_159_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 0)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_160_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_160_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 194,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 33)],
      metadata: lowered_import_160_metadata,
      resultLowerFns: [_lowerFlatStringUTF8],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_161_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_161_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 195,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_161_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_162_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_162_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 196,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_162_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_163_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_163_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 197,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30),_liftFlatList.bind(null, 4)],
      metadata: lowered_import_163_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_164_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_164_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 198,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30)],
      metadata: lowered_import_164_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_165_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_165_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 199,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30),_liftFlatU64],
      metadata: lowered_import_165_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_166_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_166_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 200,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30),_liftFlatU64],
      metadata: lowered_import_166_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_167_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_167_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 201,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30),_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_167_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_168_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_168_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 202,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 30),_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_168_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_169_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_169_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 203,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_169_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 10)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_170_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_170_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 204,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_170_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 11)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_171_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_171_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 205,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_171_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 11)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_172_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_172_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 206,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 33)],
      metadata: lowered_import_172_metadata,
      resultLowerFns: [_lowerFlatOption.bind(null, 5)],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_173_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_173_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 207,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatU64],
      metadata: lowered_import_173_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 29), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_174_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_174_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 208,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatU64],
      metadata: lowered_import_174_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 30), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_175_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_175_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 209,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_175_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 30), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_176_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_176_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 210,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatU64,_liftFlatU64,_liftFlatEnum.bind(null, 1)],
      metadata: lowered_import_176_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_177_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_177_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 211,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_177_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_178_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_178_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 212,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_178_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatFlags.bind(null, 0), align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_179_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_179_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 213,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_179_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_180_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_180_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 214,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatU64],
      metadata: lowered_import_180_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_181_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_181_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 215,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],]),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],])],
      metadata: lowered_import_181_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_182_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_182_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 216,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatU64,_liftFlatU64],
      metadata: lowered_import_182_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 37), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_183_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_183_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 217,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatList.bind(null, 4),_liftFlatU64],
      metadata: lowered_import_183_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_184_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_184_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 218,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_184_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 35), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_185_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_185_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 219,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_185_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_186_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_186_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 220,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8],
      metadata: lowered_import_186_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_187_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_187_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 221,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_187_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'type', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 8 },{ field: 'link-count', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'size', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'data-access-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'data-modification-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'status-change-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_188_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_188_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 222,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8],
      metadata: lowered_import_188_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'type', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 8 },{ field: 'link-count', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'size', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'data-access-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'data-modification-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'status-change-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_189_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_189_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 223,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],]),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],])],
      metadata: lowered_import_189_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_190_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_190_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 224,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8],
      metadata: lowered_import_190_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_191_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_191_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 225,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatFlags.bind(null, 2),_liftFlatFlags.bind(null, 0)],
      metadata: lowered_import_191_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 34), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_192_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_192_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 226,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8],
      metadata: lowered_import_192_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatStringUTF8, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_193_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_193_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 227,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8],
      metadata: lowered_import_193_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_194_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_194_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 228,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8,_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8],
      metadata: lowered_import_194_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_195_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_195_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 229,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8,_liftFlatStringUTF8],
      metadata: lowered_import_195_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_196_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_196_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 230,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatStringUTF8],
      metadata: lowered_import_196_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_197_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_197_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 231,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34)],
      metadata: lowered_import_197_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'lower', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'upper', lowerFn: _lowerFlatU64, align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_198_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_198_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 232,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 34),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8],
      metadata: lowered_import_198_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'lower', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'upper', lowerFn: _lowerFlatU64, align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_199_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_199_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 233,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 35)],
      metadata: lowered_import_199_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_200_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_200_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 234,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_200_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 214), typeIdx: 11 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_201_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_201_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 235,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36),_liftFlatBorrow.bind(null, 32),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
      metadata: lowered_import_201_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_202_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_202_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 236,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_202_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_203_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_203_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 237,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36),_liftFlatOption.bind(null, 6)],
      metadata: lowered_import_203_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 217), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_204_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_204_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 238,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_204_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_205_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_205_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 239,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_205_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_206_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_206_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 240,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_206_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU8, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_207_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_207_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 241,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36),_liftFlatU8],
      metadata: lowered_import_207_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_208_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_208_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 242,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_208_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_209_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_209_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 243,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36),_liftFlatU64],
      metadata: lowered_import_209_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_210_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_210_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 244,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36)],
      metadata: lowered_import_210_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_211_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_211_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 245,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 36),_liftFlatU64],
      metadata: lowered_import_211_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_212_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_212_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 246,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 37),_liftFlatU64],
      metadata: lowered_import_212_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatRecord([{ field: 'data', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ field: 'remote-address', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },]), typeIdx: 6 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc2,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_213_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_213_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 247,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 38)],
      metadata: lowered_import_213_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_214_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_214_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 248,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 38),_liftFlatList.bind(null, 7)],
      metadata: lowered_import_214_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_215_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_215_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 249,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatEnum.bind(null, 4)],
      metadata: lowered_import_215_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 36), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_216_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_216_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 250,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatBorrow.bind(null, 32),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
      metadata: lowered_import_216_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_217_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_217_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 251,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_217_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_218_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_218_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 252,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_218_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_219_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_219_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 253,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_219_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_220_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_220_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 254,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_220_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 225), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_221_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_221_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 255,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_221_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_222_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_222_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 256,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_222_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_223_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_223_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 257,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatU64],
      metadata: lowered_import_223_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_224_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_224_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 258,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_224_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatBool, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_225_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_225_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 259,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatBool],
      metadata: lowered_import_225_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_226_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_226_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 260,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_226_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_227_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_227_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 261,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatU64],
      metadata: lowered_import_227_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_228_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_228_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 262,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_228_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_229_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_229_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 263,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatU64],
      metadata: lowered_import_229_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_230_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_230_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 264,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_230_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU32, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_231_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_231_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 265,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatU32],
      metadata: lowered_import_231_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_232_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_232_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 266,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_232_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU8, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_233_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_233_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 267,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatU8],
      metadata: lowered_import_233_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_234_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_234_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 268,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_234_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_235_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_235_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 269,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatU64],
      metadata: lowered_import_235_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_236_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_236_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 270,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31)],
      metadata: lowered_import_236_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_237_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_237_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 271,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 31),_liftFlatU64],
      metadata: lowered_import_237_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_238_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_238_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 272,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 32),_liftFlatStringUTF8],
      metadata: lowered_import_238_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 39), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_239_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_239_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 273,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 39)],
      metadata: lowered_import_239_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 7), align32: 2 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => null,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_240_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_240_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 274,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_240_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatStringUTF8, typeIdx: 1 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc3,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_241_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_241_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 275,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_241_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 3), typeIdx: 0 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc3,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_242_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_242_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 276,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 35)],
      metadata: lowered_import_242_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 0), align32: 1 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc3,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_243_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_243_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 277,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_243_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc3,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_244_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_244_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 278,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [_liftFlatBorrow.bind(null, 29),_liftFlatU64],
      metadata: lowered_import_244_metadata,
      resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList({ elemLowerFn: _lowerFlatU8, typeIdx: 4 }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 33), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc3,
    },
    ),
  });
  
  
  GlobalComponentAsyncLowers.define({
    componentIdx: lowered_import_245_metadata.moduleIdx,
    qualifiedImportFn: lowered_import_245_metadata.qualifiedImportFn,
    fn: _lowerImport.bind(
    null,
    {
      trampolineIdx: 279,
      componentIdx: 3,
      isAsync: false,
      paramLiftFns: [],
      metadata: lowered_import_245_metadata,
      resultLowerFns: [_lowerFlatList({ elemLowerFn: _lowerFlatTuple.bind(null, 214), typeIdx: 11 })],
      getCallbackFn: () => null,
      getPostReturnFn: () => null,
      isCancellable: false,
      memoryIdx: 1,
      getMemoryFn: () => memory1,
      getReallocFn: () => realloc3,
    },
    ),
  });
  
  ({ exports: exports0 } = instantiateCore(module2));
  ({ exports: exports1 } = instantiateCore(module0, {
    'wasi:cli/environment@0.2.0': {
      'get-arguments': exports0['9'],
      'get-environment': exports0['28'],
      'initial-cwd': exports0['29'],
    },
    'wasi:cli/environment@0.2.3': {
      'get-arguments': exports0['9'],
    },
    'wasi:cli/exit@0.2.0': {
      exit: trampoline13,
    },
    'wasi:cli/terminal-input@0.2.0': {
      '[resource-drop]terminal-input': trampoline31,
    },
    'wasi:cli/terminal-output@0.2.0': {
      '[resource-drop]terminal-output': trampoline32,
    },
    'wasi:cli/terminal-stderr@0.2.0': {
      'get-terminal-stderr': exports0['41'],
    },
    'wasi:cli/terminal-stdin@0.2.0': {
      'get-terminal-stdin': exports0['39'],
    },
    'wasi:cli/terminal-stdout@0.2.0': {
      'get-terminal-stdout': exports0['40'],
    },
    'wasi:clocks/monotonic-clock@0.2.3': {
      now: trampoline7,
      'subscribe-duration': trampoline9,
      'subscribe-instant': trampoline8,
    },
    'wasi:filesystem/preopens@0.2.0': {
      'get-directories': exports0['70'],
    },
    'wasi:filesystem/types@0.2.0': {
      '[method]descriptor.advise': exports0['46'],
      '[method]descriptor.append-via-stream': exports0['45'],
      '[method]descriptor.create-directory-at': exports0['56'],
      '[method]descriptor.get-flags': exports0['48'],
      '[method]descriptor.get-type': exports0['49'],
      '[method]descriptor.is-same-object': trampoline15,
      '[method]descriptor.link-at': exports0['60'],
      '[method]descriptor.metadata-hash': exports0['67'],
      '[method]descriptor.metadata-hash-at': exports0['68'],
      '[method]descriptor.open-at': exports0['61'],
      '[method]descriptor.read': exports0['52'],
      '[method]descriptor.read-directory': exports0['54'],
      '[method]descriptor.read-via-stream': exports0['43'],
      '[method]descriptor.readlink-at': exports0['62'],
      '[method]descriptor.remove-directory-at': exports0['63'],
      '[method]descriptor.rename-at': exports0['64'],
      '[method]descriptor.set-size': exports0['50'],
      '[method]descriptor.set-times': exports0['51'],
      '[method]descriptor.set-times-at': exports0['59'],
      '[method]descriptor.stat': exports0['57'],
      '[method]descriptor.stat-at': exports0['58'],
      '[method]descriptor.symlink-at': exports0['65'],
      '[method]descriptor.sync': exports0['55'],
      '[method]descriptor.sync-data': exports0['47'],
      '[method]descriptor.unlink-file-at': exports0['66'],
      '[method]descriptor.write': exports0['53'],
      '[method]descriptor.write-via-stream': exports0['44'],
      '[method]directory-entry-stream.read-directory-entry': exports0['69'],
      '[resource-drop]descriptor': trampoline24,
      '[resource-drop]directory-entry-stream': trampoline25,
      'filesystem-error-code': exports0['42'],
    },
    'wasi:io/error@0.2.0': {
      '[method]error.to-debug-string': exports0['30'],
      '[resource-drop]error': trampoline23,
    },
    'wasi:io/poll@0.2.0': {
      '[method]pollable.block': trampoline4,
      '[method]pollable.ready': trampoline14,
      '[resource-drop]pollable': trampoline0,
      poll: exports0['0'],
    },
    'wasi:io/poll@0.2.3': {
      '[method]pollable.block': trampoline4,
      '[resource-drop]pollable': trampoline0,
      poll: exports0['0'],
    },
    'wasi:io/streams@0.2.0': {
      '[method]input-stream.blocking-read': exports0['2'],
      '[method]input-stream.blocking-skip': exports0['32'],
      '[method]input-stream.read': exports0['1'],
      '[method]input-stream.skip': exports0['31'],
      '[method]input-stream.subscribe': trampoline5,
      '[method]output-stream.blocking-flush': exports0['5'],
      '[method]output-stream.blocking-splice': exports0['38'],
      '[method]output-stream.blocking-write-and-flush': exports0['33'],
      '[method]output-stream.blocking-write-zeroes-and-flush': exports0['36'],
      '[method]output-stream.check-write': exports0['3'],
      '[method]output-stream.flush': exports0['34'],
      '[method]output-stream.splice': exports0['37'],
      '[method]output-stream.subscribe': trampoline6,
      '[method]output-stream.write': exports0['4'],
      '[method]output-stream.write-zeroes': exports0['35'],
      '[resource-drop]input-stream': trampoline1,
      '[resource-drop]output-stream': trampoline2,
    },
    'wasi:io/streams@0.2.3': {
      '[method]input-stream.blocking-read': exports0['2'],
      '[method]input-stream.read': exports0['1'],
      '[method]input-stream.subscribe': trampoline5,
      '[method]output-stream.blocking-flush': exports0['5'],
      '[method]output-stream.check-write': exports0['3'],
      '[method]output-stream.subscribe': trampoline6,
      '[method]output-stream.write': exports0['4'],
      '[resource-drop]input-stream': trampoline1,
      '[resource-drop]output-stream': trampoline2,
    },
    'wasi:random/random@0.2.3': {
      'get-random-bytes': exports0['11'],
      'get-random-u64': trampoline12,
    },
    'wasi:sockets/instance-network@0.2.0': {
      'instance-network': trampoline10,
    },
    'wasi:sockets/instance-network@0.2.3': {
      'instance-network': trampoline10,
    },
    'wasi:sockets/ip-name-lookup@0.2.0': {
      '[method]resolve-address-stream.resolve-next-address': exports0['109'],
      '[method]resolve-address-stream.subscribe': trampoline22,
      '[resource-drop]resolve-address-stream': trampoline30,
      'resolve-addresses': exports0['108'],
    },
    'wasi:sockets/network@0.2.0': {
      '[resource-drop]network': trampoline26,
    },
    'wasi:sockets/tcp-create-socket@0.2.0': {
      'create-tcp-socket': exports0['10'],
    },
    'wasi:sockets/tcp-create-socket@0.2.3': {
      'create-tcp-socket': exports0['10'],
    },
    'wasi:sockets/tcp@0.2.0': {
      '[method]tcp-socket.accept': exports0['90'],
      '[method]tcp-socket.address-family': trampoline21,
      '[method]tcp-socket.finish-bind': exports0['87'],
      '[method]tcp-socket.finish-connect': exports0['7'],
      '[method]tcp-socket.finish-listen': exports0['89'],
      '[method]tcp-socket.hop-limit': exports0['102'],
      '[method]tcp-socket.is-listening': trampoline20,
      '[method]tcp-socket.keep-alive-count': exports0['100'],
      '[method]tcp-socket.keep-alive-enabled': exports0['94'],
      '[method]tcp-socket.keep-alive-idle-time': exports0['96'],
      '[method]tcp-socket.keep-alive-interval': exports0['98'],
      '[method]tcp-socket.local-address': exports0['91'],
      '[method]tcp-socket.receive-buffer-size': exports0['104'],
      '[method]tcp-socket.remote-address': exports0['92'],
      '[method]tcp-socket.send-buffer-size': exports0['106'],
      '[method]tcp-socket.set-hop-limit': exports0['103'],
      '[method]tcp-socket.set-keep-alive-count': exports0['101'],
      '[method]tcp-socket.set-keep-alive-enabled': exports0['95'],
      '[method]tcp-socket.set-keep-alive-idle-time': exports0['97'],
      '[method]tcp-socket.set-keep-alive-interval': exports0['99'],
      '[method]tcp-socket.set-listen-backlog-size': exports0['93'],
      '[method]tcp-socket.set-receive-buffer-size': exports0['105'],
      '[method]tcp-socket.set-send-buffer-size': exports0['107'],
      '[method]tcp-socket.shutdown': exports0['8'],
      '[method]tcp-socket.start-bind': exports0['86'],
      '[method]tcp-socket.start-connect': exports0['6'],
      '[method]tcp-socket.start-listen': exports0['88'],
      '[method]tcp-socket.subscribe': trampoline11,
      '[resource-drop]tcp-socket': trampoline3,
    },
    'wasi:sockets/tcp@0.2.3': {
      '[method]tcp-socket.finish-connect': exports0['7'],
      '[method]tcp-socket.shutdown': exports0['8'],
      '[method]tcp-socket.start-connect': exports0['6'],
      '[method]tcp-socket.subscribe': trampoline11,
      '[resource-drop]tcp-socket': trampoline3,
    },
    'wasi:sockets/udp-create-socket@0.2.0': {
      'create-udp-socket': exports0['85'],
    },
    'wasi:sockets/udp@0.2.0': {
      '[method]incoming-datagram-stream.receive': exports0['82'],
      '[method]incoming-datagram-stream.subscribe': trampoline18,
      '[method]outgoing-datagram-stream.check-send': exports0['83'],
      '[method]outgoing-datagram-stream.send': exports0['84'],
      '[method]outgoing-datagram-stream.subscribe': trampoline19,
      '[method]udp-socket.address-family': trampoline16,
      '[method]udp-socket.finish-bind': exports0['72'],
      '[method]udp-socket.local-address': exports0['74'],
      '[method]udp-socket.receive-buffer-size': exports0['78'],
      '[method]udp-socket.remote-address': exports0['75'],
      '[method]udp-socket.send-buffer-size': exports0['80'],
      '[method]udp-socket.set-receive-buffer-size': exports0['79'],
      '[method]udp-socket.set-send-buffer-size': exports0['81'],
      '[method]udp-socket.set-unicast-hop-limit': exports0['77'],
      '[method]udp-socket.start-bind': exports0['71'],
      '[method]udp-socket.stream': exports0['73'],
      '[method]udp-socket.subscribe': trampoline17,
      '[method]udp-socket.unicast-hop-limit': exports0['76'],
      '[resource-drop]incoming-datagram-stream': trampoline28,
      '[resource-drop]outgoing-datagram-stream': trampoline29,
      '[resource-drop]udp-socket': trampoline27,
    },
    wasi_snapshot_preview1: {
      args_get: exports0['12'],
      args_sizes_get: exports0['13'],
      environ_get: exports0['14'],
      environ_sizes_get: exports0['15'],
      fd_close: exports0['16'],
      fd_fdstat_set_flags: exports0['17'],
      fd_prestat_dir_name: exports0['19'],
      fd_prestat_get: exports0['18'],
      fd_read: exports0['20'],
      fd_readdir: exports0['21'],
      fd_seek: exports0['22'],
      path_filestat_get: exports0['23'],
      path_open: exports0['24'],
      path_remove_directory: exports0['25'],
      path_unlink_file: exports0['26'],
      proc_exit: exports0['27'],
    },
  }));
  ({ exports: exports2 } = instantiateCore(module1, {
    __main_module__: {
      cabi_realloc_adapter: exports1.cabi_realloc_adapter,
    },
    env: {
      memory: exports1.memory,
    },
    'wasi:cli/environment@0.2.3': {
      'get-arguments': exports0['110'],
      'get-environment': exports0['111'],
    },
    'wasi:cli/exit@0.2.3': {
      exit: trampoline13,
    },
    'wasi:cli/stderr@0.2.3': {
      'get-stderr': trampoline33,
    },
    'wasi:cli/stdin@0.2.3': {
      'get-stdin': trampoline34,
    },
    'wasi:cli/stdout@0.2.3': {
      'get-stdout': trampoline35,
    },
    'wasi:filesystem/preopens@0.2.3': {
      'get-directories': exports0['127'],
    },
    'wasi:filesystem/types@0.2.3': {
      '[method]descriptor.get-type': exports0['112'],
      '[method]descriptor.metadata-hash': exports0['113'],
      '[method]descriptor.metadata-hash-at': exports0['115'],
      '[method]descriptor.open-at': exports0['122'],
      '[method]descriptor.read-directory': exports0['119'],
      '[method]descriptor.read-via-stream': exports0['118'],
      '[method]descriptor.remove-directory-at': exports0['116'],
      '[method]descriptor.stat': exports0['120'],
      '[method]descriptor.stat-at': exports0['121'],
      '[method]descriptor.unlink-file-at': exports0['117'],
      '[method]directory-entry-stream.read-directory-entry': exports0['123'],
      '[resource-drop]descriptor': trampoline24,
      '[resource-drop]directory-entry-stream': trampoline25,
      'filesystem-error-code': exports0['114'],
    },
    'wasi:io/error@0.2.3': {
      '[resource-drop]error': trampoline23,
    },
    'wasi:io/streams@0.2.3': {
      '[method]input-stream.blocking-read': exports0['125'],
      '[method]input-stream.read': exports0['124'],
      '[method]output-stream.blocking-write-and-flush': exports0['126'],
      '[resource-drop]input-stream': trampoline1,
      '[resource-drop]output-stream': trampoline2,
    },
  }));
  memory0 = exports1.memory;
  GlobalComponentMemories.save({ idx: 0, componentIdx: 1, memory: memory0 });
  realloc0 = exports1.cabi_realloc;
  realloc1 = exports2.cabi_import_realloc;
  ({ exports: exports3 } = instantiateCore(module3, {
    '': {
      $imports: exports0.$imports,
      '0': trampoline36,
      '1': trampoline37,
      '10': trampoline46,
      '100': trampoline120,
      '101': trampoline121,
      '102': trampoline122,
      '103': trampoline123,
      '104': trampoline124,
      '105': trampoline125,
      '106': trampoline126,
      '107': trampoline127,
      '108': trampoline128,
      '109': trampoline129,
      '11': trampoline47,
      '110': trampoline130,
      '111': trampoline131,
      '112': trampoline69,
      '113': trampoline87,
      '114': trampoline62,
      '115': trampoline88,
      '116': trampoline83,
      '117': trampoline86,
      '118': trampoline63,
      '119': trampoline74,
      '12': exports2.args_get,
      '120': trampoline77,
      '121': trampoline78,
      '122': trampoline81,
      '123': trampoline132,
      '124': trampoline133,
      '125': trampoline134,
      '126': trampoline53,
      '127': trampoline135,
      '13': exports2.args_sizes_get,
      '14': exports2.environ_get,
      '15': exports2.environ_sizes_get,
      '16': exports2.fd_close,
      '17': exports2.fd_fdstat_set_flags,
      '18': exports2.fd_prestat_get,
      '19': exports2.fd_prestat_dir_name,
      '2': trampoline38,
      '20': exports2.fd_read,
      '21': exports2.fd_readdir,
      '22': exports2.fd_seek,
      '23': exports2.path_filestat_get,
      '24': exports2.path_open,
      '25': exports2.path_remove_directory,
      '26': exports2.path_unlink_file,
      '27': exports2.proc_exit,
      '28': trampoline48,
      '29': trampoline49,
      '3': trampoline39,
      '30': trampoline50,
      '31': trampoline51,
      '32': trampoline52,
      '33': trampoline53,
      '34': trampoline54,
      '35': trampoline55,
      '36': trampoline56,
      '37': trampoline57,
      '38': trampoline58,
      '39': trampoline59,
      '4': trampoline40,
      '40': trampoline60,
      '41': trampoline61,
      '42': trampoline62,
      '43': trampoline63,
      '44': trampoline64,
      '45': trampoline65,
      '46': trampoline66,
      '47': trampoline67,
      '48': trampoline68,
      '49': trampoline69,
      '5': trampoline41,
      '50': trampoline70,
      '51': trampoline71,
      '52': trampoline72,
      '53': trampoline73,
      '54': trampoline74,
      '55': trampoline75,
      '56': trampoline76,
      '57': trampoline77,
      '58': trampoline78,
      '59': trampoline79,
      '6': trampoline42,
      '60': trampoline80,
      '61': trampoline81,
      '62': trampoline82,
      '63': trampoline83,
      '64': trampoline84,
      '65': trampoline85,
      '66': trampoline86,
      '67': trampoline87,
      '68': trampoline88,
      '69': trampoline89,
      '7': trampoline43,
      '70': trampoline90,
      '71': trampoline91,
      '72': trampoline92,
      '73': trampoline93,
      '74': trampoline94,
      '75': trampoline95,
      '76': trampoline96,
      '77': trampoline97,
      '78': trampoline98,
      '79': trampoline99,
      '8': trampoline44,
      '80': trampoline100,
      '81': trampoline101,
      '82': trampoline102,
      '83': trampoline103,
      '84': trampoline104,
      '85': trampoline105,
      '86': trampoline106,
      '87': trampoline107,
      '88': trampoline108,
      '89': trampoline109,
      '9': trampoline45,
      '90': trampoline110,
      '91': trampoline111,
      '92': trampoline112,
      '93': trampoline113,
      '94': trampoline114,
      '95': trampoline115,
      '96': trampoline116,
      '97': trampoline117,
      '98': trampoline118,
      '99': trampoline119,
    },
  }));
  ({ exports: exports4 } = instantiateCore(module6));
  ({ exports: exports5 } = instantiateCore(module8, {
    callee: {
      adapter0: exports1['docs:adder/add@0.1.0#add'],
      adapter1: exports1['docs:adder/add@0.1.0#sub'],
      adapter2: exports1['docs:adder/add@0.1.0#mul'],
    },
    flags: {
      instance1: instanceFlags1,
      instance3: instanceFlags3,
    },
    post_return: {
      adapter0: exports1['cabi_post_docs:adder/add@0.1.0#add'],
      adapter1: exports1['cabi_post_docs:adder/add@0.1.0#sub'],
      adapter2: exports1['cabi_post_docs:adder/add@0.1.0#mul'],
    },
  }));
  ({ exports: exports6 } = instantiateCore(module4, {
    '[export]docs:calculator/calculate@0.1.0': {
      '[resource-drop]calc-session': trampoline163,
      '[resource-drop]number-stream': trampoline166,
      '[resource-new]calc-session': trampoline161,
      '[resource-new]number-stream': trampoline164,
      '[resource-rep]calc-session': trampoline162,
      '[resource-rep]number-stream': trampoline165,
    },
    'docs:adder/add@0.1.0': {
      add: exports5.adapter0,
      mul: exports5.adapter2,
      sub: exports5.adapter1,
    },
    'docs:calculator/stream-sink@0.1.0': {
      'on-done': trampoline160,
      'on-number': trampoline159,
    },
    'wasi:cli/environment@0.2.0': {
      'get-arguments': exports4['9'],
      'get-environment': exports4['28'],
      'initial-cwd': exports4['29'],
    },
    'wasi:cli/environment@0.2.3': {
      'get-arguments': exports4['9'],
    },
    'wasi:cli/exit@0.2.0': {
      exit: trampoline149,
    },
    'wasi:cli/terminal-input@0.2.0': {
      '[resource-drop]terminal-input': trampoline175,
    },
    'wasi:cli/terminal-output@0.2.0': {
      '[resource-drop]terminal-output': trampoline176,
    },
    'wasi:cli/terminal-stderr@0.2.0': {
      'get-terminal-stderr': exports4['41'],
    },
    'wasi:cli/terminal-stdin@0.2.0': {
      'get-terminal-stdin': exports4['39'],
    },
    'wasi:cli/terminal-stdout@0.2.0': {
      'get-terminal-stdout': exports4['40'],
    },
    'wasi:clocks/monotonic-clock@0.2.3': {
      now: trampoline143,
      'subscribe-duration': trampoline145,
      'subscribe-instant': trampoline144,
    },
    'wasi:filesystem/preopens@0.2.0': {
      'get-directories': exports4['70'],
    },
    'wasi:filesystem/types@0.2.0': {
      '[method]descriptor.advise': exports4['46'],
      '[method]descriptor.append-via-stream': exports4['45'],
      '[method]descriptor.create-directory-at': exports4['56'],
      '[method]descriptor.get-flags': exports4['48'],
      '[method]descriptor.get-type': exports4['49'],
      '[method]descriptor.is-same-object': trampoline151,
      '[method]descriptor.link-at': exports4['60'],
      '[method]descriptor.metadata-hash': exports4['67'],
      '[method]descriptor.metadata-hash-at': exports4['68'],
      '[method]descriptor.open-at': exports4['61'],
      '[method]descriptor.read': exports4['52'],
      '[method]descriptor.read-directory': exports4['54'],
      '[method]descriptor.read-via-stream': exports4['43'],
      '[method]descriptor.readlink-at': exports4['62'],
      '[method]descriptor.remove-directory-at': exports4['63'],
      '[method]descriptor.rename-at': exports4['64'],
      '[method]descriptor.set-size': exports4['50'],
      '[method]descriptor.set-times': exports4['51'],
      '[method]descriptor.set-times-at': exports4['59'],
      '[method]descriptor.stat': exports4['57'],
      '[method]descriptor.stat-at': exports4['58'],
      '[method]descriptor.symlink-at': exports4['65'],
      '[method]descriptor.sync': exports4['55'],
      '[method]descriptor.sync-data': exports4['47'],
      '[method]descriptor.unlink-file-at': exports4['66'],
      '[method]descriptor.write': exports4['53'],
      '[method]descriptor.write-via-stream': exports4['44'],
      '[method]directory-entry-stream.read-directory-entry': exports4['69'],
      '[resource-drop]descriptor': trampoline168,
      '[resource-drop]directory-entry-stream': trampoline169,
      'filesystem-error-code': exports4['42'],
    },
    'wasi:io/error@0.2.0': {
      '[method]error.to-debug-string': exports4['30'],
      '[resource-drop]error': trampoline167,
    },
    'wasi:io/poll@0.2.0': {
      '[method]pollable.block': trampoline140,
      '[method]pollable.ready': trampoline150,
      '[resource-drop]pollable': trampoline136,
      poll: exports4['0'],
    },
    'wasi:io/poll@0.2.3': {
      '[method]pollable.block': trampoline140,
      '[resource-drop]pollable': trampoline136,
      poll: exports4['0'],
    },
    'wasi:io/streams@0.2.0': {
      '[method]input-stream.blocking-read': exports4['2'],
      '[method]input-stream.blocking-skip': exports4['32'],
      '[method]input-stream.read': exports4['1'],
      '[method]input-stream.skip': exports4['31'],
      '[method]input-stream.subscribe': trampoline141,
      '[method]output-stream.blocking-flush': exports4['5'],
      '[method]output-stream.blocking-splice': exports4['38'],
      '[method]output-stream.blocking-write-and-flush': exports4['33'],
      '[method]output-stream.blocking-write-zeroes-and-flush': exports4['36'],
      '[method]output-stream.check-write': exports4['3'],
      '[method]output-stream.flush': exports4['34'],
      '[method]output-stream.splice': exports4['37'],
      '[method]output-stream.subscribe': trampoline142,
      '[method]output-stream.write': exports4['4'],
      '[method]output-stream.write-zeroes': exports4['35'],
      '[resource-drop]input-stream': trampoline137,
      '[resource-drop]output-stream': trampoline138,
    },
    'wasi:io/streams@0.2.3': {
      '[method]input-stream.blocking-read': exports4['2'],
      '[method]input-stream.read': exports4['1'],
      '[method]input-stream.subscribe': trampoline141,
      '[method]output-stream.blocking-flush': exports4['5'],
      '[method]output-stream.check-write': exports4['3'],
      '[method]output-stream.subscribe': trampoline142,
      '[method]output-stream.write': exports4['4'],
      '[resource-drop]input-stream': trampoline137,
      '[resource-drop]output-stream': trampoline138,
    },
    'wasi:random/random@0.2.3': {
      'get-random-bytes': exports4['11'],
      'get-random-u64': trampoline148,
    },
    'wasi:sockets/instance-network@0.2.0': {
      'instance-network': trampoline146,
    },
    'wasi:sockets/instance-network@0.2.3': {
      'instance-network': trampoline146,
    },
    'wasi:sockets/ip-name-lookup@0.2.0': {
      '[method]resolve-address-stream.resolve-next-address': exports4['109'],
      '[method]resolve-address-stream.subscribe': trampoline158,
      '[resource-drop]resolve-address-stream': trampoline174,
      'resolve-addresses': exports4['108'],
    },
    'wasi:sockets/network@0.2.0': {
      '[resource-drop]network': trampoline170,
    },
    'wasi:sockets/tcp-create-socket@0.2.0': {
      'create-tcp-socket': exports4['10'],
    },
    'wasi:sockets/tcp-create-socket@0.2.3': {
      'create-tcp-socket': exports4['10'],
    },
    'wasi:sockets/tcp@0.2.0': {
      '[method]tcp-socket.accept': exports4['90'],
      '[method]tcp-socket.address-family': trampoline157,
      '[method]tcp-socket.finish-bind': exports4['87'],
      '[method]tcp-socket.finish-connect': exports4['7'],
      '[method]tcp-socket.finish-listen': exports4['89'],
      '[method]tcp-socket.hop-limit': exports4['102'],
      '[method]tcp-socket.is-listening': trampoline156,
      '[method]tcp-socket.keep-alive-count': exports4['100'],
      '[method]tcp-socket.keep-alive-enabled': exports4['94'],
      '[method]tcp-socket.keep-alive-idle-time': exports4['96'],
      '[method]tcp-socket.keep-alive-interval': exports4['98'],
      '[method]tcp-socket.local-address': exports4['91'],
      '[method]tcp-socket.receive-buffer-size': exports4['104'],
      '[method]tcp-socket.remote-address': exports4['92'],
      '[method]tcp-socket.send-buffer-size': exports4['106'],
      '[method]tcp-socket.set-hop-limit': exports4['103'],
      '[method]tcp-socket.set-keep-alive-count': exports4['101'],
      '[method]tcp-socket.set-keep-alive-enabled': exports4['95'],
      '[method]tcp-socket.set-keep-alive-idle-time': exports4['97'],
      '[method]tcp-socket.set-keep-alive-interval': exports4['99'],
      '[method]tcp-socket.set-listen-backlog-size': exports4['93'],
      '[method]tcp-socket.set-receive-buffer-size': exports4['105'],
      '[method]tcp-socket.set-send-buffer-size': exports4['107'],
      '[method]tcp-socket.shutdown': exports4['8'],
      '[method]tcp-socket.start-bind': exports4['86'],
      '[method]tcp-socket.start-connect': exports4['6'],
      '[method]tcp-socket.start-listen': exports4['88'],
      '[method]tcp-socket.subscribe': trampoline147,
      '[resource-drop]tcp-socket': trampoline139,
    },
    'wasi:sockets/tcp@0.2.3': {
      '[method]tcp-socket.finish-connect': exports4['7'],
      '[method]tcp-socket.shutdown': exports4['8'],
      '[method]tcp-socket.start-connect': exports4['6'],
      '[method]tcp-socket.subscribe': trampoline147,
      '[resource-drop]tcp-socket': trampoline139,
    },
    'wasi:sockets/udp-create-socket@0.2.0': {
      'create-udp-socket': exports4['85'],
    },
    'wasi:sockets/udp@0.2.0': {
      '[method]incoming-datagram-stream.receive': exports4['82'],
      '[method]incoming-datagram-stream.subscribe': trampoline154,
      '[method]outgoing-datagram-stream.check-send': exports4['83'],
      '[method]outgoing-datagram-stream.send': exports4['84'],
      '[method]outgoing-datagram-stream.subscribe': trampoline155,
      '[method]udp-socket.address-family': trampoline152,
      '[method]udp-socket.finish-bind': exports4['72'],
      '[method]udp-socket.local-address': exports4['74'],
      '[method]udp-socket.receive-buffer-size': exports4['78'],
      '[method]udp-socket.remote-address': exports4['75'],
      '[method]udp-socket.send-buffer-size': exports4['80'],
      '[method]udp-socket.set-receive-buffer-size': exports4['79'],
      '[method]udp-socket.set-send-buffer-size': exports4['81'],
      '[method]udp-socket.set-unicast-hop-limit': exports4['77'],
      '[method]udp-socket.start-bind': exports4['71'],
      '[method]udp-socket.stream': exports4['73'],
      '[method]udp-socket.subscribe': trampoline153,
      '[method]udp-socket.unicast-hop-limit': exports4['76'],
      '[resource-drop]incoming-datagram-stream': trampoline172,
      '[resource-drop]outgoing-datagram-stream': trampoline173,
      '[resource-drop]udp-socket': trampoline171,
    },
    wasi_snapshot_preview1: {
      args_get: exports4['12'],
      args_sizes_get: exports4['13'],
      environ_get: exports4['14'],
      environ_sizes_get: exports4['15'],
      fd_close: exports4['16'],
      fd_fdstat_set_flags: exports4['17'],
      fd_prestat_dir_name: exports4['19'],
      fd_prestat_get: exports4['18'],
      fd_read: exports4['20'],
      fd_readdir: exports4['21'],
      fd_seek: exports4['22'],
      path_filestat_get: exports4['23'],
      path_open: exports4['24'],
      path_remove_directory: exports4['25'],
      path_unlink_file: exports4['26'],
      proc_exit: exports4['27'],
    },
  }));
  ({ exports: exports7 } = instantiateCore(module5, {
    __main_module__: {
      cabi_realloc_adapter: exports6.cabi_realloc_adapter,
    },
    env: {
      memory: exports6.memory,
    },
    'wasi:cli/environment@0.2.3': {
      'get-arguments': exports4['110'],
      'get-environment': exports4['111'],
    },
    'wasi:cli/exit@0.2.3': {
      exit: trampoline149,
    },
    'wasi:cli/stderr@0.2.3': {
      'get-stderr': trampoline177,
    },
    'wasi:cli/stdin@0.2.3': {
      'get-stdin': trampoline178,
    },
    'wasi:cli/stdout@0.2.3': {
      'get-stdout': trampoline179,
    },
    'wasi:filesystem/preopens@0.2.3': {
      'get-directories': exports4['127'],
    },
    'wasi:filesystem/types@0.2.3': {
      '[method]descriptor.get-type': exports4['112'],
      '[method]descriptor.metadata-hash': exports4['113'],
      '[method]descriptor.metadata-hash-at': exports4['115'],
      '[method]descriptor.open-at': exports4['122'],
      '[method]descriptor.read-directory': exports4['119'],
      '[method]descriptor.read-via-stream': exports4['118'],
      '[method]descriptor.remove-directory-at': exports4['116'],
      '[method]descriptor.stat': exports4['120'],
      '[method]descriptor.stat-at': exports4['121'],
      '[method]descriptor.unlink-file-at': exports4['117'],
      '[method]directory-entry-stream.read-directory-entry': exports4['123'],
      '[resource-drop]descriptor': trampoline168,
      '[resource-drop]directory-entry-stream': trampoline169,
      'filesystem-error-code': exports4['114'],
    },
    'wasi:io/error@0.2.3': {
      '[resource-drop]error': trampoline167,
    },
    'wasi:io/streams@0.2.3': {
      '[method]input-stream.blocking-read': exports4['125'],
      '[method]input-stream.read': exports4['124'],
      '[method]output-stream.blocking-write-and-flush': exports4['126'],
      '[resource-drop]input-stream': trampoline137,
      '[resource-drop]output-stream': trampoline138,
    },
  }));
  memory1 = exports6.memory;
  GlobalComponentMemories.save({ idx: 1, componentIdx: 6, memory: memory1 });
  realloc2 = exports6.cabi_realloc;
  realloc3 = exports7.cabi_import_realloc;
  ({ exports: exports8 } = instantiateCore(module7, {
    '': {
      $imports: exports4.$imports,
      '0': trampoline180,
      '1': trampoline181,
      '10': trampoline190,
      '100': trampoline264,
      '101': trampoline265,
      '102': trampoline266,
      '103': trampoline267,
      '104': trampoline268,
      '105': trampoline269,
      '106': trampoline270,
      '107': trampoline271,
      '108': trampoline272,
      '109': trampoline273,
      '11': trampoline191,
      '110': trampoline274,
      '111': trampoline275,
      '112': trampoline213,
      '113': trampoline231,
      '114': trampoline206,
      '115': trampoline232,
      '116': trampoline227,
      '117': trampoline230,
      '118': trampoline207,
      '119': trampoline218,
      '12': exports7.args_get,
      '120': trampoline221,
      '121': trampoline222,
      '122': trampoline225,
      '123': trampoline276,
      '124': trampoline277,
      '125': trampoline278,
      '126': trampoline197,
      '127': trampoline279,
      '13': exports7.args_sizes_get,
      '14': exports7.environ_get,
      '15': exports7.environ_sizes_get,
      '16': exports7.fd_close,
      '17': exports7.fd_fdstat_set_flags,
      '18': exports7.fd_prestat_get,
      '19': exports7.fd_prestat_dir_name,
      '2': trampoline182,
      '20': exports7.fd_read,
      '21': exports7.fd_readdir,
      '22': exports7.fd_seek,
      '23': exports7.path_filestat_get,
      '24': exports7.path_open,
      '25': exports7.path_remove_directory,
      '26': exports7.path_unlink_file,
      '27': exports7.proc_exit,
      '28': trampoline192,
      '29': trampoline193,
      '3': trampoline183,
      '30': trampoline194,
      '31': trampoline195,
      '32': trampoline196,
      '33': trampoline197,
      '34': trampoline198,
      '35': trampoline199,
      '36': trampoline200,
      '37': trampoline201,
      '38': trampoline202,
      '39': trampoline203,
      '4': trampoline184,
      '40': trampoline204,
      '41': trampoline205,
      '42': trampoline206,
      '43': trampoline207,
      '44': trampoline208,
      '45': trampoline209,
      '46': trampoline210,
      '47': trampoline211,
      '48': trampoline212,
      '49': trampoline213,
      '5': trampoline185,
      '50': trampoline214,
      '51': trampoline215,
      '52': trampoline216,
      '53': trampoline217,
      '54': trampoline218,
      '55': trampoline219,
      '56': trampoline220,
      '57': trampoline221,
      '58': trampoline222,
      '59': trampoline223,
      '6': trampoline186,
      '60': trampoline224,
      '61': trampoline225,
      '62': trampoline226,
      '63': trampoline227,
      '64': trampoline228,
      '65': trampoline229,
      '66': trampoline230,
      '67': trampoline231,
      '68': trampoline232,
      '69': trampoline233,
      '7': trampoline187,
      '70': trampoline234,
      '71': trampoline235,
      '72': trampoline236,
      '73': trampoline237,
      '74': trampoline238,
      '75': trampoline239,
      '76': trampoline240,
      '77': trampoline241,
      '78': trampoline242,
      '79': trampoline243,
      '8': trampoline188,
      '80': trampoline244,
      '81': trampoline245,
      '82': trampoline246,
      '83': trampoline247,
      '84': trampoline248,
      '85': trampoline249,
      '86': trampoline250,
      '87': trampoline251,
      '88': trampoline252,
      '89': trampoline253,
      '9': trampoline189,
      '90': trampoline254,
      '91': trampoline255,
      '92': trampoline256,
      '93': trampoline257,
      '94': trampoline258,
      '95': trampoline259,
      '96': trampoline260,
      '97': trampoline261,
      '98': trampoline262,
      '99': trampoline263,
    },
  }));
  postReturn0 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[constructor]calc-session'];
  postReturn1 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]calc-session.push-op'];
  postReturn2 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]calc-session.get-current'];
  postReturn3 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]calc-session.get-history'];
  postReturn4 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]calc-session.reset'];
  postReturn5 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[constructor]number-stream'];
  postReturn6 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]number-stream.start-fibonacci'];
  postReturn7 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]number-stream.start-squares'];
  postReturn8 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]number-stream.start-primes'];
  postReturn9 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]number-stream.read'];
  postReturn10 = exports6['cabi_post_docs:calculator/calculate@0.1.0#[method]number-stream.stop'];
  postReturn11 = exports6['cabi_post_docs:calculator/calculate@0.1.0#eval-expression'];
  postReturn12 = exports6['cabi_post_docs:calculator/calculate@0.1.0#eval-expression-detailed'];
  postReturn13 = exports6['cabi_post_docs:calculator/calculate@0.1.0#generate-fibonacci'];
  postReturn14 = exports6['cabi_post_docs:calculator/calculate@0.1.0#generate-squares'];
  postReturn15 = exports6['cabi_post_docs:calculator/calculate@0.1.0#generate-primes'];
  let calculate010ConstructorCalcSession;
  
  class CalcSession{
    constructor() {
      _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[constructor]calc-session"][Instruction::CallWasm] enter', {
        funcName: '[constructor]calc-session',
        paramCount: 0,
        async: false,
        postReturn: true,
      });
      const hostProvided = false;
      
      const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'calculate010ConstructorCalcSession',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: true,
      });
      
      let ret = calculate010ConstructorCalcSession();
      endCurrentTask(3);
      var handle1 = ret;
      var rsc0 = new.target === CalcSession ? this : Object.create(CalcSession.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      finalizationRegistry40.register(rsc0, handle1, rsc0);
      Object.defineProperty(rsc0, symbolDispose, { writable: true, value: emptyFunc });
      _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[constructor]calc-session"][Instruction::Return]', {
        funcName: '[constructor]calc-session',
        paramCount: 1,
        async: false,
        postReturn: true
      });
      const retCopy = rsc0;
      
      let cstate = getOrCreateAsyncState(3);
      cstate.mayLeave = false;
      postReturn0(ret);
      cstate.mayLeave = true;
      return retCopy;
      
    }
  }
  let calculate010MethodCalcSessionPushOp;
  
  CalcSession.prototype.pushOp = function pushOp(arg1, arg2) {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable40[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "CalcSession" resource.');
    }
    var handle0 = handleTable40[(handle1 << 1) + 1] & ~T_FLAG;
    var val2 = arg1;
    let enum2;
    switch (val2) {
      case 'add': {
        enum2 = 0;
        break;
      }
      case 'sub': {
        enum2 = 1;
        break;
      }
      case 'mul': {
        enum2 = 2;
        break;
      }
      default: {
        if ((arg1) instanceof Error) {
          console.error(arg1);
        }
        
        throw new TypeError(`"${val2}" is not one of the cases of op`);
      }
    }
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.push-op"][Instruction::CallWasm] enter', {
      funcName: '[method]calc-session.push-op',
      paramCount: 3,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodCalcSessionPushOp',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010MethodCalcSessionPushOp(handle0, enum2, toUint32(arg2));
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.push-op"][Instruction::Return]', {
      funcName: '[method]calc-session.push-op',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn1();
    cstate.mayLeave = true;
    
    
  };
  let calculate010MethodCalcSessionGetCurrent;
  
  CalcSession.prototype.getCurrent = function getCurrent() {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable40[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "CalcSession" resource.');
    }
    var handle0 = handleTable40[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.get-current"][Instruction::CallWasm] enter', {
      funcName: '[method]calc-session.get-current',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodCalcSessionGetCurrent',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret = calculate010MethodCalcSessionGetCurrent(handle0);
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.get-current"][Instruction::Return]', {
      funcName: '[method]calc-session.get-current',
      paramCount: 1,
      async: false,
      postReturn: true
    });
    const retCopy = ret >>> 0;
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn2(ret);
    cstate.mayLeave = true;
    return retCopy;
    
  };
  let calculate010MethodCalcSessionGetHistory;
  
  CalcSession.prototype.getHistory = function getHistory() {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable40[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "CalcSession" resource.');
    }
    var handle0 = handleTable40[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.get-history"][Instruction::CallWasm] enter', {
      funcName: '[method]calc-session.get-history',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodCalcSessionGetHistory',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret = calculate010MethodCalcSessionGetHistory(handle0);
    endCurrentTask(3);
    var len3 = dataView(memory1).getUint32(ret + 4, true);
    var base3 = dataView(memory1).getUint32(ret + 0, true);
    var result3 = [];
    for (let i = 0; i < len3; i++) {
      const base = base3 + i * 20;
      var ptr2 = dataView(memory1).getUint32(base + 4, true);
      var len2 = dataView(memory1).getUint32(base + 8, true);
      var result2 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr2, len2));
      result3.push({
        value: dataView(memory1).getInt32(base + 0, true) >>> 0,
        op: result2,
        x: dataView(memory1).getInt32(base + 12, true) >>> 0,
        y: dataView(memory1).getInt32(base + 16, true) >>> 0,
      });
    }
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.get-history"][Instruction::Return]', {
      funcName: '[method]calc-session.get-history',
      paramCount: 1,
      async: false,
      postReturn: true
    });
    const retCopy = result3;
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn3(ret);
    cstate.mayLeave = true;
    return retCopy;
    
  };
  let calculate010MethodCalcSessionReset;
  
  CalcSession.prototype.reset = function reset() {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable40[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "CalcSession" resource.');
    }
    var handle0 = handleTable40[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.reset"][Instruction::CallWasm] enter', {
      funcName: '[method]calc-session.reset',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodCalcSessionReset',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010MethodCalcSessionReset(handle0);
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]calc-session.reset"][Instruction::Return]', {
      funcName: '[method]calc-session.reset',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn4();
    cstate.mayLeave = true;
    
    
  };
  let calculate010ConstructorNumberStream;
  
  class NumberStream{
    constructor() {
      _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[constructor]number-stream"][Instruction::CallWasm] enter', {
        funcName: '[constructor]number-stream',
        paramCount: 0,
        async: false,
        postReturn: true,
      });
      const hostProvided = false;
      
      const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
        componentIdx: 3,
        isAsync: false,
        entryFnName: 'calculate010ConstructorNumberStream',
        getCallbackFn: () => null,
        callbackFnName: 'null',
        errHandling: 'none',
        callingWasmExport: true,
      });
      
      let ret = calculate010ConstructorNumberStream();
      endCurrentTask(3);
      var handle1 = ret;
      var rsc0 = new.target === NumberStream ? this : Object.create(NumberStream.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      finalizationRegistry41.register(rsc0, handle1, rsc0);
      Object.defineProperty(rsc0, symbolDispose, { writable: true, value: emptyFunc });
      _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[constructor]number-stream"][Instruction::Return]', {
        funcName: '[constructor]number-stream',
        paramCount: 1,
        async: false,
        postReturn: true
      });
      const retCopy = rsc0;
      
      let cstate = getOrCreateAsyncState(3);
      cstate.mayLeave = false;
      postReturn5(ret);
      cstate.mayLeave = true;
      return retCopy;
      
    }
  }
  let calculate010MethodNumberStreamStartFibonacci;
  
  NumberStream.prototype.startFibonacci = function startFibonacci() {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable41[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "NumberStream" resource.');
    }
    var handle0 = handleTable41[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.start-fibonacci"][Instruction::CallWasm] enter', {
      funcName: '[method]number-stream.start-fibonacci',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodNumberStreamStartFibonacci',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010MethodNumberStreamStartFibonacci(handle0);
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.start-fibonacci"][Instruction::Return]', {
      funcName: '[method]number-stream.start-fibonacci',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn6();
    cstate.mayLeave = true;
    
    
  };
  let calculate010MethodNumberStreamStartSquares;
  
  NumberStream.prototype.startSquares = function startSquares() {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable41[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "NumberStream" resource.');
    }
    var handle0 = handleTable41[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.start-squares"][Instruction::CallWasm] enter', {
      funcName: '[method]number-stream.start-squares',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodNumberStreamStartSquares',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010MethodNumberStreamStartSquares(handle0);
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.start-squares"][Instruction::Return]', {
      funcName: '[method]number-stream.start-squares',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn7();
    cstate.mayLeave = true;
    
    
  };
  let calculate010MethodNumberStreamStartPrimes;
  
  NumberStream.prototype.startPrimes = function startPrimes() {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable41[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "NumberStream" resource.');
    }
    var handle0 = handleTable41[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.start-primes"][Instruction::CallWasm] enter', {
      funcName: '[method]number-stream.start-primes',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodNumberStreamStartPrimes',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010MethodNumberStreamStartPrimes(handle0);
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.start-primes"][Instruction::Return]', {
      funcName: '[method]number-stream.start-primes',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn8();
    cstate.mayLeave = true;
    
    
  };
  let calculate010MethodNumberStreamRead;
  
  NumberStream.prototype.read = function read(arg1) {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable41[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "NumberStream" resource.');
    }
    var handle0 = handleTable41[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.read"][Instruction::CallWasm] enter', {
      funcName: '[method]number-stream.read',
      paramCount: 2,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodNumberStreamRead',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret = calculate010MethodNumberStreamRead(handle0, toUint32(arg1));
    endCurrentTask(3);
    var ptr2 = dataView(memory1).getUint32(ret + 0, true);
    var len2 = dataView(memory1).getUint32(ret + 4, true);
    var result2 = new Uint32Array(memory1.buffer.slice(ptr2, ptr2 + len2 * 4));
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.read"][Instruction::Return]', {
      funcName: '[method]number-stream.read',
      paramCount: 1,
      async: false,
      postReturn: true
    });
    const retCopy = result2;
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn9(ret);
    cstate.mayLeave = true;
    return retCopy;
    
  };
  let calculate010MethodNumberStreamStop;
  
  NumberStream.prototype.stop = function stop() {
    var handle1 = this[symbolRscHandle];
    if (!handle1 || (handleTable41[(handle1 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "NumberStream" resource.');
    }
    var handle0 = handleTable41[(handle1 << 1) + 1] & ~T_FLAG;
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.stop"][Instruction::CallWasm] enter', {
      funcName: '[method]number-stream.stop',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010MethodNumberStreamStop',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010MethodNumberStreamStop(handle0);
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="[method]number-stream.stop"][Instruction::Return]', {
      funcName: '[method]number-stream.stop',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn10();
    cstate.mayLeave = true;
    
    
  };
  let calculate010EvalExpression;
  
  function evalExpression(arg0, arg1, arg2) {
    var val0 = arg0;
    let enum0;
    switch (val0) {
      case 'add': {
        enum0 = 0;
        break;
      }
      case 'sub': {
        enum0 = 1;
        break;
      }
      case 'mul': {
        enum0 = 2;
        break;
      }
      default: {
        if ((arg0) instanceof Error) {
          console.error(arg0);
        }
        
        throw new TypeError(`"${val0}" is not one of the cases of op`);
      }
    }
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="eval-expression"][Instruction::CallWasm] enter', {
      funcName: 'eval-expression',
      paramCount: 3,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010EvalExpression',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret = calculate010EvalExpression(enum0, toUint32(arg1), toUint32(arg2));
    endCurrentTask(3);
    var ptr1 = dataView(memory1).getUint32(ret + 0, true);
    var len1 = dataView(memory1).getUint32(ret + 4, true);
    var result1 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr1, len1));
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="eval-expression"][Instruction::Return]', {
      funcName: 'eval-expression',
      paramCount: 1,
      async: false,
      postReturn: true
    });
    const retCopy = result1;
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn11(ret);
    cstate.mayLeave = true;
    return retCopy;
    
  }
  let calculate010EvalExpressionDetailed;
  
  function evalExpressionDetailed(arg0, arg1, arg2) {
    var val0 = arg0;
    let enum0;
    switch (val0) {
      case 'add': {
        enum0 = 0;
        break;
      }
      case 'sub': {
        enum0 = 1;
        break;
      }
      case 'mul': {
        enum0 = 2;
        break;
      }
      default: {
        if ((arg0) instanceof Error) {
          console.error(arg0);
        }
        
        throw new TypeError(`"${val0}" is not one of the cases of op`);
      }
    }
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="eval-expression-detailed"][Instruction::CallWasm] enter', {
      funcName: 'eval-expression-detailed',
      paramCount: 3,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010EvalExpressionDetailed',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret = calculate010EvalExpressionDetailed(enum0, toUint32(arg1), toUint32(arg2));
    endCurrentTask(3);
    var ptr1 = dataView(memory1).getUint32(ret + 4, true);
    var len1 = dataView(memory1).getUint32(ret + 8, true);
    var result1 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory1.buffer, ptr1, len1));
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="eval-expression-detailed"][Instruction::Return]', {
      funcName: 'eval-expression-detailed',
      paramCount: 1,
      async: false,
      postReturn: true
    });
    const retCopy = {
      value: dataView(memory1).getInt32(ret + 0, true) >>> 0,
      op: result1,
      x: dataView(memory1).getInt32(ret + 12, true) >>> 0,
      y: dataView(memory1).getInt32(ret + 16, true) >>> 0,
    };
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn12(ret);
    cstate.mayLeave = true;
    return retCopy;
    
  }
  let calculate010GenerateFibonacci;
  
  function generateFibonacci(arg0) {
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="generate-fibonacci"][Instruction::CallWasm] enter', {
      funcName: 'generate-fibonacci',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010GenerateFibonacci',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010GenerateFibonacci(toUint32(arg0));
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="generate-fibonacci"][Instruction::Return]', {
      funcName: 'generate-fibonacci',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn13();
    cstate.mayLeave = true;
    
    
  }
  let calculate010GenerateSquares;
  
  function generateSquares(arg0) {
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="generate-squares"][Instruction::CallWasm] enter', {
      funcName: 'generate-squares',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010GenerateSquares',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010GenerateSquares(toUint32(arg0));
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="generate-squares"][Instruction::Return]', {
      funcName: 'generate-squares',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn14();
    cstate.mayLeave = true;
    
    
  }
  let calculate010GeneratePrimes;
  
  function generatePrimes(arg0) {
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="generate-primes"][Instruction::CallWasm] enter', {
      funcName: 'generate-primes',
      paramCount: 1,
      async: false,
      postReturn: true,
    });
    const hostProvided = false;
    
    const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
      componentIdx: 3,
      isAsync: false,
      entryFnName: 'calculate010GeneratePrimes',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: true,
    });
    
    let ret;calculate010GeneratePrimes(toUint32(arg0));
    endCurrentTask(3);
    _debugLog('[iface="docs:calculator/calculate@0.1.0", function="generate-primes"][Instruction::Return]', {
      funcName: 'generate-primes',
      paramCount: 0,
      async: false,
      postReturn: true
    });
    
    let cstate = getOrCreateAsyncState(3);
    cstate.mayLeave = false;
    postReturn15();
    cstate.mayLeave = true;
    
    
  }
  calculate010ConstructorCalcSession = exports6['docs:calculator/calculate@0.1.0#[constructor]calc-session'];
  calculate010MethodCalcSessionPushOp = exports6['docs:calculator/calculate@0.1.0#[method]calc-session.push-op'];
  calculate010MethodCalcSessionGetCurrent = exports6['docs:calculator/calculate@0.1.0#[method]calc-session.get-current'];
  calculate010MethodCalcSessionGetHistory = exports6['docs:calculator/calculate@0.1.0#[method]calc-session.get-history'];
  calculate010MethodCalcSessionReset = exports6['docs:calculator/calculate@0.1.0#[method]calc-session.reset'];
  calculate010ConstructorNumberStream = exports6['docs:calculator/calculate@0.1.0#[constructor]number-stream'];
  calculate010MethodNumberStreamStartFibonacci = exports6['docs:calculator/calculate@0.1.0#[method]number-stream.start-fibonacci'];
  calculate010MethodNumberStreamStartSquares = exports6['docs:calculator/calculate@0.1.0#[method]number-stream.start-squares'];
  calculate010MethodNumberStreamStartPrimes = exports6['docs:calculator/calculate@0.1.0#[method]number-stream.start-primes'];
  calculate010MethodNumberStreamRead = exports6['docs:calculator/calculate@0.1.0#[method]number-stream.read'];
  calculate010MethodNumberStreamStop = exports6['docs:calculator/calculate@0.1.0#[method]number-stream.stop'];
  calculate010EvalExpression = exports6['docs:calculator/calculate@0.1.0#eval-expression'];
  calculate010EvalExpressionDetailed = exports6['docs:calculator/calculate@0.1.0#eval-expression-detailed'];
  calculate010GenerateFibonacci = exports6['docs:calculator/calculate@0.1.0#generate-fibonacci'];
  calculate010GenerateSquares = exports6['docs:calculator/calculate@0.1.0#generate-squares'];
  calculate010GeneratePrimes = exports6['docs:calculator/calculate@0.1.0#generate-primes'];
  const calculate010 = {
    CalcSession: CalcSession,
    NumberStream: NumberStream,
    evalExpression: evalExpression,
    evalExpressionDetailed: evalExpressionDetailed,
    generateFibonacci: generateFibonacci,
    generatePrimes: generatePrimes,
    generateSquares: generateSquares,
    
  };
  
  return { calculate: calculate010, 'docs:calculator/calculate@0.1.0': calculate010,  };
})();
let promise, resolve, reject;
function runNext (value) {
  try {
    let done;
    do {
      ({ value, done } = gen.next(value));
    } while (!(value instanceof Promise) && !done);
    if (done) {
      if (resolve) return resolve(value);
      else return value;
    }
    if (!promise) promise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));
    value.then(nextVal => done ? resolve() : runNext(nextVal), reject);
  }
  catch (e) {
    if (reject) reject(e);
    else throw e;
  }
}
const maybeSyncReturn = runNext(null);
return promise || maybeSyncReturn;
}
